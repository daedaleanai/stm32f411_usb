#pragma once

// Generated enums and structures for device {{.Name}} version {{.Version}}
// Generated by genstruct, DO NOT EDIT.

#include <stdint.h>

#define __I volatile const // 'read only' permissions
#define __O volatile       // 'write only' permissions
#define __IO volatile      // 'read / write' permissions

{{define "access"}}{{if eq . "read-only"}}__I{{else if eq . "write-only"}}__O{{else if ne . "reserved"}}__IO{{end}}{{end}}

{{- range .Peripherals}}
{{- if .Registers}}
{{- if .Description}}
/* {{.Description}} */
{{- end}}
struct {{.Name}}_Type {
{{- range .Registers}}
{{- if .Union}}
	union {  // @{{.AddressOffset}}
		{{template "access" .Access}} uint{{.Size}}_t {{.Name}}{{if gt .ArraySize 1}}[{{.ArraySize}}]{{end}}; // {{.Description}}
{{- range .Union}}
		{{template "access" .Access}} uint{{.Size}}_t {{.Name}}{{if gt .ArraySize 1}}[{{.ArraySize}}]{{end}}; // {{.Description}}
{{- end}}
	};
{{- else}}
	{{template "access" .Access}} uint{{.Size}}_t {{.Name}}{{if gt .ArraySize 1}}[{{.ArraySize}}]{{end}}; // @{{.AddressOffset}} {{.Description}}
{{- end}}
{{- end}}
};
{{- $pname := .Name}}
{{- range .Registers}}
	{{- $rname := .Name}}
	{{- $regwidth := .Size}}
	{{- if .HasEnumFields}}

// {{$pname}}->{{$rname}} {{.Description}}
enum {
{{- range .Fields}}
	{{if ne .BitWidth $regwidth}}
		{{- if gt .BitWidth 1 -}}
			{{upper $pname}}_{{upper $rname}}_{{upper .Name}} = ((1UL<<{{.BitWidth}})-1) << {{.BitOffset}},{{if .Description}} // {{.Description}}{{end}}
		{{- else -}}
			{{upper $pname}}_{{upper $rname}}_{{upper .Name}} = 1UL<<{{.BitOffset}},{{if .Description}} // {{.Description}}{{end}}
		{{- end -}}
	{{- end}}
{{- end}}		
};
{{- if ne .Access "read-only"}}
{{- range .Fields}}
	{{- if ne .BitWidth $regwidth}}{{if gt .BitWidth 1}}
inline void {{lower $pname}}_{{lower $rname}}_set_{{lower .Name}}(struct {{$pname}}_Type* p, uint32_t val) { p->{{$rname}} = (p->{{$rname}} & ~{{upper $pname}}_{{upper $rname}}_{{upper .Name}}) | ((val<<{{.BitOffset}}) & {{upper $pname}}_{{upper $rname}}_{{upper .Name}}); }
	{{- end}}{{end}}
{{- end}}		
{{- end}}		
{{- range .Fields}}
	{{- if ne .BitWidth $regwidth}}
		{{- if gt .BitWidth 1}}
inline uint32_t {{lower $pname}}_{{lower $rname}}_get_{{lower .Name}}(struct {{$pname}}_Type* p) { return (p->{{$rname}} & {{upper $pname}}_{{upper $rname}}_{{upper .Name}}) >> {{.BitOffset}} ; }
		{{- end}}
	{{- end}}
{{- end}}		
	{{- end}}
{{- end}}
{{- end}}
{{if .Extends}}
{{- $dname := .Name}}
// Valid Casts:
{{range .Extends}} 
inline struct {{.Name}}_Type* {{$dname}}_as_{{.Name}}_Type(struct {{$dname}}_Type* p) { return (struct {{.Name}}_Type*)p; }
{{end}}
{{end}}
{{- end}}

#undef __I
#undef __O
#undef __IO

{{range .Peripherals}}
{{- if .BaseAddress}}
{{- if .DerivedFrom}}
struct {{.DerivedFrom}}_Type 	{{.Name}};	// @{{.BaseAddress.Hex}}
{{- else}}
struct {{.Name}}_Type	{{.Name}};	// @{{.BaseAddress.Hex}} {{if .Extends}}Also:{{range .Extends}} {{.Name}}_Type{{end}}{{end}}
{{- end}}
{{- end}}
{{- end}}

