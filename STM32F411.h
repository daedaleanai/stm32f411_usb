#pragma once

// Generated enums and structures for device STM32F411 version 1.1
// Generated by genstruct, DO NOT EDIT.

#include "cortex_m4.h"
#include <stdint.h>

#define __I volatile const // 'read only' permissions
#define __O volatile       // 'write only' permissions
#define __IO volatile      // 'read / write' permissions

/* Analog-to-digital converter */
struct ADC1_Type {
	__IO uint8_t SR;            // @0 status register
	uint8_t      RESERVED0[3];  // @1
	__IO uint32_t CR1;          // @4 control register 1
	__IO uint32_t CR2;          // @8 control register 2
	__IO uint32_t SMPR1;        // @12 sample time register 1
	__IO uint32_t SMPR2;        // @16 sample time register 2
	__IO uint16_t JOFR1;        // @20 injected channel data offset register x
	uint8_t       RESERVED1[2]; // @22
	__IO uint16_t JOFR2;        // @24 injected channel data offset register x
	uint8_t       RESERVED2[2]; // @26
	__IO uint16_t JOFR3;        // @28 injected channel data offset register x
	uint8_t       RESERVED3[2]; // @30
	__IO uint16_t JOFR4;        // @32 injected channel data offset register x
	uint8_t       RESERVED4[2]; // @34
	__IO uint16_t HTR;          // @36 watchdog higher threshold register
	uint8_t       RESERVED5[2]; // @38
	__IO uint16_t LTR;          // @40 watchdog lower threshold register
	uint8_t       RESERVED6[2]; // @42
	__IO uint32_t SQR1;         // @44 regular sequence register 1
	__IO uint32_t SQR2;         // @48 regular sequence register 2
	__IO uint32_t SQR3;         // @52 regular sequence register 3
	__IO uint32_t JSQR;         // @56 injected sequence register
	__I uint16_t JDR1;          // @60 injected data register x
	uint8_t      RESERVED7[2];  // @62
	__I uint16_t JDR2;          // @64 injected data register x
	uint8_t      RESERVED8[2];  // @66
	__I uint16_t JDR3;          // @68 injected data register x
	uint8_t      RESERVED9[2];  // @70
	__I uint16_t JDR4;          // @72 injected data register x
	uint8_t      RESERVED10[2]; // @74
	__I uint16_t DR;            // @76 regular data register
};

// ADC1->SR status register
enum {
	ADC1_SR_OVR   = 1UL << 5, // Overrun
	ADC1_SR_STRT  = 1UL << 4, // Regular channel start flag
	ADC1_SR_JSTRT = 1UL << 3, // Injected channel start flag
	ADC1_SR_JEOC  = 1UL << 2, // Injected channel end of conversion
	ADC1_SR_EOC   = 1UL << 1, // Regular channel end of conversion
	ADC1_SR_AWD   = 1UL << 0, // Analog watchdog flag
};

// ADC1->CR1 control register 1
enum {
	ADC1_CR1_OVRIE   = 1UL << 26,              // Overrun interrupt enable
	ADC1_CR1_RES     = ((1UL << 2) - 1) << 24, // Resolution
	ADC1_CR1_AWDEN   = 1UL << 23,              // Analog watchdog enable on regular channels
	ADC1_CR1_JAWDEN  = 1UL << 22,              // Analog watchdog enable on injected channels
	ADC1_CR1_DISCNUM = ((1UL << 3) - 1) << 13, // Discontinuous mode channel count
	ADC1_CR1_JDISCEN = 1UL << 12,              // Discontinuous mode on injected channels
	ADC1_CR1_DISCEN  = 1UL << 11,              // Discontinuous mode on regular channels
	ADC1_CR1_JAUTO   = 1UL << 10,              // Automatic injected group conversion
	ADC1_CR1_AWDSGL  = 1UL << 9,               // Enable the watchdog on a single channel in scan mode
	ADC1_CR1_SCAN    = 1UL << 8,               // Scan mode
	ADC1_CR1_JEOCIE  = 1UL << 7,               // Interrupt enable for injected channels
	ADC1_CR1_AWDIE   = 1UL << 6,               // Analog watchdog interrupt enable
	ADC1_CR1_EOCIE   = 1UL << 5,               // Interrupt enable for EOC
	ADC1_CR1_AWDCH   = ((1UL << 5) - 1) << 0,  // Analog watchdog channel select bits
};
inline void adc1_cr1_set_res(struct ADC1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~ADC1_CR1_RES) | ((val << 24) & ADC1_CR1_RES); }
inline void adc1_cr1_set_discnum(struct ADC1_Type* p, uint32_t val) {
	p->CR1 = (p->CR1 & ~ADC1_CR1_DISCNUM) | ((val << 13) & ADC1_CR1_DISCNUM);
}
inline void adc1_cr1_set_awdch(struct ADC1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~ADC1_CR1_AWDCH) | ((val << 0) & ADC1_CR1_AWDCH); }
inline uint32_t adc1_cr1_get_res(struct ADC1_Type* p) { return (p->CR1 & ADC1_CR1_RES) >> 24; }
inline uint32_t adc1_cr1_get_discnum(struct ADC1_Type* p) { return (p->CR1 & ADC1_CR1_DISCNUM) >> 13; }
inline uint32_t adc1_cr1_get_awdch(struct ADC1_Type* p) { return (p->CR1 & ADC1_CR1_AWDCH) >> 0; }

// ADC1->CR2 control register 2
enum {
	ADC1_CR2_SWSTART  = 1UL << 30,              // Start conversion of regular channels
	ADC1_CR2_EXTEN    = ((1UL << 2) - 1) << 28, // External trigger enable for regular channels
	ADC1_CR2_EXTSEL   = ((1UL << 4) - 1) << 24, // External event select for regular group
	ADC1_CR2_JSWSTART = 1UL << 22,              // Start conversion of injected channels
	ADC1_CR2_JEXTEN   = ((1UL << 2) - 1) << 20, // External trigger enable for injected channels
	ADC1_CR2_JEXTSEL  = ((1UL << 4) - 1) << 16, // External event select for injected group
	ADC1_CR2_ALIGN    = 1UL << 11,              // Data alignment
	ADC1_CR2_EOCS     = 1UL << 10,              // End of conversion selection
	ADC1_CR2_DDS      = 1UL << 9,               // DMA disable selection (for single ADC mode)
	ADC1_CR2_DMA      = 1UL << 8,               // Direct memory access mode (for single ADC mode)
	ADC1_CR2_CONT     = 1UL << 1,               // Continuous conversion
	ADC1_CR2_ADON     = 1UL << 0,               // A/D Converter ON / OFF
};
inline void adc1_cr2_set_exten(struct ADC1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~ADC1_CR2_EXTEN) | ((val << 28) & ADC1_CR2_EXTEN); }
inline void adc1_cr2_set_extsel(struct ADC1_Type* p, uint32_t val) {
	p->CR2 = (p->CR2 & ~ADC1_CR2_EXTSEL) | ((val << 24) & ADC1_CR2_EXTSEL);
}
inline void adc1_cr2_set_jexten(struct ADC1_Type* p, uint32_t val) {
	p->CR2 = (p->CR2 & ~ADC1_CR2_JEXTEN) | ((val << 20) & ADC1_CR2_JEXTEN);
}
inline void adc1_cr2_set_jextsel(struct ADC1_Type* p, uint32_t val) {
	p->CR2 = (p->CR2 & ~ADC1_CR2_JEXTSEL) | ((val << 16) & ADC1_CR2_JEXTSEL);
}
inline uint32_t adc1_cr2_get_exten(struct ADC1_Type* p) { return (p->CR2 & ADC1_CR2_EXTEN) >> 28; }
inline uint32_t adc1_cr2_get_extsel(struct ADC1_Type* p) { return (p->CR2 & ADC1_CR2_EXTSEL) >> 24; }
inline uint32_t adc1_cr2_get_jexten(struct ADC1_Type* p) { return (p->CR2 & ADC1_CR2_JEXTEN) >> 20; }
inline uint32_t adc1_cr2_get_jextsel(struct ADC1_Type* p) { return (p->CR2 & ADC1_CR2_JEXTSEL) >> 16; }

// ADC1->JOFR1 injected channel data offset register x
enum {
	ADC1_JOFR1_JOFFSET1 = ((1UL << 12) - 1) << 0, // Data offset for injected channel x
};
inline void adc1_jofr1_set_joffset1(struct ADC1_Type* p, uint32_t val) {
	p->JOFR1 = (p->JOFR1 & ~ADC1_JOFR1_JOFFSET1) | ((val << 0) & ADC1_JOFR1_JOFFSET1);
}
inline uint32_t adc1_jofr1_get_joffset1(struct ADC1_Type* p) { return (p->JOFR1 & ADC1_JOFR1_JOFFSET1) >> 0; }

// ADC1->JOFR2 injected channel data offset register x
enum {
	ADC1_JOFR2_JOFFSET2 = ((1UL << 12) - 1) << 0, // Data offset for injected channel x
};
inline void adc1_jofr2_set_joffset2(struct ADC1_Type* p, uint32_t val) {
	p->JOFR2 = (p->JOFR2 & ~ADC1_JOFR2_JOFFSET2) | ((val << 0) & ADC1_JOFR2_JOFFSET2);
}
inline uint32_t adc1_jofr2_get_joffset2(struct ADC1_Type* p) { return (p->JOFR2 & ADC1_JOFR2_JOFFSET2) >> 0; }

// ADC1->JOFR3 injected channel data offset register x
enum {
	ADC1_JOFR3_JOFFSET3 = ((1UL << 12) - 1) << 0, // Data offset for injected channel x
};
inline void adc1_jofr3_set_joffset3(struct ADC1_Type* p, uint32_t val) {
	p->JOFR3 = (p->JOFR3 & ~ADC1_JOFR3_JOFFSET3) | ((val << 0) & ADC1_JOFR3_JOFFSET3);
}
inline uint32_t adc1_jofr3_get_joffset3(struct ADC1_Type* p) { return (p->JOFR3 & ADC1_JOFR3_JOFFSET3) >> 0; }

// ADC1->JOFR4 injected channel data offset register x
enum {
	ADC1_JOFR4_JOFFSET4 = ((1UL << 12) - 1) << 0, // Data offset for injected channel x
};
inline void adc1_jofr4_set_joffset4(struct ADC1_Type* p, uint32_t val) {
	p->JOFR4 = (p->JOFR4 & ~ADC1_JOFR4_JOFFSET4) | ((val << 0) & ADC1_JOFR4_JOFFSET4);
}
inline uint32_t adc1_jofr4_get_joffset4(struct ADC1_Type* p) { return (p->JOFR4 & ADC1_JOFR4_JOFFSET4) >> 0; }

// ADC1->HTR watchdog higher threshold register
enum {
	ADC1_HTR_HT = ((1UL << 12) - 1) << 0, // Analog watchdog higher threshold
};
inline void     adc1_htr_set_ht(struct ADC1_Type* p, uint32_t val) { p->HTR = (p->HTR & ~ADC1_HTR_HT) | ((val << 0) & ADC1_HTR_HT); }
inline uint32_t adc1_htr_get_ht(struct ADC1_Type* p) { return (p->HTR & ADC1_HTR_HT) >> 0; }

// ADC1->LTR watchdog lower threshold register
enum {
	ADC1_LTR_LT = ((1UL << 12) - 1) << 0, // Analog watchdog lower threshold
};
inline void     adc1_ltr_set_lt(struct ADC1_Type* p, uint32_t val) { p->LTR = (p->LTR & ~ADC1_LTR_LT) | ((val << 0) & ADC1_LTR_LT); }
inline uint32_t adc1_ltr_get_lt(struct ADC1_Type* p) { return (p->LTR & ADC1_LTR_LT) >> 0; }

// ADC1->SQR1 regular sequence register 1
enum {
	ADC1_SQR1_L    = ((1UL << 4) - 1) << 20, // Regular channel sequence length
	ADC1_SQR1_SQ16 = ((1UL << 5) - 1) << 15, // 16th conversion in regular sequence
	ADC1_SQR1_SQ15 = ((1UL << 5) - 1) << 10, // 15th conversion in regular sequence
	ADC1_SQR1_SQ14 = ((1UL << 5) - 1) << 5,  // 14th conversion in regular sequence
	ADC1_SQR1_SQ13 = ((1UL << 5) - 1) << 0,  // 13th conversion in regular sequence
};
inline void adc1_sqr1_set_l(struct ADC1_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC1_SQR1_L) | ((val << 20) & ADC1_SQR1_L); }
inline void adc1_sqr1_set_sq16(struct ADC1_Type* p, uint32_t val) {
	p->SQR1 = (p->SQR1 & ~ADC1_SQR1_SQ16) | ((val << 15) & ADC1_SQR1_SQ16);
}
inline void adc1_sqr1_set_sq15(struct ADC1_Type* p, uint32_t val) {
	p->SQR1 = (p->SQR1 & ~ADC1_SQR1_SQ15) | ((val << 10) & ADC1_SQR1_SQ15);
}
inline void adc1_sqr1_set_sq14(struct ADC1_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC1_SQR1_SQ14) | ((val << 5) & ADC1_SQR1_SQ14); }
inline void adc1_sqr1_set_sq13(struct ADC1_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC1_SQR1_SQ13) | ((val << 0) & ADC1_SQR1_SQ13); }
inline uint32_t adc1_sqr1_get_l(struct ADC1_Type* p) { return (p->SQR1 & ADC1_SQR1_L) >> 20; }
inline uint32_t adc1_sqr1_get_sq16(struct ADC1_Type* p) { return (p->SQR1 & ADC1_SQR1_SQ16) >> 15; }
inline uint32_t adc1_sqr1_get_sq15(struct ADC1_Type* p) { return (p->SQR1 & ADC1_SQR1_SQ15) >> 10; }
inline uint32_t adc1_sqr1_get_sq14(struct ADC1_Type* p) { return (p->SQR1 & ADC1_SQR1_SQ14) >> 5; }
inline uint32_t adc1_sqr1_get_sq13(struct ADC1_Type* p) { return (p->SQR1 & ADC1_SQR1_SQ13) >> 0; }

// ADC1->SQR2 regular sequence register 2
enum {
	ADC1_SQR2_SQ12 = ((1UL << 5) - 1) << 25, // 12th conversion in regular sequence
	ADC1_SQR2_SQ11 = ((1UL << 5) - 1) << 20, // 11th conversion in regular sequence
	ADC1_SQR2_SQ10 = ((1UL << 5) - 1) << 15, // 10th conversion in regular sequence
	ADC1_SQR2_SQ9  = ((1UL << 5) - 1) << 10, // 9th conversion in regular sequence
	ADC1_SQR2_SQ8  = ((1UL << 5) - 1) << 5,  // 8th conversion in regular sequence
	ADC1_SQR2_SQ7  = ((1UL << 5) - 1) << 0,  // 7th conversion in regular sequence
};
inline void adc1_sqr2_set_sq12(struct ADC1_Type* p, uint32_t val) {
	p->SQR2 = (p->SQR2 & ~ADC1_SQR2_SQ12) | ((val << 25) & ADC1_SQR2_SQ12);
}
inline void adc1_sqr2_set_sq11(struct ADC1_Type* p, uint32_t val) {
	p->SQR2 = (p->SQR2 & ~ADC1_SQR2_SQ11) | ((val << 20) & ADC1_SQR2_SQ11);
}
inline void adc1_sqr2_set_sq10(struct ADC1_Type* p, uint32_t val) {
	p->SQR2 = (p->SQR2 & ~ADC1_SQR2_SQ10) | ((val << 15) & ADC1_SQR2_SQ10);
}
inline void adc1_sqr2_set_sq9(struct ADC1_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC1_SQR2_SQ9) | ((val << 10) & ADC1_SQR2_SQ9); }
inline void adc1_sqr2_set_sq8(struct ADC1_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC1_SQR2_SQ8) | ((val << 5) & ADC1_SQR2_SQ8); }
inline void adc1_sqr2_set_sq7(struct ADC1_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC1_SQR2_SQ7) | ((val << 0) & ADC1_SQR2_SQ7); }
inline uint32_t adc1_sqr2_get_sq12(struct ADC1_Type* p) { return (p->SQR2 & ADC1_SQR2_SQ12) >> 25; }
inline uint32_t adc1_sqr2_get_sq11(struct ADC1_Type* p) { return (p->SQR2 & ADC1_SQR2_SQ11) >> 20; }
inline uint32_t adc1_sqr2_get_sq10(struct ADC1_Type* p) { return (p->SQR2 & ADC1_SQR2_SQ10) >> 15; }
inline uint32_t adc1_sqr2_get_sq9(struct ADC1_Type* p) { return (p->SQR2 & ADC1_SQR2_SQ9) >> 10; }
inline uint32_t adc1_sqr2_get_sq8(struct ADC1_Type* p) { return (p->SQR2 & ADC1_SQR2_SQ8) >> 5; }
inline uint32_t adc1_sqr2_get_sq7(struct ADC1_Type* p) { return (p->SQR2 & ADC1_SQR2_SQ7) >> 0; }

// ADC1->SQR3 regular sequence register 3
enum {
	ADC1_SQR3_SQ6 = ((1UL << 5) - 1) << 25, // 6th conversion in regular sequence
	ADC1_SQR3_SQ5 = ((1UL << 5) - 1) << 20, // 5th conversion in regular sequence
	ADC1_SQR3_SQ4 = ((1UL << 5) - 1) << 15, // 4th conversion in regular sequence
	ADC1_SQR3_SQ3 = ((1UL << 5) - 1) << 10, // 3rd conversion in regular sequence
	ADC1_SQR3_SQ2 = ((1UL << 5) - 1) << 5,  // 2nd conversion in regular sequence
	ADC1_SQR3_SQ1 = ((1UL << 5) - 1) << 0,  // 1st conversion in regular sequence
};
inline void adc1_sqr3_set_sq6(struct ADC1_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC1_SQR3_SQ6) | ((val << 25) & ADC1_SQR3_SQ6); }
inline void adc1_sqr3_set_sq5(struct ADC1_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC1_SQR3_SQ5) | ((val << 20) & ADC1_SQR3_SQ5); }
inline void adc1_sqr3_set_sq4(struct ADC1_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC1_SQR3_SQ4) | ((val << 15) & ADC1_SQR3_SQ4); }
inline void adc1_sqr3_set_sq3(struct ADC1_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC1_SQR3_SQ3) | ((val << 10) & ADC1_SQR3_SQ3); }
inline void adc1_sqr3_set_sq2(struct ADC1_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC1_SQR3_SQ2) | ((val << 5) & ADC1_SQR3_SQ2); }
inline void adc1_sqr3_set_sq1(struct ADC1_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC1_SQR3_SQ1) | ((val << 0) & ADC1_SQR3_SQ1); }
inline uint32_t adc1_sqr3_get_sq6(struct ADC1_Type* p) { return (p->SQR3 & ADC1_SQR3_SQ6) >> 25; }
inline uint32_t adc1_sqr3_get_sq5(struct ADC1_Type* p) { return (p->SQR3 & ADC1_SQR3_SQ5) >> 20; }
inline uint32_t adc1_sqr3_get_sq4(struct ADC1_Type* p) { return (p->SQR3 & ADC1_SQR3_SQ4) >> 15; }
inline uint32_t adc1_sqr3_get_sq3(struct ADC1_Type* p) { return (p->SQR3 & ADC1_SQR3_SQ3) >> 10; }
inline uint32_t adc1_sqr3_get_sq2(struct ADC1_Type* p) { return (p->SQR3 & ADC1_SQR3_SQ2) >> 5; }
inline uint32_t adc1_sqr3_get_sq1(struct ADC1_Type* p) { return (p->SQR3 & ADC1_SQR3_SQ1) >> 0; }

// ADC1->JSQR injected sequence register
enum {
	ADC1_JSQR_JL   = ((1UL << 2) - 1) << 20, // Injected sequence length
	ADC1_JSQR_JSQ4 = ((1UL << 5) - 1) << 15, // 4th conversion in injected sequence
	ADC1_JSQR_JSQ3 = ((1UL << 5) - 1) << 10, // 3rd conversion in injected sequence
	ADC1_JSQR_JSQ2 = ((1UL << 5) - 1) << 5,  // 2nd conversion in injected sequence
	ADC1_JSQR_JSQ1 = ((1UL << 5) - 1) << 0,  // 1st conversion in injected sequence
};
inline void adc1_jsqr_set_jl(struct ADC1_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC1_JSQR_JL) | ((val << 20) & ADC1_JSQR_JL); }
inline void adc1_jsqr_set_jsq4(struct ADC1_Type* p, uint32_t val) {
	p->JSQR = (p->JSQR & ~ADC1_JSQR_JSQ4) | ((val << 15) & ADC1_JSQR_JSQ4);
}
inline void adc1_jsqr_set_jsq3(struct ADC1_Type* p, uint32_t val) {
	p->JSQR = (p->JSQR & ~ADC1_JSQR_JSQ3) | ((val << 10) & ADC1_JSQR_JSQ3);
}
inline void adc1_jsqr_set_jsq2(struct ADC1_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC1_JSQR_JSQ2) | ((val << 5) & ADC1_JSQR_JSQ2); }
inline void adc1_jsqr_set_jsq1(struct ADC1_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC1_JSQR_JSQ1) | ((val << 0) & ADC1_JSQR_JSQ1); }
inline uint32_t adc1_jsqr_get_jl(struct ADC1_Type* p) { return (p->JSQR & ADC1_JSQR_JL) >> 20; }
inline uint32_t adc1_jsqr_get_jsq4(struct ADC1_Type* p) { return (p->JSQR & ADC1_JSQR_JSQ4) >> 15; }
inline uint32_t adc1_jsqr_get_jsq3(struct ADC1_Type* p) { return (p->JSQR & ADC1_JSQR_JSQ3) >> 10; }
inline uint32_t adc1_jsqr_get_jsq2(struct ADC1_Type* p) { return (p->JSQR & ADC1_JSQR_JSQ2) >> 5; }
inline uint32_t adc1_jsqr_get_jsq1(struct ADC1_Type* p) { return (p->JSQR & ADC1_JSQR_JSQ1) >> 0; }

/* ADC common registers */
struct ADC_COMMON_Type {
	__I uint32_t CSR;  // @0 ADC Common status register
	__IO uint32_t CCR; // @4 ADC common control register
};

// ADC_COMMON->CSR ADC Common status register
enum {
	ADC_COMMON_CSR_OVR3   = 1UL << 21, // Overrun flag of ADC3
	ADC_COMMON_CSR_STRT3  = 1UL << 20, // Regular channel Start flag of ADC 3
	ADC_COMMON_CSR_JSTRT3 = 1UL << 19, // Injected channel Start flag of ADC 3
	ADC_COMMON_CSR_JEOC3  = 1UL << 18, // Injected channel end of conversion of ADC 3
	ADC_COMMON_CSR_EOC3   = 1UL << 17, // End of conversion of ADC 3
	ADC_COMMON_CSR_AWD3   = 1UL << 16, // Analog watchdog flag of ADC 3
	ADC_COMMON_CSR_OVR2   = 1UL << 13, // Overrun flag of ADC 2
	ADC_COMMON_CSR_STRT2  = 1UL << 12, // Regular channel Start flag of ADC 2
	ADC_COMMON_CSR_JSTRT2 = 1UL << 11, // Injected channel Start flag of ADC 2
	ADC_COMMON_CSR_JEOC2  = 1UL << 10, // Injected channel end of conversion of ADC 2
	ADC_COMMON_CSR_EOC2   = 1UL << 9,  // End of conversion of ADC 2
	ADC_COMMON_CSR_AWD2   = 1UL << 8,  // Analog watchdog flag of ADC 2
	ADC_COMMON_CSR_OVR1   = 1UL << 5,  // Overrun flag of ADC 1
	ADC_COMMON_CSR_STRT1  = 1UL << 4,  // Regular channel Start flag of ADC 1
	ADC_COMMON_CSR_JSTRT1 = 1UL << 3,  // Injected channel Start flag of ADC 1
	ADC_COMMON_CSR_JEOC1  = 1UL << 2,  // Injected channel end of conversion of ADC 1
	ADC_COMMON_CSR_EOC1   = 1UL << 1,  // End of conversion of ADC 1
	ADC_COMMON_CSR_AWD1   = 1UL << 0,  // Analog watchdog flag of ADC 1
};

// ADC_COMMON->CCR ADC common control register
enum {
	ADC_COMMON_CCR_TSVREFE = 1UL << 23,              // Temperature sensor and VREFINT enable
	ADC_COMMON_CCR_VBATE   = 1UL << 22,              // VBAT enable
	ADC_COMMON_CCR_ADCPRE  = ((1UL << 2) - 1) << 16, // ADC prescaler
	ADC_COMMON_CCR_DMA     = ((1UL << 2) - 1) << 14, // Direct memory access mode for multi ADC mode
	ADC_COMMON_CCR_DDS     = 1UL << 13,              // DMA disable selection for multi-ADC mode
	ADC_COMMON_CCR_DELAY   = ((1UL << 4) - 1) << 8,  // Delay between 2 sampling phases
};
inline void adc_common_ccr_set_adcpre(struct ADC_COMMON_Type* p, uint32_t val) {
	p->CCR = (p->CCR & ~ADC_COMMON_CCR_ADCPRE) | ((val << 16) & ADC_COMMON_CCR_ADCPRE);
}
inline void adc_common_ccr_set_dma(struct ADC_COMMON_Type* p, uint32_t val) {
	p->CCR = (p->CCR & ~ADC_COMMON_CCR_DMA) | ((val << 14) & ADC_COMMON_CCR_DMA);
}
inline void adc_common_ccr_set_delay(struct ADC_COMMON_Type* p, uint32_t val) {
	p->CCR = (p->CCR & ~ADC_COMMON_CCR_DELAY) | ((val << 8) & ADC_COMMON_CCR_DELAY);
}
inline uint32_t adc_common_ccr_get_adcpre(struct ADC_COMMON_Type* p) { return (p->CCR & ADC_COMMON_CCR_ADCPRE) >> 16; }
inline uint32_t adc_common_ccr_get_dma(struct ADC_COMMON_Type* p) { return (p->CCR & ADC_COMMON_CCR_DMA) >> 14; }
inline uint32_t adc_common_ccr_get_delay(struct ADC_COMMON_Type* p) { return (p->CCR & ADC_COMMON_CCR_DELAY) >> 8; }

/* Cryptographic processor */
struct CRC_Type {
	__IO uint32_t DR;          // @0 Data register
	__IO uint8_t IDR;          // @4 Independent Data register
	uint8_t      RESERVED0[3]; // @5
	__O uint8_t CR;            // @8 Control register
};

// CRC->CR Control register
enum {
	CRC_CR_CR = 1UL << 0, // Control regidter
};

/* Debug support */
struct DBG_Type {
	__I uint32_t DBGMCU_IDCODE;   // @0 IDCODE
	__IO uint8_t DBGMCU_CR;       // @4 Control Register
	uint8_t      RESERVED0[3];    // @5
	__IO uint32_t DBGMCU_APB1_FZ; // @8 Debug MCU APB1 Freeze registe
	__IO uint32_t DBGMCU_APB2_FZ; // @12 Debug MCU APB2 Freeze registe
};

// DBG->DBGMCU_IDCODE IDCODE
enum {
	DBG_DBGMCU_IDCODE_REV_ID = ((1UL << 16) - 1) << 16, // REV_ID
	DBG_DBGMCU_IDCODE_DEV_ID = ((1UL << 12) - 1) << 0,  // DEV_ID
};
inline uint32_t dbg_dbgmcu_idcode_get_rev_id(struct DBG_Type* p) { return (p->DBGMCU_IDCODE & DBG_DBGMCU_IDCODE_REV_ID) >> 16; }
inline uint32_t dbg_dbgmcu_idcode_get_dev_id(struct DBG_Type* p) { return (p->DBGMCU_IDCODE & DBG_DBGMCU_IDCODE_DEV_ID) >> 0; }

// DBG->DBGMCU_CR Control Register
enum {
	DBG_DBGMCU_CR_TRACE_MODE  = ((1UL << 2) - 1) << 6, // TRACE_MODE
	DBG_DBGMCU_CR_TRACE_IOEN  = 1UL << 5,              // TRACE_IOEN
	DBG_DBGMCU_CR_DBG_STANDBY = 1UL << 2,              // DBG_STANDBY
	DBG_DBGMCU_CR_DBG_STOP    = 1UL << 1,              // DBG_STOP
	DBG_DBGMCU_CR_DBG_SLEEP   = 1UL << 0,              // DBG_SLEEP
};
inline void dbg_dbgmcu_cr_set_trace_mode(struct DBG_Type* p, uint32_t val) {
	p->DBGMCU_CR = (p->DBGMCU_CR & ~DBG_DBGMCU_CR_TRACE_MODE) | ((val << 6) & DBG_DBGMCU_CR_TRACE_MODE);
}
inline uint32_t dbg_dbgmcu_cr_get_trace_mode(struct DBG_Type* p) { return (p->DBGMCU_CR & DBG_DBGMCU_CR_TRACE_MODE) >> 6; }

// DBG->DBGMCU_APB1_FZ Debug MCU APB1 Freeze registe
enum {
	DBG_DBGMCU_APB1_FZ_DBG_I2C3SMBUS_TIMEOUT  = 1UL << 23, // DBG_J2C3SMBUS_TIMEOUT
	DBG_DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT = 1UL << 22, // DBG_J2C2_SMBUS_TIMEOUT
	DBG_DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT = 1UL << 21, // DBG_J2C1_SMBUS_TIMEOUT
	DBG_DBGMCU_APB1_FZ_DBG_IWDEG_STOP         = 1UL << 12, // DBG_IWDEG_STOP
	DBG_DBGMCU_APB1_FZ_DBG_WWDG_STOP          = 1UL << 11, // DBG_WWDG_STOP
	DBG_DBGMCU_APB1_FZ_DBG_RTC_STOP           = 1UL << 10, // RTC stopped when Core is halted
	DBG_DBGMCU_APB1_FZ_DBG_TIM5_STOP          = 1UL << 3,  // DBG_TIM5_STOP
	DBG_DBGMCU_APB1_FZ_DBG_TIM4_STOP          = 1UL << 2,  // DBG_TIM4_STOP
	DBG_DBGMCU_APB1_FZ_DBG_TIM3_STOP          = 1UL << 1,  // DBG_TIM3 _STOP
	DBG_DBGMCU_APB1_FZ_DBG_TIM2_STOP          = 1UL << 0,  // DBG_TIM2_STOP
};

// DBG->DBGMCU_APB2_FZ Debug MCU APB2 Freeze registe
enum {
	DBG_DBGMCU_APB2_FZ_DBG_TIM11_STOP = 1UL << 18, // TIM11 counter stopped when core is halted
	DBG_DBGMCU_APB2_FZ_DBG_TIM10_STOP = 1UL << 17, // TIM10 counter stopped when core is halted
	DBG_DBGMCU_APB2_FZ_DBG_TIM9_STOP  = 1UL << 16, // TIM9 counter stopped when core is halted
	DBG_DBGMCU_APB2_FZ_DBG_TIM1_STOP  = 1UL << 0,  // TIM1 counter stopped when core is halted
};

/* DMA controller */
struct DMA2_Type {
	__I uint32_t LISR;           // @0 low interrupt status register
	__I uint32_t HISR;           // @4 high interrupt status register
	__O uint32_t LIFCR;          // @8 low interrupt flag clear register
	__O uint32_t HIFCR;          // @12 high interrupt flag clear register
	__IO uint32_t S0CR;          // @16 stream x configuration register
	__IO uint16_t S0NDTR;        // @20 stream x number of data register
	uint8_t       RESERVED0[2];  // @22
	__IO uint32_t S0PAR;         // @24 stream x peripheral address register
	__IO uint32_t S0M0AR;        // @28 stream x memory 0 address register
	__IO uint32_t S0M1AR;        // @32 stream x memory 1 address register
	__IO uint8_t S0FCR;          // @36 stream x FIFO control register
	uint8_t      RESERVED1[3];   // @37
	__IO uint32_t S1CR;          // @40 stream x configuration register
	__IO uint16_t S1NDTR;        // @44 stream x number of data register
	uint8_t       RESERVED2[2];  // @46
	__IO uint32_t S1PAR;         // @48 stream x peripheral address register
	__IO uint32_t S1M0AR;        // @52 stream x memory 0 address register
	__IO uint32_t S1M1AR;        // @56 stream x memory 1 address register
	__IO uint8_t S1FCR;          // @60 stream x FIFO control register
	uint8_t      RESERVED3[3];   // @61
	__IO uint32_t S2CR;          // @64 stream x configuration register
	__IO uint16_t S2NDTR;        // @68 stream x number of data register
	uint8_t       RESERVED4[2];  // @70
	__IO uint32_t S2PAR;         // @72 stream x peripheral address register
	__IO uint32_t S2M0AR;        // @76 stream x memory 0 address register
	__IO uint32_t S2M1AR;        // @80 stream x memory 1 address register
	__IO uint8_t S2FCR;          // @84 stream x FIFO control register
	uint8_t      RESERVED5[3];   // @85
	__IO uint32_t S3CR;          // @88 stream x configuration register
	__IO uint16_t S3NDTR;        // @92 stream x number of data register
	uint8_t       RESERVED6[2];  // @94
	__IO uint32_t S3PAR;         // @96 stream x peripheral address register
	__IO uint32_t S3M0AR;        // @100 stream x memory 0 address register
	__IO uint32_t S3M1AR;        // @104 stream x memory 1 address register
	__IO uint8_t S3FCR;          // @108 stream x FIFO control register
	uint8_t      RESERVED7[3];   // @109
	__IO uint32_t S4CR;          // @112 stream x configuration register
	__IO uint16_t S4NDTR;        // @116 stream x number of data register
	uint8_t       RESERVED8[2];  // @118
	__IO uint32_t S4PAR;         // @120 stream x peripheral address register
	__IO uint32_t S4M0AR;        // @124 stream x memory 0 address register
	__IO uint32_t S4M1AR;        // @128 stream x memory 1 address register
	__IO uint8_t S4FCR;          // @132 stream x FIFO control register
	uint8_t      RESERVED9[3];   // @133
	__IO uint32_t S5CR;          // @136 stream x configuration register
	__IO uint16_t S5NDTR;        // @140 stream x number of data register
	uint8_t       RESERVED10[2]; // @142
	__IO uint32_t S5PAR;         // @144 stream x peripheral address register
	__IO uint32_t S5M0AR;        // @148 stream x memory 0 address register
	__IO uint32_t S5M1AR;        // @152 stream x memory 1 address register
	__IO uint8_t S5FCR;          // @156 stream x FIFO control register
	uint8_t      RESERVED11[3];  // @157
	__IO uint32_t S6CR;          // @160 stream x configuration register
	__IO uint16_t S6NDTR;        // @164 stream x number of data register
	uint8_t       RESERVED12[2]; // @166
	__IO uint32_t S6PAR;         // @168 stream x peripheral address register
	__IO uint32_t S6M0AR;        // @172 stream x memory 0 address register
	__IO uint32_t S6M1AR;        // @176 stream x memory 1 address register
	__IO uint8_t S6FCR;          // @180 stream x FIFO control register
	uint8_t      RESERVED13[3];  // @181
	__IO uint32_t S7CR;          // @184 stream x configuration register
	__IO uint16_t S7NDTR;        // @188 stream x number of data register
	uint8_t       RESERVED14[2]; // @190
	__IO uint32_t S7PAR;         // @192 stream x peripheral address register
	__IO uint32_t S7M0AR;        // @196 stream x memory 0 address register
	__IO uint32_t S7M1AR;        // @200 stream x memory 1 address register
	__IO uint8_t S7FCR;          // @204 stream x FIFO control register
};

// DMA2->LISR low interrupt status register
enum {
	DMA2_LISR_TCIF3  = 1UL << 27, // Stream x transfer complete interrupt flag (x = 3..0)
	DMA2_LISR_HTIF3  = 1UL << 26, // Stream x half transfer interrupt flag (x=3..0)
	DMA2_LISR_TEIF3  = 1UL << 25, // Stream x transfer error interrupt flag (x=3..0)
	DMA2_LISR_DMEIF3 = 1UL << 24, // Stream x direct mode error interrupt flag (x=3..0)
	DMA2_LISR_FEIF3  = 1UL << 22, // Stream x FIFO error interrupt flag (x=3..0)
	DMA2_LISR_TCIF2  = 1UL << 21, // Stream x transfer complete interrupt flag (x = 3..0)
	DMA2_LISR_HTIF2  = 1UL << 20, // Stream x half transfer interrupt flag (x=3..0)
	DMA2_LISR_TEIF2  = 1UL << 19, // Stream x transfer error interrupt flag (x=3..0)
	DMA2_LISR_DMEIF2 = 1UL << 18, // Stream x direct mode error interrupt flag (x=3..0)
	DMA2_LISR_FEIF2  = 1UL << 16, // Stream x FIFO error interrupt flag (x=3..0)
	DMA2_LISR_TCIF1  = 1UL << 11, // Stream x transfer complete interrupt flag (x = 3..0)
	DMA2_LISR_HTIF1  = 1UL << 10, // Stream x half transfer interrupt flag (x=3..0)
	DMA2_LISR_TEIF1  = 1UL << 9,  // Stream x transfer error interrupt flag (x=3..0)
	DMA2_LISR_DMEIF1 = 1UL << 8,  // Stream x direct mode error interrupt flag (x=3..0)
	DMA2_LISR_FEIF1  = 1UL << 6,  // Stream x FIFO error interrupt flag (x=3..0)
	DMA2_LISR_TCIF0  = 1UL << 5,  // Stream x transfer complete interrupt flag (x = 3..0)
	DMA2_LISR_HTIF0  = 1UL << 4,  // Stream x half transfer interrupt flag (x=3..0)
	DMA2_LISR_TEIF0  = 1UL << 3,  // Stream x transfer error interrupt flag (x=3..0)
	DMA2_LISR_DMEIF0 = 1UL << 2,  // Stream x direct mode error interrupt flag (x=3..0)
	DMA2_LISR_FEIF0  = 1UL << 0,  // Stream x FIFO error interrupt flag (x=3..0)
};

// DMA2->HISR high interrupt status register
enum {
	DMA2_HISR_TCIF7  = 1UL << 27, // Stream x transfer complete interrupt flag (x=7..4)
	DMA2_HISR_HTIF7  = 1UL << 26, // Stream x half transfer interrupt flag (x=7..4)
	DMA2_HISR_TEIF7  = 1UL << 25, // Stream x transfer error interrupt flag (x=7..4)
	DMA2_HISR_DMEIF7 = 1UL << 24, // Stream x direct mode error interrupt flag (x=7..4)
	DMA2_HISR_FEIF7  = 1UL << 22, // Stream x FIFO error interrupt flag (x=7..4)
	DMA2_HISR_TCIF6  = 1UL << 21, // Stream x transfer complete interrupt flag (x=7..4)
	DMA2_HISR_HTIF6  = 1UL << 20, // Stream x half transfer interrupt flag (x=7..4)
	DMA2_HISR_TEIF6  = 1UL << 19, // Stream x transfer error interrupt flag (x=7..4)
	DMA2_HISR_DMEIF6 = 1UL << 18, // Stream x direct mode error interrupt flag (x=7..4)
	DMA2_HISR_FEIF6  = 1UL << 16, // Stream x FIFO error interrupt flag (x=7..4)
	DMA2_HISR_TCIF5  = 1UL << 11, // Stream x transfer complete interrupt flag (x=7..4)
	DMA2_HISR_HTIF5  = 1UL << 10, // Stream x half transfer interrupt flag (x=7..4)
	DMA2_HISR_TEIF5  = 1UL << 9,  // Stream x transfer error interrupt flag (x=7..4)
	DMA2_HISR_DMEIF5 = 1UL << 8,  // Stream x direct mode error interrupt flag (x=7..4)
	DMA2_HISR_FEIF5  = 1UL << 6,  // Stream x FIFO error interrupt flag (x=7..4)
	DMA2_HISR_TCIF4  = 1UL << 5,  // Stream x transfer complete interrupt flag (x=7..4)
	DMA2_HISR_HTIF4  = 1UL << 4,  // Stream x half transfer interrupt flag (x=7..4)
	DMA2_HISR_TEIF4  = 1UL << 3,  // Stream x transfer error interrupt flag (x=7..4)
	DMA2_HISR_DMEIF4 = 1UL << 2,  // Stream x direct mode error interrupt flag (x=7..4)
	DMA2_HISR_FEIF4  = 1UL << 0,  // Stream x FIFO error interrupt flag (x=7..4)
};

// DMA2->LIFCR low interrupt flag clear register
enum {
	DMA2_LIFCR_CTCIF3  = 1UL << 27, // Stream x clear transfer complete interrupt flag (x = 3..0)
	DMA2_LIFCR_CHTIF3  = 1UL << 26, // Stream x clear half transfer interrupt flag (x = 3..0)
	DMA2_LIFCR_CTEIF3  = 1UL << 25, // Stream x clear transfer error interrupt flag (x = 3..0)
	DMA2_LIFCR_CDMEIF3 = 1UL << 24, // Stream x clear direct mode error interrupt flag (x = 3..0)
	DMA2_LIFCR_CFEIF3  = 1UL << 22, // Stream x clear FIFO error interrupt flag (x = 3..0)
	DMA2_LIFCR_CTCIF2  = 1UL << 21, // Stream x clear transfer complete interrupt flag (x = 3..0)
	DMA2_LIFCR_CHTIF2  = 1UL << 20, // Stream x clear half transfer interrupt flag (x = 3..0)
	DMA2_LIFCR_CTEIF2  = 1UL << 19, // Stream x clear transfer error interrupt flag (x = 3..0)
	DMA2_LIFCR_CDMEIF2 = 1UL << 18, // Stream x clear direct mode error interrupt flag (x = 3..0)
	DMA2_LIFCR_CFEIF2  = 1UL << 16, // Stream x clear FIFO error interrupt flag (x = 3..0)
	DMA2_LIFCR_CTCIF1  = 1UL << 11, // Stream x clear transfer complete interrupt flag (x = 3..0)
	DMA2_LIFCR_CHTIF1  = 1UL << 10, // Stream x clear half transfer interrupt flag (x = 3..0)
	DMA2_LIFCR_CTEIF1  = 1UL << 9,  // Stream x clear transfer error interrupt flag (x = 3..0)
	DMA2_LIFCR_CDMEIF1 = 1UL << 8,  // Stream x clear direct mode error interrupt flag (x = 3..0)
	DMA2_LIFCR_CFEIF1  = 1UL << 6,  // Stream x clear FIFO error interrupt flag (x = 3..0)
	DMA2_LIFCR_CTCIF0  = 1UL << 5,  // Stream x clear transfer complete interrupt flag (x = 3..0)
	DMA2_LIFCR_CHTIF0  = 1UL << 4,  // Stream x clear half transfer interrupt flag (x = 3..0)
	DMA2_LIFCR_CTEIF0  = 1UL << 3,  // Stream x clear transfer error interrupt flag (x = 3..0)
	DMA2_LIFCR_CDMEIF0 = 1UL << 2,  // Stream x clear direct mode error interrupt flag (x = 3..0)
	DMA2_LIFCR_CFEIF0  = 1UL << 0,  // Stream x clear FIFO error interrupt flag (x = 3..0)
};

// DMA2->HIFCR high interrupt flag clear register
enum {
	DMA2_HIFCR_CTCIF7  = 1UL << 27, // Stream x clear transfer complete interrupt flag (x = 7..4)
	DMA2_HIFCR_CHTIF7  = 1UL << 26, // Stream x clear half transfer interrupt flag (x = 7..4)
	DMA2_HIFCR_CTEIF7  = 1UL << 25, // Stream x clear transfer error interrupt flag (x = 7..4)
	DMA2_HIFCR_CDMEIF7 = 1UL << 24, // Stream x clear direct mode error interrupt flag (x = 7..4)
	DMA2_HIFCR_CFEIF7  = 1UL << 22, // Stream x clear FIFO error interrupt flag (x = 7..4)
	DMA2_HIFCR_CTCIF6  = 1UL << 21, // Stream x clear transfer complete interrupt flag (x = 7..4)
	DMA2_HIFCR_CHTIF6  = 1UL << 20, // Stream x clear half transfer interrupt flag (x = 7..4)
	DMA2_HIFCR_CTEIF6  = 1UL << 19, // Stream x clear transfer error interrupt flag (x = 7..4)
	DMA2_HIFCR_CDMEIF6 = 1UL << 18, // Stream x clear direct mode error interrupt flag (x = 7..4)
	DMA2_HIFCR_CFEIF6  = 1UL << 16, // Stream x clear FIFO error interrupt flag (x = 7..4)
	DMA2_HIFCR_CTCIF5  = 1UL << 11, // Stream x clear transfer complete interrupt flag (x = 7..4)
	DMA2_HIFCR_CHTIF5  = 1UL << 10, // Stream x clear half transfer interrupt flag (x = 7..4)
	DMA2_HIFCR_CTEIF5  = 1UL << 9,  // Stream x clear transfer error interrupt flag (x = 7..4)
	DMA2_HIFCR_CDMEIF5 = 1UL << 8,  // Stream x clear direct mode error interrupt flag (x = 7..4)
	DMA2_HIFCR_CFEIF5  = 1UL << 6,  // Stream x clear FIFO error interrupt flag (x = 7..4)
	DMA2_HIFCR_CTCIF4  = 1UL << 5,  // Stream x clear transfer complete interrupt flag (x = 7..4)
	DMA2_HIFCR_CHTIF4  = 1UL << 4,  // Stream x clear half transfer interrupt flag (x = 7..4)
	DMA2_HIFCR_CTEIF4  = 1UL << 3,  // Stream x clear transfer error interrupt flag (x = 7..4)
	DMA2_HIFCR_CDMEIF4 = 1UL << 2,  // Stream x clear direct mode error interrupt flag (x = 7..4)
	DMA2_HIFCR_CFEIF4  = 1UL << 0,  // Stream x clear FIFO error interrupt flag (x = 7..4)
};

// DMA2->S0CR stream x configuration register
enum {
	DMA2_S0CR_CHSEL  = ((1UL << 3) - 1) << 25, // Channel selection
	DMA2_S0CR_MBURST = ((1UL << 2) - 1) << 23, // Memory burst transfer configuration
	DMA2_S0CR_PBURST = ((1UL << 2) - 1) << 21, // Peripheral burst transfer configuration
	DMA2_S0CR_CT     = 1UL << 19,              // Current target (only in double buffer mode)
	DMA2_S0CR_DBM    = 1UL << 18,              // Double buffer mode
	DMA2_S0CR_PL     = ((1UL << 2) - 1) << 16, // Priority level
	DMA2_S0CR_PINCOS = 1UL << 15,              // Peripheral increment offset size
	DMA2_S0CR_MSIZE  = ((1UL << 2) - 1) << 13, // Memory data size
	DMA2_S0CR_PSIZE  = ((1UL << 2) - 1) << 11, // Peripheral data size
	DMA2_S0CR_MINC   = 1UL << 10,              // Memory increment mode
	DMA2_S0CR_PINC   = 1UL << 9,               // Peripheral increment mode
	DMA2_S0CR_CIRC   = 1UL << 8,               // Circular mode
	DMA2_S0CR_DIR    = ((1UL << 2) - 1) << 6,  // Data transfer direction
	DMA2_S0CR_PFCTRL = 1UL << 5,               // Peripheral flow controller
	DMA2_S0CR_TCIE   = 1UL << 4,               // Transfer complete interrupt enable
	DMA2_S0CR_HTIE   = 1UL << 3,               // Half transfer interrupt enable
	DMA2_S0CR_TEIE   = 1UL << 2,               // Transfer error interrupt enable
	DMA2_S0CR_DMEIE  = 1UL << 1,               // Direct mode error interrupt enable
	DMA2_S0CR_EN     = 1UL << 0,               // Stream enable / flag stream ready when read low
};
inline void dma2_s0cr_set_chsel(struct DMA2_Type* p, uint32_t val) {
	p->S0CR = (p->S0CR & ~DMA2_S0CR_CHSEL) | ((val << 25) & DMA2_S0CR_CHSEL);
}
inline void dma2_s0cr_set_mburst(struct DMA2_Type* p, uint32_t val) {
	p->S0CR = (p->S0CR & ~DMA2_S0CR_MBURST) | ((val << 23) & DMA2_S0CR_MBURST);
}
inline void dma2_s0cr_set_pburst(struct DMA2_Type* p, uint32_t val) {
	p->S0CR = (p->S0CR & ~DMA2_S0CR_PBURST) | ((val << 21) & DMA2_S0CR_PBURST);
}
inline void dma2_s0cr_set_pl(struct DMA2_Type* p, uint32_t val) { p->S0CR = (p->S0CR & ~DMA2_S0CR_PL) | ((val << 16) & DMA2_S0CR_PL); }
inline void dma2_s0cr_set_msize(struct DMA2_Type* p, uint32_t val) {
	p->S0CR = (p->S0CR & ~DMA2_S0CR_MSIZE) | ((val << 13) & DMA2_S0CR_MSIZE);
}
inline void dma2_s0cr_set_psize(struct DMA2_Type* p, uint32_t val) {
	p->S0CR = (p->S0CR & ~DMA2_S0CR_PSIZE) | ((val << 11) & DMA2_S0CR_PSIZE);
}
inline void dma2_s0cr_set_dir(struct DMA2_Type* p, uint32_t val) { p->S0CR = (p->S0CR & ~DMA2_S0CR_DIR) | ((val << 6) & DMA2_S0CR_DIR); }
inline uint32_t dma2_s0cr_get_chsel(struct DMA2_Type* p) { return (p->S0CR & DMA2_S0CR_CHSEL) >> 25; }
inline uint32_t dma2_s0cr_get_mburst(struct DMA2_Type* p) { return (p->S0CR & DMA2_S0CR_MBURST) >> 23; }
inline uint32_t dma2_s0cr_get_pburst(struct DMA2_Type* p) { return (p->S0CR & DMA2_S0CR_PBURST) >> 21; }
inline uint32_t dma2_s0cr_get_pl(struct DMA2_Type* p) { return (p->S0CR & DMA2_S0CR_PL) >> 16; }
inline uint32_t dma2_s0cr_get_msize(struct DMA2_Type* p) { return (p->S0CR & DMA2_S0CR_MSIZE) >> 13; }
inline uint32_t dma2_s0cr_get_psize(struct DMA2_Type* p) { return (p->S0CR & DMA2_S0CR_PSIZE) >> 11; }
inline uint32_t dma2_s0cr_get_dir(struct DMA2_Type* p) { return (p->S0CR & DMA2_S0CR_DIR) >> 6; }

// DMA2->S0FCR stream x FIFO control register
enum {
	DMA2_S0FCR_FEIE  = 1UL << 7,              // FIFO error interrupt enable
	DMA2_S0FCR_FS    = ((1UL << 3) - 1) << 3, // FIFO status
	DMA2_S0FCR_DMDIS = 1UL << 2,              // Direct mode disable
	DMA2_S0FCR_FTH   = ((1UL << 2) - 1) << 0, // FIFO threshold selection
};
inline void dma2_s0fcr_set_fs(struct DMA2_Type* p, uint32_t val) { p->S0FCR = (p->S0FCR & ~DMA2_S0FCR_FS) | ((val << 3) & DMA2_S0FCR_FS); }
inline void dma2_s0fcr_set_fth(struct DMA2_Type* p, uint32_t val) {
	p->S0FCR = (p->S0FCR & ~DMA2_S0FCR_FTH) | ((val << 0) & DMA2_S0FCR_FTH);
}
inline uint32_t dma2_s0fcr_get_fs(struct DMA2_Type* p) { return (p->S0FCR & DMA2_S0FCR_FS) >> 3; }
inline uint32_t dma2_s0fcr_get_fth(struct DMA2_Type* p) { return (p->S0FCR & DMA2_S0FCR_FTH) >> 0; }

// DMA2->S1CR stream x configuration register
enum {
	DMA2_S1CR_CHSEL  = ((1UL << 3) - 1) << 25, // Channel selection
	DMA2_S1CR_MBURST = ((1UL << 2) - 1) << 23, // Memory burst transfer configuration
	DMA2_S1CR_PBURST = ((1UL << 2) - 1) << 21, // Peripheral burst transfer configuration
	DMA2_S1CR_ACK    = 1UL << 20,              // ACK
	DMA2_S1CR_CT     = 1UL << 19,              // Current target (only in double buffer mode)
	DMA2_S1CR_DBM    = 1UL << 18,              // Double buffer mode
	DMA2_S1CR_PL     = ((1UL << 2) - 1) << 16, // Priority level
	DMA2_S1CR_PINCOS = 1UL << 15,              // Peripheral increment offset size
	DMA2_S1CR_MSIZE  = ((1UL << 2) - 1) << 13, // Memory data size
	DMA2_S1CR_PSIZE  = ((1UL << 2) - 1) << 11, // Peripheral data size
	DMA2_S1CR_MINC   = 1UL << 10,              // Memory increment mode
	DMA2_S1CR_PINC   = 1UL << 9,               // Peripheral increment mode
	DMA2_S1CR_CIRC   = 1UL << 8,               // Circular mode
	DMA2_S1CR_DIR    = ((1UL << 2) - 1) << 6,  // Data transfer direction
	DMA2_S1CR_PFCTRL = 1UL << 5,               // Peripheral flow controller
	DMA2_S1CR_TCIE   = 1UL << 4,               // Transfer complete interrupt enable
	DMA2_S1CR_HTIE   = 1UL << 3,               // Half transfer interrupt enable
	DMA2_S1CR_TEIE   = 1UL << 2,               // Transfer error interrupt enable
	DMA2_S1CR_DMEIE  = 1UL << 1,               // Direct mode error interrupt enable
	DMA2_S1CR_EN     = 1UL << 0,               // Stream enable / flag stream ready when read low
};
inline void dma2_s1cr_set_chsel(struct DMA2_Type* p, uint32_t val) {
	p->S1CR = (p->S1CR & ~DMA2_S1CR_CHSEL) | ((val << 25) & DMA2_S1CR_CHSEL);
}
inline void dma2_s1cr_set_mburst(struct DMA2_Type* p, uint32_t val) {
	p->S1CR = (p->S1CR & ~DMA2_S1CR_MBURST) | ((val << 23) & DMA2_S1CR_MBURST);
}
inline void dma2_s1cr_set_pburst(struct DMA2_Type* p, uint32_t val) {
	p->S1CR = (p->S1CR & ~DMA2_S1CR_PBURST) | ((val << 21) & DMA2_S1CR_PBURST);
}
inline void dma2_s1cr_set_pl(struct DMA2_Type* p, uint32_t val) { p->S1CR = (p->S1CR & ~DMA2_S1CR_PL) | ((val << 16) & DMA2_S1CR_PL); }
inline void dma2_s1cr_set_msize(struct DMA2_Type* p, uint32_t val) {
	p->S1CR = (p->S1CR & ~DMA2_S1CR_MSIZE) | ((val << 13) & DMA2_S1CR_MSIZE);
}
inline void dma2_s1cr_set_psize(struct DMA2_Type* p, uint32_t val) {
	p->S1CR = (p->S1CR & ~DMA2_S1CR_PSIZE) | ((val << 11) & DMA2_S1CR_PSIZE);
}
inline void dma2_s1cr_set_dir(struct DMA2_Type* p, uint32_t val) { p->S1CR = (p->S1CR & ~DMA2_S1CR_DIR) | ((val << 6) & DMA2_S1CR_DIR); }
inline uint32_t dma2_s1cr_get_chsel(struct DMA2_Type* p) { return (p->S1CR & DMA2_S1CR_CHSEL) >> 25; }
inline uint32_t dma2_s1cr_get_mburst(struct DMA2_Type* p) { return (p->S1CR & DMA2_S1CR_MBURST) >> 23; }
inline uint32_t dma2_s1cr_get_pburst(struct DMA2_Type* p) { return (p->S1CR & DMA2_S1CR_PBURST) >> 21; }
inline uint32_t dma2_s1cr_get_pl(struct DMA2_Type* p) { return (p->S1CR & DMA2_S1CR_PL) >> 16; }
inline uint32_t dma2_s1cr_get_msize(struct DMA2_Type* p) { return (p->S1CR & DMA2_S1CR_MSIZE) >> 13; }
inline uint32_t dma2_s1cr_get_psize(struct DMA2_Type* p) { return (p->S1CR & DMA2_S1CR_PSIZE) >> 11; }
inline uint32_t dma2_s1cr_get_dir(struct DMA2_Type* p) { return (p->S1CR & DMA2_S1CR_DIR) >> 6; }

// DMA2->S1FCR stream x FIFO control register
enum {
	DMA2_S1FCR_FEIE  = 1UL << 7,              // FIFO error interrupt enable
	DMA2_S1FCR_FS    = ((1UL << 3) - 1) << 3, // FIFO status
	DMA2_S1FCR_DMDIS = 1UL << 2,              // Direct mode disable
	DMA2_S1FCR_FTH   = ((1UL << 2) - 1) << 0, // FIFO threshold selection
};
inline void dma2_s1fcr_set_fs(struct DMA2_Type* p, uint32_t val) { p->S1FCR = (p->S1FCR & ~DMA2_S1FCR_FS) | ((val << 3) & DMA2_S1FCR_FS); }
inline void dma2_s1fcr_set_fth(struct DMA2_Type* p, uint32_t val) {
	p->S1FCR = (p->S1FCR & ~DMA2_S1FCR_FTH) | ((val << 0) & DMA2_S1FCR_FTH);
}
inline uint32_t dma2_s1fcr_get_fs(struct DMA2_Type* p) { return (p->S1FCR & DMA2_S1FCR_FS) >> 3; }
inline uint32_t dma2_s1fcr_get_fth(struct DMA2_Type* p) { return (p->S1FCR & DMA2_S1FCR_FTH) >> 0; }

// DMA2->S2CR stream x configuration register
enum {
	DMA2_S2CR_CHSEL  = ((1UL << 3) - 1) << 25, // Channel selection
	DMA2_S2CR_MBURST = ((1UL << 2) - 1) << 23, // Memory burst transfer configuration
	DMA2_S2CR_PBURST = ((1UL << 2) - 1) << 21, // Peripheral burst transfer configuration
	DMA2_S2CR_ACK    = 1UL << 20,              // ACK
	DMA2_S2CR_CT     = 1UL << 19,              // Current target (only in double buffer mode)
	DMA2_S2CR_DBM    = 1UL << 18,              // Double buffer mode
	DMA2_S2CR_PL     = ((1UL << 2) - 1) << 16, // Priority level
	DMA2_S2CR_PINCOS = 1UL << 15,              // Peripheral increment offset size
	DMA2_S2CR_MSIZE  = ((1UL << 2) - 1) << 13, // Memory data size
	DMA2_S2CR_PSIZE  = ((1UL << 2) - 1) << 11, // Peripheral data size
	DMA2_S2CR_MINC   = 1UL << 10,              // Memory increment mode
	DMA2_S2CR_PINC   = 1UL << 9,               // Peripheral increment mode
	DMA2_S2CR_CIRC   = 1UL << 8,               // Circular mode
	DMA2_S2CR_DIR    = ((1UL << 2) - 1) << 6,  // Data transfer direction
	DMA2_S2CR_PFCTRL = 1UL << 5,               // Peripheral flow controller
	DMA2_S2CR_TCIE   = 1UL << 4,               // Transfer complete interrupt enable
	DMA2_S2CR_HTIE   = 1UL << 3,               // Half transfer interrupt enable
	DMA2_S2CR_TEIE   = 1UL << 2,               // Transfer error interrupt enable
	DMA2_S2CR_DMEIE  = 1UL << 1,               // Direct mode error interrupt enable
	DMA2_S2CR_EN     = 1UL << 0,               // Stream enable / flag stream ready when read low
};
inline void dma2_s2cr_set_chsel(struct DMA2_Type* p, uint32_t val) {
	p->S2CR = (p->S2CR & ~DMA2_S2CR_CHSEL) | ((val << 25) & DMA2_S2CR_CHSEL);
}
inline void dma2_s2cr_set_mburst(struct DMA2_Type* p, uint32_t val) {
	p->S2CR = (p->S2CR & ~DMA2_S2CR_MBURST) | ((val << 23) & DMA2_S2CR_MBURST);
}
inline void dma2_s2cr_set_pburst(struct DMA2_Type* p, uint32_t val) {
	p->S2CR = (p->S2CR & ~DMA2_S2CR_PBURST) | ((val << 21) & DMA2_S2CR_PBURST);
}
inline void dma2_s2cr_set_pl(struct DMA2_Type* p, uint32_t val) { p->S2CR = (p->S2CR & ~DMA2_S2CR_PL) | ((val << 16) & DMA2_S2CR_PL); }
inline void dma2_s2cr_set_msize(struct DMA2_Type* p, uint32_t val) {
	p->S2CR = (p->S2CR & ~DMA2_S2CR_MSIZE) | ((val << 13) & DMA2_S2CR_MSIZE);
}
inline void dma2_s2cr_set_psize(struct DMA2_Type* p, uint32_t val) {
	p->S2CR = (p->S2CR & ~DMA2_S2CR_PSIZE) | ((val << 11) & DMA2_S2CR_PSIZE);
}
inline void dma2_s2cr_set_dir(struct DMA2_Type* p, uint32_t val) { p->S2CR = (p->S2CR & ~DMA2_S2CR_DIR) | ((val << 6) & DMA2_S2CR_DIR); }
inline uint32_t dma2_s2cr_get_chsel(struct DMA2_Type* p) { return (p->S2CR & DMA2_S2CR_CHSEL) >> 25; }
inline uint32_t dma2_s2cr_get_mburst(struct DMA2_Type* p) { return (p->S2CR & DMA2_S2CR_MBURST) >> 23; }
inline uint32_t dma2_s2cr_get_pburst(struct DMA2_Type* p) { return (p->S2CR & DMA2_S2CR_PBURST) >> 21; }
inline uint32_t dma2_s2cr_get_pl(struct DMA2_Type* p) { return (p->S2CR & DMA2_S2CR_PL) >> 16; }
inline uint32_t dma2_s2cr_get_msize(struct DMA2_Type* p) { return (p->S2CR & DMA2_S2CR_MSIZE) >> 13; }
inline uint32_t dma2_s2cr_get_psize(struct DMA2_Type* p) { return (p->S2CR & DMA2_S2CR_PSIZE) >> 11; }
inline uint32_t dma2_s2cr_get_dir(struct DMA2_Type* p) { return (p->S2CR & DMA2_S2CR_DIR) >> 6; }

// DMA2->S2FCR stream x FIFO control register
enum {
	DMA2_S2FCR_FEIE  = 1UL << 7,              // FIFO error interrupt enable
	DMA2_S2FCR_FS    = ((1UL << 3) - 1) << 3, // FIFO status
	DMA2_S2FCR_DMDIS = 1UL << 2,              // Direct mode disable
	DMA2_S2FCR_FTH   = ((1UL << 2) - 1) << 0, // FIFO threshold selection
};
inline void dma2_s2fcr_set_fs(struct DMA2_Type* p, uint32_t val) { p->S2FCR = (p->S2FCR & ~DMA2_S2FCR_FS) | ((val << 3) & DMA2_S2FCR_FS); }
inline void dma2_s2fcr_set_fth(struct DMA2_Type* p, uint32_t val) {
	p->S2FCR = (p->S2FCR & ~DMA2_S2FCR_FTH) | ((val << 0) & DMA2_S2FCR_FTH);
}
inline uint32_t dma2_s2fcr_get_fs(struct DMA2_Type* p) { return (p->S2FCR & DMA2_S2FCR_FS) >> 3; }
inline uint32_t dma2_s2fcr_get_fth(struct DMA2_Type* p) { return (p->S2FCR & DMA2_S2FCR_FTH) >> 0; }

// DMA2->S3CR stream x configuration register
enum {
	DMA2_S3CR_CHSEL  = ((1UL << 3) - 1) << 25, // Channel selection
	DMA2_S3CR_MBURST = ((1UL << 2) - 1) << 23, // Memory burst transfer configuration
	DMA2_S3CR_PBURST = ((1UL << 2) - 1) << 21, // Peripheral burst transfer configuration
	DMA2_S3CR_ACK    = 1UL << 20,              // ACK
	DMA2_S3CR_CT     = 1UL << 19,              // Current target (only in double buffer mode)
	DMA2_S3CR_DBM    = 1UL << 18,              // Double buffer mode
	DMA2_S3CR_PL     = ((1UL << 2) - 1) << 16, // Priority level
	DMA2_S3CR_PINCOS = 1UL << 15,              // Peripheral increment offset size
	DMA2_S3CR_MSIZE  = ((1UL << 2) - 1) << 13, // Memory data size
	DMA2_S3CR_PSIZE  = ((1UL << 2) - 1) << 11, // Peripheral data size
	DMA2_S3CR_MINC   = 1UL << 10,              // Memory increment mode
	DMA2_S3CR_PINC   = 1UL << 9,               // Peripheral increment mode
	DMA2_S3CR_CIRC   = 1UL << 8,               // Circular mode
	DMA2_S3CR_DIR    = ((1UL << 2) - 1) << 6,  // Data transfer direction
	DMA2_S3CR_PFCTRL = 1UL << 5,               // Peripheral flow controller
	DMA2_S3CR_TCIE   = 1UL << 4,               // Transfer complete interrupt enable
	DMA2_S3CR_HTIE   = 1UL << 3,               // Half transfer interrupt enable
	DMA2_S3CR_TEIE   = 1UL << 2,               // Transfer error interrupt enable
	DMA2_S3CR_DMEIE  = 1UL << 1,               // Direct mode error interrupt enable
	DMA2_S3CR_EN     = 1UL << 0,               // Stream enable / flag stream ready when read low
};
inline void dma2_s3cr_set_chsel(struct DMA2_Type* p, uint32_t val) {
	p->S3CR = (p->S3CR & ~DMA2_S3CR_CHSEL) | ((val << 25) & DMA2_S3CR_CHSEL);
}
inline void dma2_s3cr_set_mburst(struct DMA2_Type* p, uint32_t val) {
	p->S3CR = (p->S3CR & ~DMA2_S3CR_MBURST) | ((val << 23) & DMA2_S3CR_MBURST);
}
inline void dma2_s3cr_set_pburst(struct DMA2_Type* p, uint32_t val) {
	p->S3CR = (p->S3CR & ~DMA2_S3CR_PBURST) | ((val << 21) & DMA2_S3CR_PBURST);
}
inline void dma2_s3cr_set_pl(struct DMA2_Type* p, uint32_t val) { p->S3CR = (p->S3CR & ~DMA2_S3CR_PL) | ((val << 16) & DMA2_S3CR_PL); }
inline void dma2_s3cr_set_msize(struct DMA2_Type* p, uint32_t val) {
	p->S3CR = (p->S3CR & ~DMA2_S3CR_MSIZE) | ((val << 13) & DMA2_S3CR_MSIZE);
}
inline void dma2_s3cr_set_psize(struct DMA2_Type* p, uint32_t val) {
	p->S3CR = (p->S3CR & ~DMA2_S3CR_PSIZE) | ((val << 11) & DMA2_S3CR_PSIZE);
}
inline void dma2_s3cr_set_dir(struct DMA2_Type* p, uint32_t val) { p->S3CR = (p->S3CR & ~DMA2_S3CR_DIR) | ((val << 6) & DMA2_S3CR_DIR); }
inline uint32_t dma2_s3cr_get_chsel(struct DMA2_Type* p) { return (p->S3CR & DMA2_S3CR_CHSEL) >> 25; }
inline uint32_t dma2_s3cr_get_mburst(struct DMA2_Type* p) { return (p->S3CR & DMA2_S3CR_MBURST) >> 23; }
inline uint32_t dma2_s3cr_get_pburst(struct DMA2_Type* p) { return (p->S3CR & DMA2_S3CR_PBURST) >> 21; }
inline uint32_t dma2_s3cr_get_pl(struct DMA2_Type* p) { return (p->S3CR & DMA2_S3CR_PL) >> 16; }
inline uint32_t dma2_s3cr_get_msize(struct DMA2_Type* p) { return (p->S3CR & DMA2_S3CR_MSIZE) >> 13; }
inline uint32_t dma2_s3cr_get_psize(struct DMA2_Type* p) { return (p->S3CR & DMA2_S3CR_PSIZE) >> 11; }
inline uint32_t dma2_s3cr_get_dir(struct DMA2_Type* p) { return (p->S3CR & DMA2_S3CR_DIR) >> 6; }

// DMA2->S3FCR stream x FIFO control register
enum {
	DMA2_S3FCR_FEIE  = 1UL << 7,              // FIFO error interrupt enable
	DMA2_S3FCR_FS    = ((1UL << 3) - 1) << 3, // FIFO status
	DMA2_S3FCR_DMDIS = 1UL << 2,              // Direct mode disable
	DMA2_S3FCR_FTH   = ((1UL << 2) - 1) << 0, // FIFO threshold selection
};
inline void dma2_s3fcr_set_fs(struct DMA2_Type* p, uint32_t val) { p->S3FCR = (p->S3FCR & ~DMA2_S3FCR_FS) | ((val << 3) & DMA2_S3FCR_FS); }
inline void dma2_s3fcr_set_fth(struct DMA2_Type* p, uint32_t val) {
	p->S3FCR = (p->S3FCR & ~DMA2_S3FCR_FTH) | ((val << 0) & DMA2_S3FCR_FTH);
}
inline uint32_t dma2_s3fcr_get_fs(struct DMA2_Type* p) { return (p->S3FCR & DMA2_S3FCR_FS) >> 3; }
inline uint32_t dma2_s3fcr_get_fth(struct DMA2_Type* p) { return (p->S3FCR & DMA2_S3FCR_FTH) >> 0; }

// DMA2->S4CR stream x configuration register
enum {
	DMA2_S4CR_CHSEL  = ((1UL << 3) - 1) << 25, // Channel selection
	DMA2_S4CR_MBURST = ((1UL << 2) - 1) << 23, // Memory burst transfer configuration
	DMA2_S4CR_PBURST = ((1UL << 2) - 1) << 21, // Peripheral burst transfer configuration
	DMA2_S4CR_ACK    = 1UL << 20,              // ACK
	DMA2_S4CR_CT     = 1UL << 19,              // Current target (only in double buffer mode)
	DMA2_S4CR_DBM    = 1UL << 18,              // Double buffer mode
	DMA2_S4CR_PL     = ((1UL << 2) - 1) << 16, // Priority level
	DMA2_S4CR_PINCOS = 1UL << 15,              // Peripheral increment offset size
	DMA2_S4CR_MSIZE  = ((1UL << 2) - 1) << 13, // Memory data size
	DMA2_S4CR_PSIZE  = ((1UL << 2) - 1) << 11, // Peripheral data size
	DMA2_S4CR_MINC   = 1UL << 10,              // Memory increment mode
	DMA2_S4CR_PINC   = 1UL << 9,               // Peripheral increment mode
	DMA2_S4CR_CIRC   = 1UL << 8,               // Circular mode
	DMA2_S4CR_DIR    = ((1UL << 2) - 1) << 6,  // Data transfer direction
	DMA2_S4CR_PFCTRL = 1UL << 5,               // Peripheral flow controller
	DMA2_S4CR_TCIE   = 1UL << 4,               // Transfer complete interrupt enable
	DMA2_S4CR_HTIE   = 1UL << 3,               // Half transfer interrupt enable
	DMA2_S4CR_TEIE   = 1UL << 2,               // Transfer error interrupt enable
	DMA2_S4CR_DMEIE  = 1UL << 1,               // Direct mode error interrupt enable
	DMA2_S4CR_EN     = 1UL << 0,               // Stream enable / flag stream ready when read low
};
inline void dma2_s4cr_set_chsel(struct DMA2_Type* p, uint32_t val) {
	p->S4CR = (p->S4CR & ~DMA2_S4CR_CHSEL) | ((val << 25) & DMA2_S4CR_CHSEL);
}
inline void dma2_s4cr_set_mburst(struct DMA2_Type* p, uint32_t val) {
	p->S4CR = (p->S4CR & ~DMA2_S4CR_MBURST) | ((val << 23) & DMA2_S4CR_MBURST);
}
inline void dma2_s4cr_set_pburst(struct DMA2_Type* p, uint32_t val) {
	p->S4CR = (p->S4CR & ~DMA2_S4CR_PBURST) | ((val << 21) & DMA2_S4CR_PBURST);
}
inline void dma2_s4cr_set_pl(struct DMA2_Type* p, uint32_t val) { p->S4CR = (p->S4CR & ~DMA2_S4CR_PL) | ((val << 16) & DMA2_S4CR_PL); }
inline void dma2_s4cr_set_msize(struct DMA2_Type* p, uint32_t val) {
	p->S4CR = (p->S4CR & ~DMA2_S4CR_MSIZE) | ((val << 13) & DMA2_S4CR_MSIZE);
}
inline void dma2_s4cr_set_psize(struct DMA2_Type* p, uint32_t val) {
	p->S4CR = (p->S4CR & ~DMA2_S4CR_PSIZE) | ((val << 11) & DMA2_S4CR_PSIZE);
}
inline void dma2_s4cr_set_dir(struct DMA2_Type* p, uint32_t val) { p->S4CR = (p->S4CR & ~DMA2_S4CR_DIR) | ((val << 6) & DMA2_S4CR_DIR); }
inline uint32_t dma2_s4cr_get_chsel(struct DMA2_Type* p) { return (p->S4CR & DMA2_S4CR_CHSEL) >> 25; }
inline uint32_t dma2_s4cr_get_mburst(struct DMA2_Type* p) { return (p->S4CR & DMA2_S4CR_MBURST) >> 23; }
inline uint32_t dma2_s4cr_get_pburst(struct DMA2_Type* p) { return (p->S4CR & DMA2_S4CR_PBURST) >> 21; }
inline uint32_t dma2_s4cr_get_pl(struct DMA2_Type* p) { return (p->S4CR & DMA2_S4CR_PL) >> 16; }
inline uint32_t dma2_s4cr_get_msize(struct DMA2_Type* p) { return (p->S4CR & DMA2_S4CR_MSIZE) >> 13; }
inline uint32_t dma2_s4cr_get_psize(struct DMA2_Type* p) { return (p->S4CR & DMA2_S4CR_PSIZE) >> 11; }
inline uint32_t dma2_s4cr_get_dir(struct DMA2_Type* p) { return (p->S4CR & DMA2_S4CR_DIR) >> 6; }

// DMA2->S4FCR stream x FIFO control register
enum {
	DMA2_S4FCR_FEIE  = 1UL << 7,              // FIFO error interrupt enable
	DMA2_S4FCR_FS    = ((1UL << 3) - 1) << 3, // FIFO status
	DMA2_S4FCR_DMDIS = 1UL << 2,              // Direct mode disable
	DMA2_S4FCR_FTH   = ((1UL << 2) - 1) << 0, // FIFO threshold selection
};
inline void dma2_s4fcr_set_fs(struct DMA2_Type* p, uint32_t val) { p->S4FCR = (p->S4FCR & ~DMA2_S4FCR_FS) | ((val << 3) & DMA2_S4FCR_FS); }
inline void dma2_s4fcr_set_fth(struct DMA2_Type* p, uint32_t val) {
	p->S4FCR = (p->S4FCR & ~DMA2_S4FCR_FTH) | ((val << 0) & DMA2_S4FCR_FTH);
}
inline uint32_t dma2_s4fcr_get_fs(struct DMA2_Type* p) { return (p->S4FCR & DMA2_S4FCR_FS) >> 3; }
inline uint32_t dma2_s4fcr_get_fth(struct DMA2_Type* p) { return (p->S4FCR & DMA2_S4FCR_FTH) >> 0; }

// DMA2->S5CR stream x configuration register
enum {
	DMA2_S5CR_CHSEL  = ((1UL << 3) - 1) << 25, // Channel selection
	DMA2_S5CR_MBURST = ((1UL << 2) - 1) << 23, // Memory burst transfer configuration
	DMA2_S5CR_PBURST = ((1UL << 2) - 1) << 21, // Peripheral burst transfer configuration
	DMA2_S5CR_ACK    = 1UL << 20,              // ACK
	DMA2_S5CR_CT     = 1UL << 19,              // Current target (only in double buffer mode)
	DMA2_S5CR_DBM    = 1UL << 18,              // Double buffer mode
	DMA2_S5CR_PL     = ((1UL << 2) - 1) << 16, // Priority level
	DMA2_S5CR_PINCOS = 1UL << 15,              // Peripheral increment offset size
	DMA2_S5CR_MSIZE  = ((1UL << 2) - 1) << 13, // Memory data size
	DMA2_S5CR_PSIZE  = ((1UL << 2) - 1) << 11, // Peripheral data size
	DMA2_S5CR_MINC   = 1UL << 10,              // Memory increment mode
	DMA2_S5CR_PINC   = 1UL << 9,               // Peripheral increment mode
	DMA2_S5CR_CIRC   = 1UL << 8,               // Circular mode
	DMA2_S5CR_DIR    = ((1UL << 2) - 1) << 6,  // Data transfer direction
	DMA2_S5CR_PFCTRL = 1UL << 5,               // Peripheral flow controller
	DMA2_S5CR_TCIE   = 1UL << 4,               // Transfer complete interrupt enable
	DMA2_S5CR_HTIE   = 1UL << 3,               // Half transfer interrupt enable
	DMA2_S5CR_TEIE   = 1UL << 2,               // Transfer error interrupt enable
	DMA2_S5CR_DMEIE  = 1UL << 1,               // Direct mode error interrupt enable
	DMA2_S5CR_EN     = 1UL << 0,               // Stream enable / flag stream ready when read low
};
inline void dma2_s5cr_set_chsel(struct DMA2_Type* p, uint32_t val) {
	p->S5CR = (p->S5CR & ~DMA2_S5CR_CHSEL) | ((val << 25) & DMA2_S5CR_CHSEL);
}
inline void dma2_s5cr_set_mburst(struct DMA2_Type* p, uint32_t val) {
	p->S5CR = (p->S5CR & ~DMA2_S5CR_MBURST) | ((val << 23) & DMA2_S5CR_MBURST);
}
inline void dma2_s5cr_set_pburst(struct DMA2_Type* p, uint32_t val) {
	p->S5CR = (p->S5CR & ~DMA2_S5CR_PBURST) | ((val << 21) & DMA2_S5CR_PBURST);
}
inline void dma2_s5cr_set_pl(struct DMA2_Type* p, uint32_t val) { p->S5CR = (p->S5CR & ~DMA2_S5CR_PL) | ((val << 16) & DMA2_S5CR_PL); }
inline void dma2_s5cr_set_msize(struct DMA2_Type* p, uint32_t val) {
	p->S5CR = (p->S5CR & ~DMA2_S5CR_MSIZE) | ((val << 13) & DMA2_S5CR_MSIZE);
}
inline void dma2_s5cr_set_psize(struct DMA2_Type* p, uint32_t val) {
	p->S5CR = (p->S5CR & ~DMA2_S5CR_PSIZE) | ((val << 11) & DMA2_S5CR_PSIZE);
}
inline void dma2_s5cr_set_dir(struct DMA2_Type* p, uint32_t val) { p->S5CR = (p->S5CR & ~DMA2_S5CR_DIR) | ((val << 6) & DMA2_S5CR_DIR); }
inline uint32_t dma2_s5cr_get_chsel(struct DMA2_Type* p) { return (p->S5CR & DMA2_S5CR_CHSEL) >> 25; }
inline uint32_t dma2_s5cr_get_mburst(struct DMA2_Type* p) { return (p->S5CR & DMA2_S5CR_MBURST) >> 23; }
inline uint32_t dma2_s5cr_get_pburst(struct DMA2_Type* p) { return (p->S5CR & DMA2_S5CR_PBURST) >> 21; }
inline uint32_t dma2_s5cr_get_pl(struct DMA2_Type* p) { return (p->S5CR & DMA2_S5CR_PL) >> 16; }
inline uint32_t dma2_s5cr_get_msize(struct DMA2_Type* p) { return (p->S5CR & DMA2_S5CR_MSIZE) >> 13; }
inline uint32_t dma2_s5cr_get_psize(struct DMA2_Type* p) { return (p->S5CR & DMA2_S5CR_PSIZE) >> 11; }
inline uint32_t dma2_s5cr_get_dir(struct DMA2_Type* p) { return (p->S5CR & DMA2_S5CR_DIR) >> 6; }

// DMA2->S5FCR stream x FIFO control register
enum {
	DMA2_S5FCR_FEIE  = 1UL << 7,              // FIFO error interrupt enable
	DMA2_S5FCR_FS    = ((1UL << 3) - 1) << 3, // FIFO status
	DMA2_S5FCR_DMDIS = 1UL << 2,              // Direct mode disable
	DMA2_S5FCR_FTH   = ((1UL << 2) - 1) << 0, // FIFO threshold selection
};
inline void dma2_s5fcr_set_fs(struct DMA2_Type* p, uint32_t val) { p->S5FCR = (p->S5FCR & ~DMA2_S5FCR_FS) | ((val << 3) & DMA2_S5FCR_FS); }
inline void dma2_s5fcr_set_fth(struct DMA2_Type* p, uint32_t val) {
	p->S5FCR = (p->S5FCR & ~DMA2_S5FCR_FTH) | ((val << 0) & DMA2_S5FCR_FTH);
}
inline uint32_t dma2_s5fcr_get_fs(struct DMA2_Type* p) { return (p->S5FCR & DMA2_S5FCR_FS) >> 3; }
inline uint32_t dma2_s5fcr_get_fth(struct DMA2_Type* p) { return (p->S5FCR & DMA2_S5FCR_FTH) >> 0; }

// DMA2->S6CR stream x configuration register
enum {
	DMA2_S6CR_CHSEL  = ((1UL << 3) - 1) << 25, // Channel selection
	DMA2_S6CR_MBURST = ((1UL << 2) - 1) << 23, // Memory burst transfer configuration
	DMA2_S6CR_PBURST = ((1UL << 2) - 1) << 21, // Peripheral burst transfer configuration
	DMA2_S6CR_ACK    = 1UL << 20,              // ACK
	DMA2_S6CR_CT     = 1UL << 19,              // Current target (only in double buffer mode)
	DMA2_S6CR_DBM    = 1UL << 18,              // Double buffer mode
	DMA2_S6CR_PL     = ((1UL << 2) - 1) << 16, // Priority level
	DMA2_S6CR_PINCOS = 1UL << 15,              // Peripheral increment offset size
	DMA2_S6CR_MSIZE  = ((1UL << 2) - 1) << 13, // Memory data size
	DMA2_S6CR_PSIZE  = ((1UL << 2) - 1) << 11, // Peripheral data size
	DMA2_S6CR_MINC   = 1UL << 10,              // Memory increment mode
	DMA2_S6CR_PINC   = 1UL << 9,               // Peripheral increment mode
	DMA2_S6CR_CIRC   = 1UL << 8,               // Circular mode
	DMA2_S6CR_DIR    = ((1UL << 2) - 1) << 6,  // Data transfer direction
	DMA2_S6CR_PFCTRL = 1UL << 5,               // Peripheral flow controller
	DMA2_S6CR_TCIE   = 1UL << 4,               // Transfer complete interrupt enable
	DMA2_S6CR_HTIE   = 1UL << 3,               // Half transfer interrupt enable
	DMA2_S6CR_TEIE   = 1UL << 2,               // Transfer error interrupt enable
	DMA2_S6CR_DMEIE  = 1UL << 1,               // Direct mode error interrupt enable
	DMA2_S6CR_EN     = 1UL << 0,               // Stream enable / flag stream ready when read low
};
inline void dma2_s6cr_set_chsel(struct DMA2_Type* p, uint32_t val) {
	p->S6CR = (p->S6CR & ~DMA2_S6CR_CHSEL) | ((val << 25) & DMA2_S6CR_CHSEL);
}
inline void dma2_s6cr_set_mburst(struct DMA2_Type* p, uint32_t val) {
	p->S6CR = (p->S6CR & ~DMA2_S6CR_MBURST) | ((val << 23) & DMA2_S6CR_MBURST);
}
inline void dma2_s6cr_set_pburst(struct DMA2_Type* p, uint32_t val) {
	p->S6CR = (p->S6CR & ~DMA2_S6CR_PBURST) | ((val << 21) & DMA2_S6CR_PBURST);
}
inline void dma2_s6cr_set_pl(struct DMA2_Type* p, uint32_t val) { p->S6CR = (p->S6CR & ~DMA2_S6CR_PL) | ((val << 16) & DMA2_S6CR_PL); }
inline void dma2_s6cr_set_msize(struct DMA2_Type* p, uint32_t val) {
	p->S6CR = (p->S6CR & ~DMA2_S6CR_MSIZE) | ((val << 13) & DMA2_S6CR_MSIZE);
}
inline void dma2_s6cr_set_psize(struct DMA2_Type* p, uint32_t val) {
	p->S6CR = (p->S6CR & ~DMA2_S6CR_PSIZE) | ((val << 11) & DMA2_S6CR_PSIZE);
}
inline void dma2_s6cr_set_dir(struct DMA2_Type* p, uint32_t val) { p->S6CR = (p->S6CR & ~DMA2_S6CR_DIR) | ((val << 6) & DMA2_S6CR_DIR); }
inline uint32_t dma2_s6cr_get_chsel(struct DMA2_Type* p) { return (p->S6CR & DMA2_S6CR_CHSEL) >> 25; }
inline uint32_t dma2_s6cr_get_mburst(struct DMA2_Type* p) { return (p->S6CR & DMA2_S6CR_MBURST) >> 23; }
inline uint32_t dma2_s6cr_get_pburst(struct DMA2_Type* p) { return (p->S6CR & DMA2_S6CR_PBURST) >> 21; }
inline uint32_t dma2_s6cr_get_pl(struct DMA2_Type* p) { return (p->S6CR & DMA2_S6CR_PL) >> 16; }
inline uint32_t dma2_s6cr_get_msize(struct DMA2_Type* p) { return (p->S6CR & DMA2_S6CR_MSIZE) >> 13; }
inline uint32_t dma2_s6cr_get_psize(struct DMA2_Type* p) { return (p->S6CR & DMA2_S6CR_PSIZE) >> 11; }
inline uint32_t dma2_s6cr_get_dir(struct DMA2_Type* p) { return (p->S6CR & DMA2_S6CR_DIR) >> 6; }

// DMA2->S6FCR stream x FIFO control register
enum {
	DMA2_S6FCR_FEIE  = 1UL << 7,              // FIFO error interrupt enable
	DMA2_S6FCR_FS    = ((1UL << 3) - 1) << 3, // FIFO status
	DMA2_S6FCR_DMDIS = 1UL << 2,              // Direct mode disable
	DMA2_S6FCR_FTH   = ((1UL << 2) - 1) << 0, // FIFO threshold selection
};
inline void dma2_s6fcr_set_fs(struct DMA2_Type* p, uint32_t val) { p->S6FCR = (p->S6FCR & ~DMA2_S6FCR_FS) | ((val << 3) & DMA2_S6FCR_FS); }
inline void dma2_s6fcr_set_fth(struct DMA2_Type* p, uint32_t val) {
	p->S6FCR = (p->S6FCR & ~DMA2_S6FCR_FTH) | ((val << 0) & DMA2_S6FCR_FTH);
}
inline uint32_t dma2_s6fcr_get_fs(struct DMA2_Type* p) { return (p->S6FCR & DMA2_S6FCR_FS) >> 3; }
inline uint32_t dma2_s6fcr_get_fth(struct DMA2_Type* p) { return (p->S6FCR & DMA2_S6FCR_FTH) >> 0; }

// DMA2->S7CR stream x configuration register
enum {
	DMA2_S7CR_CHSEL  = ((1UL << 3) - 1) << 25, // Channel selection
	DMA2_S7CR_MBURST = ((1UL << 2) - 1) << 23, // Memory burst transfer configuration
	DMA2_S7CR_PBURST = ((1UL << 2) - 1) << 21, // Peripheral burst transfer configuration
	DMA2_S7CR_ACK    = 1UL << 20,              // ACK
	DMA2_S7CR_CT     = 1UL << 19,              // Current target (only in double buffer mode)
	DMA2_S7CR_DBM    = 1UL << 18,              // Double buffer mode
	DMA2_S7CR_PL     = ((1UL << 2) - 1) << 16, // Priority level
	DMA2_S7CR_PINCOS = 1UL << 15,              // Peripheral increment offset size
	DMA2_S7CR_MSIZE  = ((1UL << 2) - 1) << 13, // Memory data size
	DMA2_S7CR_PSIZE  = ((1UL << 2) - 1) << 11, // Peripheral data size
	DMA2_S7CR_MINC   = 1UL << 10,              // Memory increment mode
	DMA2_S7CR_PINC   = 1UL << 9,               // Peripheral increment mode
	DMA2_S7CR_CIRC   = 1UL << 8,               // Circular mode
	DMA2_S7CR_DIR    = ((1UL << 2) - 1) << 6,  // Data transfer direction
	DMA2_S7CR_PFCTRL = 1UL << 5,               // Peripheral flow controller
	DMA2_S7CR_TCIE   = 1UL << 4,               // Transfer complete interrupt enable
	DMA2_S7CR_HTIE   = 1UL << 3,               // Half transfer interrupt enable
	DMA2_S7CR_TEIE   = 1UL << 2,               // Transfer error interrupt enable
	DMA2_S7CR_DMEIE  = 1UL << 1,               // Direct mode error interrupt enable
	DMA2_S7CR_EN     = 1UL << 0,               // Stream enable / flag stream ready when read low
};
inline void dma2_s7cr_set_chsel(struct DMA2_Type* p, uint32_t val) {
	p->S7CR = (p->S7CR & ~DMA2_S7CR_CHSEL) | ((val << 25) & DMA2_S7CR_CHSEL);
}
inline void dma2_s7cr_set_mburst(struct DMA2_Type* p, uint32_t val) {
	p->S7CR = (p->S7CR & ~DMA2_S7CR_MBURST) | ((val << 23) & DMA2_S7CR_MBURST);
}
inline void dma2_s7cr_set_pburst(struct DMA2_Type* p, uint32_t val) {
	p->S7CR = (p->S7CR & ~DMA2_S7CR_PBURST) | ((val << 21) & DMA2_S7CR_PBURST);
}
inline void dma2_s7cr_set_pl(struct DMA2_Type* p, uint32_t val) { p->S7CR = (p->S7CR & ~DMA2_S7CR_PL) | ((val << 16) & DMA2_S7CR_PL); }
inline void dma2_s7cr_set_msize(struct DMA2_Type* p, uint32_t val) {
	p->S7CR = (p->S7CR & ~DMA2_S7CR_MSIZE) | ((val << 13) & DMA2_S7CR_MSIZE);
}
inline void dma2_s7cr_set_psize(struct DMA2_Type* p, uint32_t val) {
	p->S7CR = (p->S7CR & ~DMA2_S7CR_PSIZE) | ((val << 11) & DMA2_S7CR_PSIZE);
}
inline void dma2_s7cr_set_dir(struct DMA2_Type* p, uint32_t val) { p->S7CR = (p->S7CR & ~DMA2_S7CR_DIR) | ((val << 6) & DMA2_S7CR_DIR); }
inline uint32_t dma2_s7cr_get_chsel(struct DMA2_Type* p) { return (p->S7CR & DMA2_S7CR_CHSEL) >> 25; }
inline uint32_t dma2_s7cr_get_mburst(struct DMA2_Type* p) { return (p->S7CR & DMA2_S7CR_MBURST) >> 23; }
inline uint32_t dma2_s7cr_get_pburst(struct DMA2_Type* p) { return (p->S7CR & DMA2_S7CR_PBURST) >> 21; }
inline uint32_t dma2_s7cr_get_pl(struct DMA2_Type* p) { return (p->S7CR & DMA2_S7CR_PL) >> 16; }
inline uint32_t dma2_s7cr_get_msize(struct DMA2_Type* p) { return (p->S7CR & DMA2_S7CR_MSIZE) >> 13; }
inline uint32_t dma2_s7cr_get_psize(struct DMA2_Type* p) { return (p->S7CR & DMA2_S7CR_PSIZE) >> 11; }
inline uint32_t dma2_s7cr_get_dir(struct DMA2_Type* p) { return (p->S7CR & DMA2_S7CR_DIR) >> 6; }

// DMA2->S7FCR stream x FIFO control register
enum {
	DMA2_S7FCR_FEIE  = 1UL << 7,              // FIFO error interrupt enable
	DMA2_S7FCR_FS    = ((1UL << 3) - 1) << 3, // FIFO status
	DMA2_S7FCR_DMDIS = 1UL << 2,              // Direct mode disable
	DMA2_S7FCR_FTH   = ((1UL << 2) - 1) << 0, // FIFO threshold selection
};
inline void dma2_s7fcr_set_fs(struct DMA2_Type* p, uint32_t val) { p->S7FCR = (p->S7FCR & ~DMA2_S7FCR_FS) | ((val << 3) & DMA2_S7FCR_FS); }
inline void dma2_s7fcr_set_fth(struct DMA2_Type* p, uint32_t val) {
	p->S7FCR = (p->S7FCR & ~DMA2_S7FCR_FTH) | ((val << 0) & DMA2_S7FCR_FTH);
}
inline uint32_t dma2_s7fcr_get_fs(struct DMA2_Type* p) { return (p->S7FCR & DMA2_S7FCR_FS) >> 3; }
inline uint32_t dma2_s7fcr_get_fth(struct DMA2_Type* p) { return (p->S7FCR & DMA2_S7FCR_FTH) >> 0; }

/* External interrupt/event controller */
struct EXTI_Type {
	__IO uint32_t IMR;   // @0 Interrupt mask register (EXTI_IMR)
	__IO uint32_t EMR;   // @4 Event mask register (EXTI_EMR)
	__IO uint32_t RTSR;  // @8 Rising Trigger selection register (EXTI_RTSR)
	__IO uint32_t FTSR;  // @12 Falling Trigger selection register (EXTI_FTSR)
	__IO uint32_t SWIER; // @16 Software interrupt event register (EXTI_SWIER)
	__IO uint32_t PR;    // @20 Pending register (EXTI_PR)
};

// EXTI->IMR Interrupt mask register (EXTI_IMR)
enum {
	EXTI_IMR_MRX = ((1UL << 22) - 1) << 0, // Merged Interrupt Mask on line 22
};
inline void     exti_imr_set_mrx(struct EXTI_Type* p, uint32_t val) { p->IMR = (p->IMR & ~EXTI_IMR_MRX) | ((val << 0) & EXTI_IMR_MRX); }
inline uint32_t exti_imr_get_mrx(struct EXTI_Type* p) { return (p->IMR & EXTI_IMR_MRX) >> 0; }

// EXTI->EMR Event mask register (EXTI_EMR)
enum {
	EXTI_EMR_MRX = ((1UL << 22) - 1) << 0, // Merged Event Mask on line 22
};
inline void     exti_emr_set_mrx(struct EXTI_Type* p, uint32_t val) { p->EMR = (p->EMR & ~EXTI_EMR_MRX) | ((val << 0) & EXTI_EMR_MRX); }
inline uint32_t exti_emr_get_mrx(struct EXTI_Type* p) { return (p->EMR & EXTI_EMR_MRX) >> 0; }

// EXTI->RTSR Rising Trigger selection register (EXTI_RTSR)
enum {
	EXTI_RTSR_TRX = ((1UL << 22) - 1) << 0, // Merged Rising trigger event configuration of line 22
};
inline void exti_rtsr_set_trx(struct EXTI_Type* p, uint32_t val) { p->RTSR = (p->RTSR & ~EXTI_RTSR_TRX) | ((val << 0) & EXTI_RTSR_TRX); }
inline uint32_t exti_rtsr_get_trx(struct EXTI_Type* p) { return (p->RTSR & EXTI_RTSR_TRX) >> 0; }

// EXTI->FTSR Falling Trigger selection register (EXTI_FTSR)
enum {
	EXTI_FTSR_TRX = ((1UL << 22) - 1) << 0, // Merged Falling trigger event configuration of line 22
};
inline void exti_ftsr_set_trx(struct EXTI_Type* p, uint32_t val) { p->FTSR = (p->FTSR & ~EXTI_FTSR_TRX) | ((val << 0) & EXTI_FTSR_TRX); }
inline uint32_t exti_ftsr_get_trx(struct EXTI_Type* p) { return (p->FTSR & EXTI_FTSR_TRX) >> 0; }

// EXTI->SWIER Software interrupt event register (EXTI_SWIER)
enum {
	EXTI_SWIER_SWIERX = ((1UL << 22) - 1) << 0, // Merged Software Interrupt on line 22
};
inline void exti_swier_set_swierx(struct EXTI_Type* p, uint32_t val) {
	p->SWIER = (p->SWIER & ~EXTI_SWIER_SWIERX) | ((val << 0) & EXTI_SWIER_SWIERX);
}
inline uint32_t exti_swier_get_swierx(struct EXTI_Type* p) { return (p->SWIER & EXTI_SWIER_SWIERX) >> 0; }

// EXTI->PR Pending register (EXTI_PR)
enum {
	EXTI_PR_PRX = ((1UL << 22) - 1) << 0, // Merged Pending bit 22
};
inline void     exti_pr_set_prx(struct EXTI_Type* p, uint32_t val) { p->PR = (p->PR & ~EXTI_PR_PRX) | ((val << 0) & EXTI_PR_PRX); }
inline uint32_t exti_pr_get_prx(struct EXTI_Type* p) { return (p->PR & EXTI_PR_PRX) >> 0; }

/* FLASH */
struct FLASH_Type {
	__IO uint16_t ACR;          // @0 Flash access control register
	uint8_t       RESERVED0[2]; // @2
	__O uint32_t KEYR;          // @4 Flash key register
	__O uint32_t OPTKEYR;       // @8 Flash option key register
	__IO uint32_t SR;           // @12 Status register
	__IO uint32_t CR;           // @16 Control register
	__IO uint32_t OPTCR;        // @20 Flash option control register
};

// FLASH->ACR Flash access control register
enum {
	FLASH_ACR_DCRST   = 1UL << 12,             // Data cache reset
	FLASH_ACR_ICRST   = 1UL << 11,             // Instruction cache reset
	FLASH_ACR_DCEN    = 1UL << 10,             // Data cache enable
	FLASH_ACR_ICEN    = 1UL << 9,              // Instruction cache enable
	FLASH_ACR_PRFTEN  = 1UL << 8,              // Prefetch enable
	FLASH_ACR_LATENCY = ((1UL << 3) - 1) << 0, // Latency
};
inline void flash_acr_set_latency(struct FLASH_Type* p, uint32_t val) {
	p->ACR = (p->ACR & ~FLASH_ACR_LATENCY) | ((val << 0) & FLASH_ACR_LATENCY);
}
inline uint32_t flash_acr_get_latency(struct FLASH_Type* p) { return (p->ACR & FLASH_ACR_LATENCY) >> 0; }

// FLASH->SR Status register
enum {
	FLASH_SR_BSY    = 1UL << 16, // Busy
	FLASH_SR_PGSERR = 1UL << 7,  // Programming sequence error
	FLASH_SR_PGPERR = 1UL << 6,  // Programming parallelism error
	FLASH_SR_PGAERR = 1UL << 5,  // Programming alignment error
	FLASH_SR_WRPERR = 1UL << 4,  // Write protection error
	FLASH_SR_OPERR  = 1UL << 1,  // Operation error
	FLASH_SR_EOP    = 1UL << 0,  // End of operation
};

// FLASH->CR Control register
enum {
	FLASH_CR_LOCK  = 1UL << 31,             // Lock
	FLASH_CR_ERRIE = 1UL << 25,             // Error interrupt enable
	FLASH_CR_EOPIE = 1UL << 24,             // End of operation interrupt enable
	FLASH_CR_STRT  = 1UL << 16,             // Start
	FLASH_CR_PSIZE = ((1UL << 2) - 1) << 8, // Program size
	FLASH_CR_SNB   = ((1UL << 4) - 1) << 3, // Sector number
	FLASH_CR_MER   = 1UL << 2,              // Mass Erase
	FLASH_CR_SER   = 1UL << 1,              // Sector Erase
	FLASH_CR_PG    = 1UL << 0,              // Programming
};
inline void flash_cr_set_psize(struct FLASH_Type* p, uint32_t val) { p->CR = (p->CR & ~FLASH_CR_PSIZE) | ((val << 8) & FLASH_CR_PSIZE); }
inline void flash_cr_set_snb(struct FLASH_Type* p, uint32_t val) { p->CR = (p->CR & ~FLASH_CR_SNB) | ((val << 3) & FLASH_CR_SNB); }
inline uint32_t flash_cr_get_psize(struct FLASH_Type* p) { return (p->CR & FLASH_CR_PSIZE) >> 8; }
inline uint32_t flash_cr_get_snb(struct FLASH_Type* p) { return (p->CR & FLASH_CR_SNB) >> 3; }

// FLASH->OPTCR Flash option control register
enum {
	FLASH_OPTCR_NWRP       = ((1UL << 12) - 1) << 16, // Not write protect
	FLASH_OPTCR_RDP        = ((1UL << 8) - 1) << 8,   // Read protect
	FLASH_OPTCR_NRST_STDBY = 1UL << 7,                // nRST_STDBY User option bytes
	FLASH_OPTCR_NRST_STOP  = 1UL << 6,                // nRST_STOP User option bytes
	FLASH_OPTCR_WDG_SW     = 1UL << 5,                // WDG_SW User option bytes
	FLASH_OPTCR_BOR_LEV    = ((1UL << 2) - 1) << 2,   // BOR reset Level
	FLASH_OPTCR_OPTSTRT    = 1UL << 1,                // Option start
	FLASH_OPTCR_OPTLOCK    = 1UL << 0,                // Option lock
};
inline void flash_optcr_set_nwrp(struct FLASH_Type* p, uint32_t val) {
	p->OPTCR = (p->OPTCR & ~FLASH_OPTCR_NWRP) | ((val << 16) & FLASH_OPTCR_NWRP);
}
inline void flash_optcr_set_rdp(struct FLASH_Type* p, uint32_t val) {
	p->OPTCR = (p->OPTCR & ~FLASH_OPTCR_RDP) | ((val << 8) & FLASH_OPTCR_RDP);
}
inline void flash_optcr_set_bor_lev(struct FLASH_Type* p, uint32_t val) {
	p->OPTCR = (p->OPTCR & ~FLASH_OPTCR_BOR_LEV) | ((val << 2) & FLASH_OPTCR_BOR_LEV);
}
inline uint32_t flash_optcr_get_nwrp(struct FLASH_Type* p) { return (p->OPTCR & FLASH_OPTCR_NWRP) >> 16; }
inline uint32_t flash_optcr_get_rdp(struct FLASH_Type* p) { return (p->OPTCR & FLASH_OPTCR_RDP) >> 8; }
inline uint32_t flash_optcr_get_bor_lev(struct FLASH_Type* p) { return (p->OPTCR & FLASH_OPTCR_BOR_LEV) >> 2; }

/* Floting point unit */
struct FPU_Type {
	__IO uint32_t FPCCR; // @0 Floating-point context control register
	__IO uint32_t FPCAR; // @4 Floating-point context address register
	__IO uint32_t FPSCR; // @8 Floating-point status control register
};

// FPU->FPCCR Floating-point context control register
enum {
	FPU_FPCCR_ASPEN  = 1UL << 31, // ASPEN
	FPU_FPCCR_LSPEN  = 1UL << 30, // LSPEN
	FPU_FPCCR_MONRDY = 1UL << 8,  // MONRDY
	FPU_FPCCR_BFRDY  = 1UL << 6,  // BFRDY
	FPU_FPCCR_MMRDY  = 1UL << 5,  // MMRDY
	FPU_FPCCR_HFRDY  = 1UL << 4,  // HFRDY
	FPU_FPCCR_THREAD = 1UL << 3,  // THREAD
	FPU_FPCCR_USER   = 1UL << 1,  // USER
	FPU_FPCCR_LSPACT = 1UL << 0,  // LSPACT
};

// FPU->FPCAR Floating-point context address register
enum {
	FPU_FPCAR_ADDRESS = ((1UL << 29) - 1) << 3, // Location of unpopulated floating-point
};
inline void fpu_fpcar_set_address(struct FPU_Type* p, uint32_t val) {
	p->FPCAR = (p->FPCAR & ~FPU_FPCAR_ADDRESS) | ((val << 3) & FPU_FPCAR_ADDRESS);
}
inline uint32_t fpu_fpcar_get_address(struct FPU_Type* p) { return (p->FPCAR & FPU_FPCAR_ADDRESS) >> 3; }

// FPU->FPSCR Floating-point status control register
enum {
	FPU_FPSCR_N     = 1UL << 31,              // Negative condition code flag
	FPU_FPSCR_Z     = 1UL << 30,              // Zero condition code flag
	FPU_FPSCR_C     = 1UL << 29,              // Carry condition code flag
	FPU_FPSCR_V     = 1UL << 28,              // Overflow condition code flag
	FPU_FPSCR_AHP   = 1UL << 26,              // Alternative half-precision control bit
	FPU_FPSCR_DN    = 1UL << 25,              // Default NaN mode control bit
	FPU_FPSCR_FZ    = 1UL << 24,              // Flush-to-zero mode control bit:
	FPU_FPSCR_RMODE = ((1UL << 2) - 1) << 22, // Rounding Mode control field
	FPU_FPSCR_IDC   = 1UL << 7,               // Input denormal cumulative exception bit.
	FPU_FPSCR_IXC   = 1UL << 4,               // Inexact cumulative exception bit
	FPU_FPSCR_UFC   = 1UL << 3,               // Underflow cumulative exception bit
	FPU_FPSCR_OFC   = 1UL << 2,               // Overflow cumulative exception bit
	FPU_FPSCR_DZC   = 1UL << 1,               // Division by zero cumulative exception bit.
	FPU_FPSCR_IOC   = 1UL << 0,               // Invalid operation cumulative exception bit
};
inline void fpu_fpscr_set_rmode(struct FPU_Type* p, uint32_t val) {
	p->FPSCR = (p->FPSCR & ~FPU_FPSCR_RMODE) | ((val << 22) & FPU_FPSCR_RMODE);
}
inline uint32_t fpu_fpscr_get_rmode(struct FPU_Type* p) { return (p->FPSCR & FPU_FPSCR_RMODE) >> 22; }

/* Floating point unit CPACR */
struct FPU_CPACR_Type {
	__IO uint32_t CPACR; // @0 Coprocessor access control register
};

// FPU_CPACR->CPACR Coprocessor access control register
enum {
	FPU_CPACR_CPACR_CP = ((1UL << 4) - 1) << 20, // CP
};
inline void fpu_cpacr_cpacr_set_cp(struct FPU_CPACR_Type* p, uint32_t val) {
	p->CPACR = (p->CPACR & ~FPU_CPACR_CPACR_CP) | ((val << 20) & FPU_CPACR_CPACR_CP);
}
inline uint32_t fpu_cpacr_cpacr_get_cp(struct FPU_CPACR_Type* p) { return (p->CPACR & FPU_CPACR_CPACR_CP) >> 20; }

/* General-purpose I/Os */
struct GPIOA_Type {
	__IO uint32_t MODER;        // @0 GPIO port mode register
	__IO uint16_t OTYPER;       // @4 GPIO port output type register
	uint8_t       RESERVED0[2]; // @6
	__IO uint32_t OSPEEDR;      // @8 GPIO port output speed register
	__IO uint32_t PUPDR;        // @12 GPIO port pull-up/pull-down register
	__I uint16_t IDR;           // @16 GPIO port input data register
	uint8_t      RESERVED1[2];  // @18
	__IO uint16_t ODR;          // @20 GPIO port output data register
	uint8_t       RESERVED2[2]; // @22
	__O uint32_t BSRR;          // @24 GPIO port bit set/reset register
	__IO uint32_t LCKR;         // @28 GPIO port configuration lock register
	__IO uint32_t AFRL;         // @32 GPIO alternate function low register
	__IO uint32_t AFRH;         // @36 GPIO alternate function high register
};

// GPIOA->MODER GPIO port mode register
enum {
	GPIOA_MODER_MODER15 = ((1UL << 2) - 1) << 30, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER14 = ((1UL << 2) - 1) << 28, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER13 = ((1UL << 2) - 1) << 26, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER12 = ((1UL << 2) - 1) << 24, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER11 = ((1UL << 2) - 1) << 22, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER10 = ((1UL << 2) - 1) << 20, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER9  = ((1UL << 2) - 1) << 18, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER8  = ((1UL << 2) - 1) << 16, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER7  = ((1UL << 2) - 1) << 14, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER6  = ((1UL << 2) - 1) << 12, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER5  = ((1UL << 2) - 1) << 10, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER4  = ((1UL << 2) - 1) << 8,  // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER3  = ((1UL << 2) - 1) << 6,  // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER2  = ((1UL << 2) - 1) << 4,  // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER1  = ((1UL << 2) - 1) << 2,  // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER0  = ((1UL << 2) - 1) << 0,  // Port x configuration bits (y = 0..15)
};
inline void gpioa_moder_set_moder15(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER15) | ((val << 30) & GPIOA_MODER_MODER15);
}
inline void gpioa_moder_set_moder14(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER14) | ((val << 28) & GPIOA_MODER_MODER14);
}
inline void gpioa_moder_set_moder13(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER13) | ((val << 26) & GPIOA_MODER_MODER13);
}
inline void gpioa_moder_set_moder12(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER12) | ((val << 24) & GPIOA_MODER_MODER12);
}
inline void gpioa_moder_set_moder11(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER11) | ((val << 22) & GPIOA_MODER_MODER11);
}
inline void gpioa_moder_set_moder10(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER10) | ((val << 20) & GPIOA_MODER_MODER10);
}
inline void gpioa_moder_set_moder9(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER9) | ((val << 18) & GPIOA_MODER_MODER9);
}
inline void gpioa_moder_set_moder8(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER8) | ((val << 16) & GPIOA_MODER_MODER8);
}
inline void gpioa_moder_set_moder7(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER7) | ((val << 14) & GPIOA_MODER_MODER7);
}
inline void gpioa_moder_set_moder6(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER6) | ((val << 12) & GPIOA_MODER_MODER6);
}
inline void gpioa_moder_set_moder5(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER5) | ((val << 10) & GPIOA_MODER_MODER5);
}
inline void gpioa_moder_set_moder4(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER4) | ((val << 8) & GPIOA_MODER_MODER4);
}
inline void gpioa_moder_set_moder3(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER3) | ((val << 6) & GPIOA_MODER_MODER3);
}
inline void gpioa_moder_set_moder2(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER2) | ((val << 4) & GPIOA_MODER_MODER2);
}
inline void gpioa_moder_set_moder1(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER1) | ((val << 2) & GPIOA_MODER_MODER1);
}
inline void gpioa_moder_set_moder0(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER0) | ((val << 0) & GPIOA_MODER_MODER0);
}
inline uint32_t gpioa_moder_get_moder15(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER15) >> 30; }
inline uint32_t gpioa_moder_get_moder14(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER14) >> 28; }
inline uint32_t gpioa_moder_get_moder13(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER13) >> 26; }
inline uint32_t gpioa_moder_get_moder12(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER12) >> 24; }
inline uint32_t gpioa_moder_get_moder11(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER11) >> 22; }
inline uint32_t gpioa_moder_get_moder10(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER10) >> 20; }
inline uint32_t gpioa_moder_get_moder9(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER9) >> 18; }
inline uint32_t gpioa_moder_get_moder8(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER8) >> 16; }
inline uint32_t gpioa_moder_get_moder7(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER7) >> 14; }
inline uint32_t gpioa_moder_get_moder6(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER6) >> 12; }
inline uint32_t gpioa_moder_get_moder5(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER5) >> 10; }
inline uint32_t gpioa_moder_get_moder4(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER4) >> 8; }
inline uint32_t gpioa_moder_get_moder3(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER3) >> 6; }
inline uint32_t gpioa_moder_get_moder2(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER2) >> 4; }
inline uint32_t gpioa_moder_get_moder1(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER1) >> 2; }
inline uint32_t gpioa_moder_get_moder0(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER0) >> 0; }

// GPIOA->OTYPER GPIO port output type register
enum {
	GPIOA_OTYPER_OTX = ((1UL << 15) - 1) << 0, // Merged Port x configuration bits (y = 0..15)
};
inline void gpioa_otyper_set_otx(struct GPIOA_Type* p, uint32_t val) {
	p->OTYPER = (p->OTYPER & ~GPIOA_OTYPER_OTX) | ((val << 0) & GPIOA_OTYPER_OTX);
}
inline uint32_t gpioa_otyper_get_otx(struct GPIOA_Type* p) { return (p->OTYPER & GPIOA_OTYPER_OTX) >> 0; }

// GPIOA->OSPEEDR GPIO port output speed register
enum {
	GPIOA_OSPEEDR_OSPEEDR15 = ((1UL << 2) - 1) << 30, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR14 = ((1UL << 2) - 1) << 28, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR13 = ((1UL << 2) - 1) << 26, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR12 = ((1UL << 2) - 1) << 24, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR11 = ((1UL << 2) - 1) << 22, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR10 = ((1UL << 2) - 1) << 20, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR9  = ((1UL << 2) - 1) << 18, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR8  = ((1UL << 2) - 1) << 16, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR7  = ((1UL << 2) - 1) << 14, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR6  = ((1UL << 2) - 1) << 12, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR5  = ((1UL << 2) - 1) << 10, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR4  = ((1UL << 2) - 1) << 8,  // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR3  = ((1UL << 2) - 1) << 6,  // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR2  = ((1UL << 2) - 1) << 4,  // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR1  = ((1UL << 2) - 1) << 2,  // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR0  = ((1UL << 2) - 1) << 0,  // Port x configuration bits (y = 0..15)
};
inline void gpioa_ospeedr_set_ospeedr15(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR15) | ((val << 30) & GPIOA_OSPEEDR_OSPEEDR15);
}
inline void gpioa_ospeedr_set_ospeedr14(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR14) | ((val << 28) & GPIOA_OSPEEDR_OSPEEDR14);
}
inline void gpioa_ospeedr_set_ospeedr13(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR13) | ((val << 26) & GPIOA_OSPEEDR_OSPEEDR13);
}
inline void gpioa_ospeedr_set_ospeedr12(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR12) | ((val << 24) & GPIOA_OSPEEDR_OSPEEDR12);
}
inline void gpioa_ospeedr_set_ospeedr11(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR11) | ((val << 22) & GPIOA_OSPEEDR_OSPEEDR11);
}
inline void gpioa_ospeedr_set_ospeedr10(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR10) | ((val << 20) & GPIOA_OSPEEDR_OSPEEDR10);
}
inline void gpioa_ospeedr_set_ospeedr9(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR9) | ((val << 18) & GPIOA_OSPEEDR_OSPEEDR9);
}
inline void gpioa_ospeedr_set_ospeedr8(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR8) | ((val << 16) & GPIOA_OSPEEDR_OSPEEDR8);
}
inline void gpioa_ospeedr_set_ospeedr7(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR7) | ((val << 14) & GPIOA_OSPEEDR_OSPEEDR7);
}
inline void gpioa_ospeedr_set_ospeedr6(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR6) | ((val << 12) & GPIOA_OSPEEDR_OSPEEDR6);
}
inline void gpioa_ospeedr_set_ospeedr5(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR5) | ((val << 10) & GPIOA_OSPEEDR_OSPEEDR5);
}
inline void gpioa_ospeedr_set_ospeedr4(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR4) | ((val << 8) & GPIOA_OSPEEDR_OSPEEDR4);
}
inline void gpioa_ospeedr_set_ospeedr3(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR3) | ((val << 6) & GPIOA_OSPEEDR_OSPEEDR3);
}
inline void gpioa_ospeedr_set_ospeedr2(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR2) | ((val << 4) & GPIOA_OSPEEDR_OSPEEDR2);
}
inline void gpioa_ospeedr_set_ospeedr1(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR1) | ((val << 2) & GPIOA_OSPEEDR_OSPEEDR1);
}
inline void gpioa_ospeedr_set_ospeedr0(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR0) | ((val << 0) & GPIOA_OSPEEDR_OSPEEDR0);
}
inline uint32_t gpioa_ospeedr_get_ospeedr15(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR15) >> 30; }
inline uint32_t gpioa_ospeedr_get_ospeedr14(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR14) >> 28; }
inline uint32_t gpioa_ospeedr_get_ospeedr13(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR13) >> 26; }
inline uint32_t gpioa_ospeedr_get_ospeedr12(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR12) >> 24; }
inline uint32_t gpioa_ospeedr_get_ospeedr11(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR11) >> 22; }
inline uint32_t gpioa_ospeedr_get_ospeedr10(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR10) >> 20; }
inline uint32_t gpioa_ospeedr_get_ospeedr9(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR9) >> 18; }
inline uint32_t gpioa_ospeedr_get_ospeedr8(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR8) >> 16; }
inline uint32_t gpioa_ospeedr_get_ospeedr7(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR7) >> 14; }
inline uint32_t gpioa_ospeedr_get_ospeedr6(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR6) >> 12; }
inline uint32_t gpioa_ospeedr_get_ospeedr5(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR5) >> 10; }
inline uint32_t gpioa_ospeedr_get_ospeedr4(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR4) >> 8; }
inline uint32_t gpioa_ospeedr_get_ospeedr3(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR3) >> 6; }
inline uint32_t gpioa_ospeedr_get_ospeedr2(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR2) >> 4; }
inline uint32_t gpioa_ospeedr_get_ospeedr1(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR1) >> 2; }
inline uint32_t gpioa_ospeedr_get_ospeedr0(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR0) >> 0; }

// GPIOA->PUPDR GPIO port pull-up/pull-down register
enum {
	GPIOA_PUPDR_PUPDR15 = ((1UL << 2) - 1) << 30, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR14 = ((1UL << 2) - 1) << 28, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR13 = ((1UL << 2) - 1) << 26, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR12 = ((1UL << 2) - 1) << 24, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR11 = ((1UL << 2) - 1) << 22, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR10 = ((1UL << 2) - 1) << 20, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR9  = ((1UL << 2) - 1) << 18, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR8  = ((1UL << 2) - 1) << 16, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR7  = ((1UL << 2) - 1) << 14, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR6  = ((1UL << 2) - 1) << 12, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR5  = ((1UL << 2) - 1) << 10, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR4  = ((1UL << 2) - 1) << 8,  // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR3  = ((1UL << 2) - 1) << 6,  // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR2  = ((1UL << 2) - 1) << 4,  // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR1  = ((1UL << 2) - 1) << 2,  // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR0  = ((1UL << 2) - 1) << 0,  // Port x configuration bits (y = 0..15)
};
inline void gpioa_pupdr_set_pupdr15(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR15) | ((val << 30) & GPIOA_PUPDR_PUPDR15);
}
inline void gpioa_pupdr_set_pupdr14(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR14) | ((val << 28) & GPIOA_PUPDR_PUPDR14);
}
inline void gpioa_pupdr_set_pupdr13(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR13) | ((val << 26) & GPIOA_PUPDR_PUPDR13);
}
inline void gpioa_pupdr_set_pupdr12(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR12) | ((val << 24) & GPIOA_PUPDR_PUPDR12);
}
inline void gpioa_pupdr_set_pupdr11(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR11) | ((val << 22) & GPIOA_PUPDR_PUPDR11);
}
inline void gpioa_pupdr_set_pupdr10(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR10) | ((val << 20) & GPIOA_PUPDR_PUPDR10);
}
inline void gpioa_pupdr_set_pupdr9(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR9) | ((val << 18) & GPIOA_PUPDR_PUPDR9);
}
inline void gpioa_pupdr_set_pupdr8(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR8) | ((val << 16) & GPIOA_PUPDR_PUPDR8);
}
inline void gpioa_pupdr_set_pupdr7(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR7) | ((val << 14) & GPIOA_PUPDR_PUPDR7);
}
inline void gpioa_pupdr_set_pupdr6(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR6) | ((val << 12) & GPIOA_PUPDR_PUPDR6);
}
inline void gpioa_pupdr_set_pupdr5(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR5) | ((val << 10) & GPIOA_PUPDR_PUPDR5);
}
inline void gpioa_pupdr_set_pupdr4(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR4) | ((val << 8) & GPIOA_PUPDR_PUPDR4);
}
inline void gpioa_pupdr_set_pupdr3(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR3) | ((val << 6) & GPIOA_PUPDR_PUPDR3);
}
inline void gpioa_pupdr_set_pupdr2(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR2) | ((val << 4) & GPIOA_PUPDR_PUPDR2);
}
inline void gpioa_pupdr_set_pupdr1(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR1) | ((val << 2) & GPIOA_PUPDR_PUPDR1);
}
inline void gpioa_pupdr_set_pupdr0(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR0) | ((val << 0) & GPIOA_PUPDR_PUPDR0);
}
inline uint32_t gpioa_pupdr_get_pupdr15(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR15) >> 30; }
inline uint32_t gpioa_pupdr_get_pupdr14(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR14) >> 28; }
inline uint32_t gpioa_pupdr_get_pupdr13(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR13) >> 26; }
inline uint32_t gpioa_pupdr_get_pupdr12(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR12) >> 24; }
inline uint32_t gpioa_pupdr_get_pupdr11(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR11) >> 22; }
inline uint32_t gpioa_pupdr_get_pupdr10(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR10) >> 20; }
inline uint32_t gpioa_pupdr_get_pupdr9(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR9) >> 18; }
inline uint32_t gpioa_pupdr_get_pupdr8(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR8) >> 16; }
inline uint32_t gpioa_pupdr_get_pupdr7(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR7) >> 14; }
inline uint32_t gpioa_pupdr_get_pupdr6(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR6) >> 12; }
inline uint32_t gpioa_pupdr_get_pupdr5(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR5) >> 10; }
inline uint32_t gpioa_pupdr_get_pupdr4(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR4) >> 8; }
inline uint32_t gpioa_pupdr_get_pupdr3(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR3) >> 6; }
inline uint32_t gpioa_pupdr_get_pupdr2(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR2) >> 4; }
inline uint32_t gpioa_pupdr_get_pupdr1(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR1) >> 2; }
inline uint32_t gpioa_pupdr_get_pupdr0(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR0) >> 0; }

// GPIOA->IDR GPIO port input data register
enum {
	GPIOA_IDR_IDRX = ((1UL << 15) - 1) << 0, // Merged Port input data (y = 0..15)
};
inline uint32_t gpioa_idr_get_idrx(struct GPIOA_Type* p) { return (p->IDR & GPIOA_IDR_IDRX) >> 0; }

// GPIOA->ODR GPIO port output data register
enum {
	GPIOA_ODR_ODRX = ((1UL << 15) - 1) << 0, // Merged Port output data (y = 0..15)
};
inline void gpioa_odr_set_odrx(struct GPIOA_Type* p, uint32_t val) { p->ODR = (p->ODR & ~GPIOA_ODR_ODRX) | ((val << 0) & GPIOA_ODR_ODRX); }
inline uint32_t gpioa_odr_get_odrx(struct GPIOA_Type* p) { return (p->ODR & GPIOA_ODR_ODRX) >> 0; }

// GPIOA->BSRR GPIO port bit set/reset register
enum {
	GPIOA_BSRR_BR15 = 1UL << 31, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR14 = 1UL << 30, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR13 = 1UL << 29, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR12 = 1UL << 28, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR11 = 1UL << 27, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR10 = 1UL << 26, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR9  = 1UL << 25, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR8  = 1UL << 24, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR7  = 1UL << 23, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR6  = 1UL << 22, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR5  = 1UL << 21, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR4  = 1UL << 20, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR3  = 1UL << 19, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR2  = 1UL << 18, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR1  = 1UL << 17, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR0  = 1UL << 16, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS15 = 1UL << 15, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS14 = 1UL << 14, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS13 = 1UL << 13, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS12 = 1UL << 12, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS11 = 1UL << 11, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS10 = 1UL << 10, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS9  = 1UL << 9,  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS8  = 1UL << 8,  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS7  = 1UL << 7,  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS6  = 1UL << 6,  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS5  = 1UL << 5,  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS4  = 1UL << 4,  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS3  = 1UL << 3,  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS2  = 1UL << 2,  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS1  = 1UL << 1,  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS0  = 1UL << 0,  // Port x set bit y (y= 0..15)
};

// GPIOA->LCKR GPIO port configuration lock register
enum {
	GPIOA_LCKR_LCKK  = 1UL << 16, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK15 = 1UL << 15, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK14 = 1UL << 14, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK13 = 1UL << 13, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK12 = 1UL << 12, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK11 = 1UL << 11, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK10 = 1UL << 10, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK9  = 1UL << 9,  // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK8  = 1UL << 8,  // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK7  = 1UL << 7,  // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK6  = 1UL << 6,  // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK5  = 1UL << 5,  // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK4  = 1UL << 4,  // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK3  = 1UL << 3,  // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK2  = 1UL << 2,  // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK1  = 1UL << 1,  // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK0  = 1UL << 0,  // Port x lock bit y (y= 0..15)
};

// GPIOA->AFRL GPIO alternate function low register
enum {
	GPIOA_AFRL_AFRL7 = ((1UL << 4) - 1) << 28, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL6 = ((1UL << 4) - 1) << 24, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL5 = ((1UL << 4) - 1) << 20, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL4 = ((1UL << 4) - 1) << 16, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL3 = ((1UL << 4) - 1) << 12, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL2 = ((1UL << 4) - 1) << 8,  // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL1 = ((1UL << 4) - 1) << 4,  // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL0 = ((1UL << 4) - 1) << 0,  // Alternate function selection for port x bit y (y = 0..7)
};
inline void gpioa_afrl_set_afrl7(struct GPIOA_Type* p, uint32_t val) {
	p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL7) | ((val << 28) & GPIOA_AFRL_AFRL7);
}
inline void gpioa_afrl_set_afrl6(struct GPIOA_Type* p, uint32_t val) {
	p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL6) | ((val << 24) & GPIOA_AFRL_AFRL6);
}
inline void gpioa_afrl_set_afrl5(struct GPIOA_Type* p, uint32_t val) {
	p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL5) | ((val << 20) & GPIOA_AFRL_AFRL5);
}
inline void gpioa_afrl_set_afrl4(struct GPIOA_Type* p, uint32_t val) {
	p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL4) | ((val << 16) & GPIOA_AFRL_AFRL4);
}
inline void gpioa_afrl_set_afrl3(struct GPIOA_Type* p, uint32_t val) {
	p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL3) | ((val << 12) & GPIOA_AFRL_AFRL3);
}
inline void gpioa_afrl_set_afrl2(struct GPIOA_Type* p, uint32_t val) {
	p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL2) | ((val << 8) & GPIOA_AFRL_AFRL2);
}
inline void gpioa_afrl_set_afrl1(struct GPIOA_Type* p, uint32_t val) {
	p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL1) | ((val << 4) & GPIOA_AFRL_AFRL1);
}
inline void gpioa_afrl_set_afrl0(struct GPIOA_Type* p, uint32_t val) {
	p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL0) | ((val << 0) & GPIOA_AFRL_AFRL0);
}
inline uint32_t gpioa_afrl_get_afrl7(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL7) >> 28; }
inline uint32_t gpioa_afrl_get_afrl6(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL6) >> 24; }
inline uint32_t gpioa_afrl_get_afrl5(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL5) >> 20; }
inline uint32_t gpioa_afrl_get_afrl4(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL4) >> 16; }
inline uint32_t gpioa_afrl_get_afrl3(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL3) >> 12; }
inline uint32_t gpioa_afrl_get_afrl2(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL2) >> 8; }
inline uint32_t gpioa_afrl_get_afrl1(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL1) >> 4; }
inline uint32_t gpioa_afrl_get_afrl0(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL0) >> 0; }

// GPIOA->AFRH GPIO alternate function high register
enum {
	GPIOA_AFRH_AFRH15 = ((1UL << 4) - 1) << 28, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH14 = ((1UL << 4) - 1) << 24, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH13 = ((1UL << 4) - 1) << 20, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH12 = ((1UL << 4) - 1) << 16, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH11 = ((1UL << 4) - 1) << 12, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH10 = ((1UL << 4) - 1) << 8,  // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH9  = ((1UL << 4) - 1) << 4,  // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH8  = ((1UL << 4) - 1) << 0,  // Alternate function selection for port x bit y (y = 8..15)
};
inline void gpioa_afrh_set_afrh15(struct GPIOA_Type* p, uint32_t val) {
	p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH15) | ((val << 28) & GPIOA_AFRH_AFRH15);
}
inline void gpioa_afrh_set_afrh14(struct GPIOA_Type* p, uint32_t val) {
	p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH14) | ((val << 24) & GPIOA_AFRH_AFRH14);
}
inline void gpioa_afrh_set_afrh13(struct GPIOA_Type* p, uint32_t val) {
	p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH13) | ((val << 20) & GPIOA_AFRH_AFRH13);
}
inline void gpioa_afrh_set_afrh12(struct GPIOA_Type* p, uint32_t val) {
	p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH12) | ((val << 16) & GPIOA_AFRH_AFRH12);
}
inline void gpioa_afrh_set_afrh11(struct GPIOA_Type* p, uint32_t val) {
	p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH11) | ((val << 12) & GPIOA_AFRH_AFRH11);
}
inline void gpioa_afrh_set_afrh10(struct GPIOA_Type* p, uint32_t val) {
	p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH10) | ((val << 8) & GPIOA_AFRH_AFRH10);
}
inline void gpioa_afrh_set_afrh9(struct GPIOA_Type* p, uint32_t val) {
	p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH9) | ((val << 4) & GPIOA_AFRH_AFRH9);
}
inline void gpioa_afrh_set_afrh8(struct GPIOA_Type* p, uint32_t val) {
	p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH8) | ((val << 0) & GPIOA_AFRH_AFRH8);
}
inline uint32_t gpioa_afrh_get_afrh15(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH15) >> 28; }
inline uint32_t gpioa_afrh_get_afrh14(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH14) >> 24; }
inline uint32_t gpioa_afrh_get_afrh13(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH13) >> 20; }
inline uint32_t gpioa_afrh_get_afrh12(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH12) >> 16; }
inline uint32_t gpioa_afrh_get_afrh11(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH11) >> 12; }
inline uint32_t gpioa_afrh_get_afrh10(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH10) >> 8; }
inline uint32_t gpioa_afrh_get_afrh9(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH9) >> 4; }
inline uint32_t gpioa_afrh_get_afrh8(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH8) >> 0; }

/* Inter-integrated circuit */
struct I2C3_Type {
	__IO uint16_t CR1;          // @0 Control register 1
	uint8_t       RESERVED0[2]; // @2
	__IO uint16_t CR2;          // @4 Control register 2
	uint8_t       RESERVED1[2]; // @6
	__IO uint16_t OAR1;         // @8 Own address register 1
	uint8_t       RESERVED2[2]; // @10
	__IO uint8_t OAR2;          // @12 Own address register 2
	uint8_t      RESERVED3[3];  // @13
	__IO uint8_t DR;            // @16 Data register
	uint8_t      RESERVED4[3];  // @17
	__IO uint16_t SR1;          // @20 Status register 1
	uint8_t       RESERVED5[2]; // @22
	__I uint16_t SR2;           // @24 Status register 2
	uint8_t      RESERVED6[2];  // @26
	__IO uint16_t CCR;          // @28 Clock control register
	uint8_t       RESERVED7[2]; // @30
	__IO uint8_t TRISE;         // @32 TRISE register
};

// I2C3->CR1 Control register 1
enum {
	I2C3_CR1_SWRST     = 1UL << 15, // Software reset
	I2C3_CR1_ALERT     = 1UL << 13, // SMBus alert
	I2C3_CR1_PEC       = 1UL << 12, // Packet error checking
	I2C3_CR1_POS       = 1UL << 11, // Acknowledge/PEC Position (for data reception)
	I2C3_CR1_ACK       = 1UL << 10, // Acknowledge enable
	I2C3_CR1_STOP      = 1UL << 9,  // Stop generation
	I2C3_CR1_START     = 1UL << 8,  // Start generation
	I2C3_CR1_NOSTRETCH = 1UL << 7,  // Clock stretching disable (Slave mode)
	I2C3_CR1_ENGC      = 1UL << 6,  // General call enable
	I2C3_CR1_ENPEC     = 1UL << 5,  // PEC enable
	I2C3_CR1_ENARP     = 1UL << 4,  // ARP enable
	I2C3_CR1_SMBTYPE   = 1UL << 3,  // SMBus type
	I2C3_CR1_SMBUS     = 1UL << 1,  // SMBus mode
	I2C3_CR1_PE        = 1UL << 0,  // Peripheral enable
};

// I2C3->CR2 Control register 2
enum {
	I2C3_CR2_LAST    = 1UL << 12,             // DMA last transfer
	I2C3_CR2_DMAEN   = 1UL << 11,             // DMA requests enable
	I2C3_CR2_ITBUFEN = 1UL << 10,             // Buffer interrupt enable
	I2C3_CR2_ITEVTEN = 1UL << 9,              // Event interrupt enable
	I2C3_CR2_ITERREN = 1UL << 8,              // Error interrupt enable
	I2C3_CR2_FREQ    = ((1UL << 6) - 1) << 0, // Peripheral clock frequency
};
inline void     i2c3_cr2_set_freq(struct I2C3_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~I2C3_CR2_FREQ) | ((val << 0) & I2C3_CR2_FREQ); }
inline uint32_t i2c3_cr2_get_freq(struct I2C3_Type* p) { return (p->CR2 & I2C3_CR2_FREQ) >> 0; }

// I2C3->OAR1 Own address register 1
enum {
	I2C3_OAR1_ADDMODE = 1UL << 15,             // Addressing mode (slave mode)
	I2C3_OAR1_ADD10   = ((1UL << 2) - 1) << 8, // Interface address
	I2C3_OAR1_ADD7    = ((1UL << 7) - 1) << 1, // Interface address
	I2C3_OAR1_ADD0    = 1UL << 0,              // Interface address
};
inline void i2c3_oar1_set_add10(struct I2C3_Type* p, uint32_t val) {
	p->OAR1 = (p->OAR1 & ~I2C3_OAR1_ADD10) | ((val << 8) & I2C3_OAR1_ADD10);
}
inline void i2c3_oar1_set_add7(struct I2C3_Type* p, uint32_t val) { p->OAR1 = (p->OAR1 & ~I2C3_OAR1_ADD7) | ((val << 1) & I2C3_OAR1_ADD7); }
inline uint32_t i2c3_oar1_get_add10(struct I2C3_Type* p) { return (p->OAR1 & I2C3_OAR1_ADD10) >> 8; }
inline uint32_t i2c3_oar1_get_add7(struct I2C3_Type* p) { return (p->OAR1 & I2C3_OAR1_ADD7) >> 1; }

// I2C3->OAR2 Own address register 2
enum {
	I2C3_OAR2_ADD2   = ((1UL << 7) - 1) << 1, // Interface address
	I2C3_OAR2_ENDUAL = 1UL << 0,              // Dual addressing mode enable
};
inline void i2c3_oar2_set_add2(struct I2C3_Type* p, uint32_t val) { p->OAR2 = (p->OAR2 & ~I2C3_OAR2_ADD2) | ((val << 1) & I2C3_OAR2_ADD2); }
inline uint32_t i2c3_oar2_get_add2(struct I2C3_Type* p) { return (p->OAR2 & I2C3_OAR2_ADD2) >> 1; }

// I2C3->SR1 Status register 1
enum {
	I2C3_SR1_SMBALERT = 1UL << 15, // SMBus alert
	I2C3_SR1_TIMEOUT  = 1UL << 14, // Timeout or Tlow error
	I2C3_SR1_PECERR   = 1UL << 12, // PEC Error in reception
	I2C3_SR1_OVR      = 1UL << 11, // Overrun/Underrun
	I2C3_SR1_AF       = 1UL << 10, // Acknowledge failure
	I2C3_SR1_ARLO     = 1UL << 9,  // Arbitration lost (master mode)
	I2C3_SR1_BERR     = 1UL << 8,  // Bus error
	I2C3_SR1_TXE      = 1UL << 7,  // Data register empty (transmitters)
	I2C3_SR1_RXNE     = 1UL << 6,  // Data register not empty (receivers)
	I2C3_SR1_STOPF    = 1UL << 4,  // Stop detection (slave mode)
	I2C3_SR1_ADD10    = 1UL << 3,  // 10-bit header sent (Master mode)
	I2C3_SR1_BTF      = 1UL << 2,  // Byte transfer finished
	I2C3_SR1_ADDR     = 1UL << 1,  // Address sent (master mode)/matched (slave mode)
	I2C3_SR1_SB       = 1UL << 0,  // Start bit (Master mode)
};

// I2C3->SR2 Status register 2
enum {
	I2C3_SR2_PEC        = ((1UL << 8) - 1) << 8, // acket error checking register
	I2C3_SR2_DUALF      = 1UL << 7,              // Dual flag (Slave mode)
	I2C3_SR2_SMBHOST    = 1UL << 6,              // SMBus host header (Slave mode)
	I2C3_SR2_SMBDEFAULT = 1UL << 5,              // SMBus device default address (Slave mode)
	I2C3_SR2_GENCALL    = 1UL << 4,              // General call address (Slave mode)
	I2C3_SR2_TRA        = 1UL << 2,              // Transmitter/receiver
	I2C3_SR2_BUSY       = 1UL << 1,              // Bus busy
	I2C3_SR2_MSL        = 1UL << 0,              // Master/slave
};
inline uint32_t i2c3_sr2_get_pec(struct I2C3_Type* p) { return (p->SR2 & I2C3_SR2_PEC) >> 8; }

// I2C3->CCR Clock control register
enum {
	I2C3_CCR_F_S  = 1UL << 15,              // I2C master mode selection
	I2C3_CCR_DUTY = 1UL << 14,              // Fast mode duty cycle
	I2C3_CCR_CCR  = ((1UL << 12) - 1) << 0, // Clock control register in Fast/Standard mode (Master mode)
};
inline void     i2c3_ccr_set_ccr(struct I2C3_Type* p, uint32_t val) { p->CCR = (p->CCR & ~I2C3_CCR_CCR) | ((val << 0) & I2C3_CCR_CCR); }
inline uint32_t i2c3_ccr_get_ccr(struct I2C3_Type* p) { return (p->CCR & I2C3_CCR_CCR) >> 0; }

// I2C3->TRISE TRISE register
enum {
	I2C3_TRISE_TRISE = ((1UL << 6) - 1) << 0, // Maximum rise time in Fast/Standard mode (Master mode)
};
inline void i2c3_trise_set_trise(struct I2C3_Type* p, uint32_t val) {
	p->TRISE = (p->TRISE & ~I2C3_TRISE_TRISE) | ((val << 0) & I2C3_TRISE_TRISE);
}
inline uint32_t i2c3_trise_get_trise(struct I2C3_Type* p) { return (p->TRISE & I2C3_TRISE_TRISE) >> 0; }

/* Serial peripheral interface */
struct I2S2ext_Type {
	__IO uint16_t CR1;          // @0 control register 1
	uint8_t       RESERVED0[2]; // @2
	__IO uint8_t CR2;           // @4 control register 2
	uint8_t      RESERVED1[3];  // @5
	__IO uint16_t SR;           // @8 status register
	uint8_t       RESERVED2[2]; // @10
	__IO uint16_t DR;           // @12 data register
	uint8_t       RESERVED3[2]; // @14
	__IO uint16_t CRCPR;        // @16 CRC polynomial register
	uint8_t       RESERVED4[2]; // @18
	__I uint16_t RXCRCR;        // @20 RX CRC register
	uint8_t      RESERVED5[2];  // @22
	__I uint16_t TXCRCR;        // @24 TX CRC register
	uint8_t      RESERVED6[2];  // @26
	__IO uint16_t I2SCFGR;      // @28 I2S configuration register
	uint8_t       RESERVED7[2]; // @30
	__IO uint16_t I2SPR;        // @32 I2S prescaler register
};

// I2S2ext->CR1 control register 1
enum {
	I2S2EXT_CR1_BIDIMODE = 1UL << 15,             // Bidirectional data mode enable
	I2S2EXT_CR1_BIDIOE   = 1UL << 14,             // Output enable in bidirectional mode
	I2S2EXT_CR1_CRCEN    = 1UL << 13,             // Hardware CRC calculation enable
	I2S2EXT_CR1_CRCNEXT  = 1UL << 12,             // CRC transfer next
	I2S2EXT_CR1_DFF      = 1UL << 11,             // Data frame format
	I2S2EXT_CR1_RXONLY   = 1UL << 10,             // Receive only
	I2S2EXT_CR1_SSM      = 1UL << 9,              // Software slave management
	I2S2EXT_CR1_SSI      = 1UL << 8,              // Internal slave select
	I2S2EXT_CR1_LSBFIRST = 1UL << 7,              // Frame format
	I2S2EXT_CR1_SPE      = 1UL << 6,              // SPI enable
	I2S2EXT_CR1_BR       = ((1UL << 3) - 1) << 3, // Baud rate control
	I2S2EXT_CR1_MSTR     = 1UL << 2,              // Master selection
	I2S2EXT_CR1_CPOL     = 1UL << 1,              // Clock polarity
	I2S2EXT_CR1_CPHA     = 1UL << 0,              // Clock phase
};
inline void i2s2ext_cr1_set_br(struct I2S2ext_Type* p, uint32_t val) {
	p->CR1 = (p->CR1 & ~I2S2EXT_CR1_BR) | ((val << 3) & I2S2EXT_CR1_BR);
}
inline uint32_t i2s2ext_cr1_get_br(struct I2S2ext_Type* p) { return (p->CR1 & I2S2EXT_CR1_BR) >> 3; }

// I2S2ext->CR2 control register 2
enum {
	I2S2EXT_CR2_TXEIE   = 1UL << 7, // Tx buffer empty interrupt enable
	I2S2EXT_CR2_RXNEIE  = 1UL << 6, // RX buffer not empty interrupt enable
	I2S2EXT_CR2_ERRIE   = 1UL << 5, // Error interrupt enable
	I2S2EXT_CR2_FRF     = 1UL << 4, // Frame format
	I2S2EXT_CR2_SSOE    = 1UL << 2, // SS output enable
	I2S2EXT_CR2_TXDMAEN = 1UL << 1, // Tx buffer DMA enable
	I2S2EXT_CR2_RXDMAEN = 1UL << 0, // Rx buffer DMA enable
};

// I2S2ext->SR status register
enum {
	I2S2EXT_SR_TIFRFE = 1UL << 8, // TI frame format error
	I2S2EXT_SR_BSY    = 1UL << 7, // Busy flag
	I2S2EXT_SR_OVR    = 1UL << 6, // Overrun flag
	I2S2EXT_SR_MODF   = 1UL << 5, // Mode fault
	I2S2EXT_SR_CRCERR = 1UL << 4, // CRC error flag
	I2S2EXT_SR_UDR    = 1UL << 3, // Underrun flag
	I2S2EXT_SR_CHSIDE = 1UL << 2, // Channel side
	I2S2EXT_SR_TXE    = 1UL << 1, // Transmit buffer empty
	I2S2EXT_SR_RXNE   = 1UL << 0, // Receive buffer not empty
};

// I2S2ext->I2SCFGR I2S configuration register
enum {
	I2S2EXT_I2SCFGR_I2SMOD  = 1UL << 11,             // I2S mode selection
	I2S2EXT_I2SCFGR_I2SE    = 1UL << 10,             // I2S Enable
	I2S2EXT_I2SCFGR_I2SCFG  = ((1UL << 2) - 1) << 8, // I2S configuration mode
	I2S2EXT_I2SCFGR_PCMSYNC = 1UL << 7,              // PCM frame synchronization
	I2S2EXT_I2SCFGR_I2SSTD  = ((1UL << 2) - 1) << 4, // I2S standard selection
	I2S2EXT_I2SCFGR_CKPOL   = 1UL << 3,              // Steady state clock polarity
	I2S2EXT_I2SCFGR_DATLEN  = ((1UL << 2) - 1) << 1, // Data length to be transferred
	I2S2EXT_I2SCFGR_CHLEN   = 1UL << 0,              // Channel length (number of bits per audio channel)
};
inline void i2s2ext_i2scfgr_set_i2scfg(struct I2S2ext_Type* p, uint32_t val) {
	p->I2SCFGR = (p->I2SCFGR & ~I2S2EXT_I2SCFGR_I2SCFG) | ((val << 8) & I2S2EXT_I2SCFGR_I2SCFG);
}
inline void i2s2ext_i2scfgr_set_i2sstd(struct I2S2ext_Type* p, uint32_t val) {
	p->I2SCFGR = (p->I2SCFGR & ~I2S2EXT_I2SCFGR_I2SSTD) | ((val << 4) & I2S2EXT_I2SCFGR_I2SSTD);
}
inline void i2s2ext_i2scfgr_set_datlen(struct I2S2ext_Type* p, uint32_t val) {
	p->I2SCFGR = (p->I2SCFGR & ~I2S2EXT_I2SCFGR_DATLEN) | ((val << 1) & I2S2EXT_I2SCFGR_DATLEN);
}
inline uint32_t i2s2ext_i2scfgr_get_i2scfg(struct I2S2ext_Type* p) { return (p->I2SCFGR & I2S2EXT_I2SCFGR_I2SCFG) >> 8; }
inline uint32_t i2s2ext_i2scfgr_get_i2sstd(struct I2S2ext_Type* p) { return (p->I2SCFGR & I2S2EXT_I2SCFGR_I2SSTD) >> 4; }
inline uint32_t i2s2ext_i2scfgr_get_datlen(struct I2S2ext_Type* p) { return (p->I2SCFGR & I2S2EXT_I2SCFGR_DATLEN) >> 1; }

// I2S2ext->I2SPR I2S prescaler register
enum {
	I2S2EXT_I2SPR_MCKOE  = 1UL << 9,              // Master clock output enable
	I2S2EXT_I2SPR_ODD    = 1UL << 8,              // Odd factor for the prescaler
	I2S2EXT_I2SPR_I2SDIV = ((1UL << 8) - 1) << 0, // I2S Linear prescaler
};
inline void i2s2ext_i2spr_set_i2sdiv(struct I2S2ext_Type* p, uint32_t val) {
	p->I2SPR = (p->I2SPR & ~I2S2EXT_I2SPR_I2SDIV) | ((val << 0) & I2S2EXT_I2SPR_I2SDIV);
}
inline uint32_t i2s2ext_i2spr_get_i2sdiv(struct I2S2ext_Type* p) { return (p->I2SPR & I2S2EXT_I2SPR_I2SDIV) >> 0; }

/* Independent watchdog */
struct IWDG_Type {
	__O uint16_t KR;            // @0 Key register
	uint8_t      RESERVED0[2];  // @2
	__IO uint8_t PR;            // @4 Prescaler register
	uint8_t      RESERVED1[3];  // @5
	__IO uint16_t RLR;          // @8 Reload register
	uint8_t       RESERVED2[2]; // @10
	__I uint8_t SR;             // @12 Status register
};

// IWDG->PR Prescaler register
enum {
	IWDG_PR_PR = ((1UL << 3) - 1) << 0, // Prescaler divider
};
inline void     iwdg_pr_set_pr(struct IWDG_Type* p, uint32_t val) { p->PR = (p->PR & ~IWDG_PR_PR) | ((val << 0) & IWDG_PR_PR); }
inline uint32_t iwdg_pr_get_pr(struct IWDG_Type* p) { return (p->PR & IWDG_PR_PR) >> 0; }

// IWDG->RLR Reload register
enum {
	IWDG_RLR_RL = ((1UL << 12) - 1) << 0, // Watchdog counter reload value
};
inline void     iwdg_rlr_set_rl(struct IWDG_Type* p, uint32_t val) { p->RLR = (p->RLR & ~IWDG_RLR_RL) | ((val << 0) & IWDG_RLR_RL); }
inline uint32_t iwdg_rlr_get_rl(struct IWDG_Type* p) { return (p->RLR & IWDG_RLR_RL) >> 0; }

// IWDG->SR Status register
enum {
	IWDG_SR_RVU = 1UL << 1, // Watchdog counter reload value update
	IWDG_SR_PVU = 1UL << 0, // Watchdog prescaler value update
};

/* Memory protection unit */
struct MPU_Type {
	__I uint32_t MPU_TYPER;    // @0 MPU type register
	__I uint8_t MPU_CTRL;      // @4 MPU control register
	uint8_t     RESERVED0[3];  // @5
	__IO uint8_t MPU_RNR;      // @8 MPU region number register
	uint8_t      RESERVED1[3]; // @9
	__IO uint32_t MPU_RBAR;    // @12 MPU region base address register
	__IO uint32_t MPU_RASR;    // @16 MPU region attribute and size register
};

// MPU->MPU_TYPER MPU type register
enum {
	MPU_MPU_TYPER_IREGION  = ((1UL << 8) - 1) << 16, // Number of MPU instruction regions
	MPU_MPU_TYPER_DREGION  = ((1UL << 8) - 1) << 8,  // Number of MPU data regions
	MPU_MPU_TYPER_SEPARATE = 1UL << 0,               // Separate flag
};
inline uint32_t mpu_mpu_typer_get_iregion(struct MPU_Type* p) { return (p->MPU_TYPER & MPU_MPU_TYPER_IREGION) >> 16; }
inline uint32_t mpu_mpu_typer_get_dregion(struct MPU_Type* p) { return (p->MPU_TYPER & MPU_MPU_TYPER_DREGION) >> 8; }

// MPU->MPU_CTRL MPU control register
enum {
	MPU_MPU_CTRL_PRIVDEFENA = 1UL << 2, // Enable priviliged software access to default memory map
	MPU_MPU_CTRL_HFNMIENA   = 1UL << 1, // Enables the operation of MPU during hard fault
	MPU_MPU_CTRL_ENABLE     = 1UL << 0, // Enables the MPU
};

// MPU->MPU_RBAR MPU region base address register
enum {
	MPU_MPU_RBAR_ADDR   = ((1UL << 27) - 1) << 5, // Region base address field
	MPU_MPU_RBAR_VALID  = 1UL << 4,               // MPU region number valid
	MPU_MPU_RBAR_REGION = ((1UL << 4) - 1) << 0,  // MPU region field
};
inline void mpu_mpu_rbar_set_addr(struct MPU_Type* p, uint32_t val) {
	p->MPU_RBAR = (p->MPU_RBAR & ~MPU_MPU_RBAR_ADDR) | ((val << 5) & MPU_MPU_RBAR_ADDR);
}
inline void mpu_mpu_rbar_set_region(struct MPU_Type* p, uint32_t val) {
	p->MPU_RBAR = (p->MPU_RBAR & ~MPU_MPU_RBAR_REGION) | ((val << 0) & MPU_MPU_RBAR_REGION);
}
inline uint32_t mpu_mpu_rbar_get_addr(struct MPU_Type* p) { return (p->MPU_RBAR & MPU_MPU_RBAR_ADDR) >> 5; }
inline uint32_t mpu_mpu_rbar_get_region(struct MPU_Type* p) { return (p->MPU_RBAR & MPU_MPU_RBAR_REGION) >> 0; }

// MPU->MPU_RASR MPU region attribute and size register
enum {
	MPU_MPU_RASR_XN     = 1UL << 28,              // Instruction access disable bit
	MPU_MPU_RASR_AP     = ((1UL << 3) - 1) << 24, // Access permission
	MPU_MPU_RASR_TEX    = ((1UL << 3) - 1) << 19, // memory attribute
	MPU_MPU_RASR_S      = 1UL << 18,              // Shareable memory attribute
	MPU_MPU_RASR_C      = 1UL << 17,              // memory attribute
	MPU_MPU_RASR_B      = 1UL << 16,              // memory attribute
	MPU_MPU_RASR_SRD    = ((1UL << 8) - 1) << 8,  // Subregion disable bits
	MPU_MPU_RASR_SIZE   = ((1UL << 5) - 1) << 1,  // Size of the MPU protection region
	MPU_MPU_RASR_ENABLE = 1UL << 0,               // Region enable bit.
};
inline void mpu_mpu_rasr_set_ap(struct MPU_Type* p, uint32_t val) {
	p->MPU_RASR = (p->MPU_RASR & ~MPU_MPU_RASR_AP) | ((val << 24) & MPU_MPU_RASR_AP);
}
inline void mpu_mpu_rasr_set_tex(struct MPU_Type* p, uint32_t val) {
	p->MPU_RASR = (p->MPU_RASR & ~MPU_MPU_RASR_TEX) | ((val << 19) & MPU_MPU_RASR_TEX);
}
inline void mpu_mpu_rasr_set_srd(struct MPU_Type* p, uint32_t val) {
	p->MPU_RASR = (p->MPU_RASR & ~MPU_MPU_RASR_SRD) | ((val << 8) & MPU_MPU_RASR_SRD);
}
inline void mpu_mpu_rasr_set_size(struct MPU_Type* p, uint32_t val) {
	p->MPU_RASR = (p->MPU_RASR & ~MPU_MPU_RASR_SIZE) | ((val << 1) & MPU_MPU_RASR_SIZE);
}
inline uint32_t mpu_mpu_rasr_get_ap(struct MPU_Type* p) { return (p->MPU_RASR & MPU_MPU_RASR_AP) >> 24; }
inline uint32_t mpu_mpu_rasr_get_tex(struct MPU_Type* p) { return (p->MPU_RASR & MPU_MPU_RASR_TEX) >> 19; }
inline uint32_t mpu_mpu_rasr_get_srd(struct MPU_Type* p) { return (p->MPU_RASR & MPU_MPU_RASR_SRD) >> 8; }
inline uint32_t mpu_mpu_rasr_get_size(struct MPU_Type* p) { return (p->MPU_RASR & MPU_MPU_RASR_SIZE) >> 1; }

/* Nested Vectored Interrupt Controller */
struct NVIC_Type {
	__IO uint32_t ISER0;          // @0 Interrupt Set-Enable Register
	__IO uint32_t ISER1;          // @4 Interrupt Set-Enable Register
	__IO uint32_t ISER2;          // @8 Interrupt Set-Enable Register
	uint8_t       RESERVED0[116]; // @12
	__IO uint32_t ICER0;          // @128 Interrupt Clear-Enable Register
	__IO uint32_t ICER1;          // @132 Interrupt Clear-Enable Register
	__IO uint32_t ICER2;          // @136 Interrupt Clear-Enable Register
	uint8_t       RESERVED1[116]; // @140
	__IO uint32_t ISPR0;          // @256 Interrupt Set-Pending Register
	__IO uint32_t ISPR1;          // @260 Interrupt Set-Pending Register
	__IO uint32_t ISPR2;          // @264 Interrupt Set-Pending Register
	uint8_t       RESERVED2[116]; // @268
	__IO uint32_t ICPR0;          // @384 Interrupt Clear-Pending Register
	__IO uint32_t ICPR1;          // @388 Interrupt Clear-Pending Register
	__IO uint32_t ICPR2;          // @392 Interrupt Clear-Pending Register
	uint8_t       RESERVED3[116]; // @396
	__I uint32_t IABR0;           // @512 Interrupt Active Bit Register
	__I uint32_t IABR1;           // @516 Interrupt Active Bit Register
	__I uint32_t IABR2;           // @520 Interrupt Active Bit Register
	uint8_t      RESERVED4[244];  // @524
	__IO uint32_t IPR0;           // @768 Interrupt Priority Register
	__IO uint32_t IPR1;           // @772 Interrupt Priority Register
	__IO uint32_t IPR2;           // @776 Interrupt Priority Register
	__IO uint32_t IPR3;           // @780 Interrupt Priority Register
	__IO uint32_t IPR4;           // @784 Interrupt Priority Register
	__IO uint32_t IPR5;           // @788 Interrupt Priority Register
	__IO uint32_t IPR6;           // @792 Interrupt Priority Register
	__IO uint32_t IPR7;           // @796 Interrupt Priority Register
	__IO uint32_t IPR8;           // @800 Interrupt Priority Register
	__IO uint32_t IPR9;           // @804 Interrupt Priority Register
	__IO uint32_t IPR10;          // @808 Interrupt Priority Register
	__IO uint32_t IPR11;          // @812 Interrupt Priority Register
	__IO uint32_t IPR12;          // @816 Interrupt Priority Register
	__IO uint32_t IPR13;          // @820 Interrupt Priority Register
	__IO uint32_t IPR14;          // @824 Interrupt Priority Register
	__IO uint32_t IPR15;          // @828 Interrupt Priority Register
	__IO uint32_t IPR16;          // @832 Interrupt Priority Register
	__IO uint32_t IPR17;          // @836 Interrupt Priority Register
	__IO uint32_t IPR18;          // @840 Interrupt Priority Register
	__IO uint32_t IPR19;          // @844 Interrupt Priority Register
};

// NVIC->IPR0 Interrupt Priority Register
enum {
	NVIC_IPR0_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR0_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR0_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR0_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr0_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR0 = (p->IPR0 & ~NVIC_IPR0_IPR_N3) | ((val << 24) & NVIC_IPR0_IPR_N3);
}
inline void nvic_ipr0_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR0 = (p->IPR0 & ~NVIC_IPR0_IPR_N2) | ((val << 16) & NVIC_IPR0_IPR_N2);
}
inline void nvic_ipr0_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR0 = (p->IPR0 & ~NVIC_IPR0_IPR_N1) | ((val << 8) & NVIC_IPR0_IPR_N1);
}
inline void nvic_ipr0_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR0 = (p->IPR0 & ~NVIC_IPR0_IPR_N0) | ((val << 0) & NVIC_IPR0_IPR_N0);
}
inline uint32_t nvic_ipr0_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR0 & NVIC_IPR0_IPR_N3) >> 24; }
inline uint32_t nvic_ipr0_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR0 & NVIC_IPR0_IPR_N2) >> 16; }
inline uint32_t nvic_ipr0_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR0 & NVIC_IPR0_IPR_N1) >> 8; }
inline uint32_t nvic_ipr0_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR0 & NVIC_IPR0_IPR_N0) >> 0; }

// NVIC->IPR1 Interrupt Priority Register
enum {
	NVIC_IPR1_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR1_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR1_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR1_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr1_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR1 = (p->IPR1 & ~NVIC_IPR1_IPR_N3) | ((val << 24) & NVIC_IPR1_IPR_N3);
}
inline void nvic_ipr1_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR1 = (p->IPR1 & ~NVIC_IPR1_IPR_N2) | ((val << 16) & NVIC_IPR1_IPR_N2);
}
inline void nvic_ipr1_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR1 = (p->IPR1 & ~NVIC_IPR1_IPR_N1) | ((val << 8) & NVIC_IPR1_IPR_N1);
}
inline void nvic_ipr1_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR1 = (p->IPR1 & ~NVIC_IPR1_IPR_N0) | ((val << 0) & NVIC_IPR1_IPR_N0);
}
inline uint32_t nvic_ipr1_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR1 & NVIC_IPR1_IPR_N3) >> 24; }
inline uint32_t nvic_ipr1_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR1 & NVIC_IPR1_IPR_N2) >> 16; }
inline uint32_t nvic_ipr1_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR1 & NVIC_IPR1_IPR_N1) >> 8; }
inline uint32_t nvic_ipr1_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR1 & NVIC_IPR1_IPR_N0) >> 0; }

// NVIC->IPR2 Interrupt Priority Register
enum {
	NVIC_IPR2_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR2_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR2_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR2_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr2_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR2 = (p->IPR2 & ~NVIC_IPR2_IPR_N3) | ((val << 24) & NVIC_IPR2_IPR_N3);
}
inline void nvic_ipr2_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR2 = (p->IPR2 & ~NVIC_IPR2_IPR_N2) | ((val << 16) & NVIC_IPR2_IPR_N2);
}
inline void nvic_ipr2_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR2 = (p->IPR2 & ~NVIC_IPR2_IPR_N1) | ((val << 8) & NVIC_IPR2_IPR_N1);
}
inline void nvic_ipr2_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR2 = (p->IPR2 & ~NVIC_IPR2_IPR_N0) | ((val << 0) & NVIC_IPR2_IPR_N0);
}
inline uint32_t nvic_ipr2_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR2 & NVIC_IPR2_IPR_N3) >> 24; }
inline uint32_t nvic_ipr2_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR2 & NVIC_IPR2_IPR_N2) >> 16; }
inline uint32_t nvic_ipr2_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR2 & NVIC_IPR2_IPR_N1) >> 8; }
inline uint32_t nvic_ipr2_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR2 & NVIC_IPR2_IPR_N0) >> 0; }

// NVIC->IPR3 Interrupt Priority Register
enum {
	NVIC_IPR3_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR3_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR3_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR3_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr3_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR3 = (p->IPR3 & ~NVIC_IPR3_IPR_N3) | ((val << 24) & NVIC_IPR3_IPR_N3);
}
inline void nvic_ipr3_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR3 = (p->IPR3 & ~NVIC_IPR3_IPR_N2) | ((val << 16) & NVIC_IPR3_IPR_N2);
}
inline void nvic_ipr3_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR3 = (p->IPR3 & ~NVIC_IPR3_IPR_N1) | ((val << 8) & NVIC_IPR3_IPR_N1);
}
inline void nvic_ipr3_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR3 = (p->IPR3 & ~NVIC_IPR3_IPR_N0) | ((val << 0) & NVIC_IPR3_IPR_N0);
}
inline uint32_t nvic_ipr3_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR3 & NVIC_IPR3_IPR_N3) >> 24; }
inline uint32_t nvic_ipr3_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR3 & NVIC_IPR3_IPR_N2) >> 16; }
inline uint32_t nvic_ipr3_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR3 & NVIC_IPR3_IPR_N1) >> 8; }
inline uint32_t nvic_ipr3_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR3 & NVIC_IPR3_IPR_N0) >> 0; }

// NVIC->IPR4 Interrupt Priority Register
enum {
	NVIC_IPR4_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR4_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR4_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR4_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr4_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR4 = (p->IPR4 & ~NVIC_IPR4_IPR_N3) | ((val << 24) & NVIC_IPR4_IPR_N3);
}
inline void nvic_ipr4_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR4 = (p->IPR4 & ~NVIC_IPR4_IPR_N2) | ((val << 16) & NVIC_IPR4_IPR_N2);
}
inline void nvic_ipr4_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR4 = (p->IPR4 & ~NVIC_IPR4_IPR_N1) | ((val << 8) & NVIC_IPR4_IPR_N1);
}
inline void nvic_ipr4_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR4 = (p->IPR4 & ~NVIC_IPR4_IPR_N0) | ((val << 0) & NVIC_IPR4_IPR_N0);
}
inline uint32_t nvic_ipr4_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR4 & NVIC_IPR4_IPR_N3) >> 24; }
inline uint32_t nvic_ipr4_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR4 & NVIC_IPR4_IPR_N2) >> 16; }
inline uint32_t nvic_ipr4_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR4 & NVIC_IPR4_IPR_N1) >> 8; }
inline uint32_t nvic_ipr4_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR4 & NVIC_IPR4_IPR_N0) >> 0; }

// NVIC->IPR5 Interrupt Priority Register
enum {
	NVIC_IPR5_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR5_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR5_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR5_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr5_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR5 = (p->IPR5 & ~NVIC_IPR5_IPR_N3) | ((val << 24) & NVIC_IPR5_IPR_N3);
}
inline void nvic_ipr5_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR5 = (p->IPR5 & ~NVIC_IPR5_IPR_N2) | ((val << 16) & NVIC_IPR5_IPR_N2);
}
inline void nvic_ipr5_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR5 = (p->IPR5 & ~NVIC_IPR5_IPR_N1) | ((val << 8) & NVIC_IPR5_IPR_N1);
}
inline void nvic_ipr5_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR5 = (p->IPR5 & ~NVIC_IPR5_IPR_N0) | ((val << 0) & NVIC_IPR5_IPR_N0);
}
inline uint32_t nvic_ipr5_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR5 & NVIC_IPR5_IPR_N3) >> 24; }
inline uint32_t nvic_ipr5_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR5 & NVIC_IPR5_IPR_N2) >> 16; }
inline uint32_t nvic_ipr5_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR5 & NVIC_IPR5_IPR_N1) >> 8; }
inline uint32_t nvic_ipr5_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR5 & NVIC_IPR5_IPR_N0) >> 0; }

// NVIC->IPR6 Interrupt Priority Register
enum {
	NVIC_IPR6_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR6_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR6_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR6_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr6_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR6 = (p->IPR6 & ~NVIC_IPR6_IPR_N3) | ((val << 24) & NVIC_IPR6_IPR_N3);
}
inline void nvic_ipr6_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR6 = (p->IPR6 & ~NVIC_IPR6_IPR_N2) | ((val << 16) & NVIC_IPR6_IPR_N2);
}
inline void nvic_ipr6_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR6 = (p->IPR6 & ~NVIC_IPR6_IPR_N1) | ((val << 8) & NVIC_IPR6_IPR_N1);
}
inline void nvic_ipr6_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR6 = (p->IPR6 & ~NVIC_IPR6_IPR_N0) | ((val << 0) & NVIC_IPR6_IPR_N0);
}
inline uint32_t nvic_ipr6_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR6 & NVIC_IPR6_IPR_N3) >> 24; }
inline uint32_t nvic_ipr6_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR6 & NVIC_IPR6_IPR_N2) >> 16; }
inline uint32_t nvic_ipr6_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR6 & NVIC_IPR6_IPR_N1) >> 8; }
inline uint32_t nvic_ipr6_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR6 & NVIC_IPR6_IPR_N0) >> 0; }

// NVIC->IPR7 Interrupt Priority Register
enum {
	NVIC_IPR7_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR7_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR7_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR7_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr7_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR7 = (p->IPR7 & ~NVIC_IPR7_IPR_N3) | ((val << 24) & NVIC_IPR7_IPR_N3);
}
inline void nvic_ipr7_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR7 = (p->IPR7 & ~NVIC_IPR7_IPR_N2) | ((val << 16) & NVIC_IPR7_IPR_N2);
}
inline void nvic_ipr7_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR7 = (p->IPR7 & ~NVIC_IPR7_IPR_N1) | ((val << 8) & NVIC_IPR7_IPR_N1);
}
inline void nvic_ipr7_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR7 = (p->IPR7 & ~NVIC_IPR7_IPR_N0) | ((val << 0) & NVIC_IPR7_IPR_N0);
}
inline uint32_t nvic_ipr7_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR7 & NVIC_IPR7_IPR_N3) >> 24; }
inline uint32_t nvic_ipr7_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR7 & NVIC_IPR7_IPR_N2) >> 16; }
inline uint32_t nvic_ipr7_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR7 & NVIC_IPR7_IPR_N1) >> 8; }
inline uint32_t nvic_ipr7_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR7 & NVIC_IPR7_IPR_N0) >> 0; }

// NVIC->IPR8 Interrupt Priority Register
enum {
	NVIC_IPR8_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR8_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR8_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR8_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr8_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR8 = (p->IPR8 & ~NVIC_IPR8_IPR_N3) | ((val << 24) & NVIC_IPR8_IPR_N3);
}
inline void nvic_ipr8_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR8 = (p->IPR8 & ~NVIC_IPR8_IPR_N2) | ((val << 16) & NVIC_IPR8_IPR_N2);
}
inline void nvic_ipr8_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR8 = (p->IPR8 & ~NVIC_IPR8_IPR_N1) | ((val << 8) & NVIC_IPR8_IPR_N1);
}
inline void nvic_ipr8_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR8 = (p->IPR8 & ~NVIC_IPR8_IPR_N0) | ((val << 0) & NVIC_IPR8_IPR_N0);
}
inline uint32_t nvic_ipr8_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR8 & NVIC_IPR8_IPR_N3) >> 24; }
inline uint32_t nvic_ipr8_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR8 & NVIC_IPR8_IPR_N2) >> 16; }
inline uint32_t nvic_ipr8_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR8 & NVIC_IPR8_IPR_N1) >> 8; }
inline uint32_t nvic_ipr8_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR8 & NVIC_IPR8_IPR_N0) >> 0; }

// NVIC->IPR9 Interrupt Priority Register
enum {
	NVIC_IPR9_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR9_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR9_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR9_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr9_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR9 = (p->IPR9 & ~NVIC_IPR9_IPR_N3) | ((val << 24) & NVIC_IPR9_IPR_N3);
}
inline void nvic_ipr9_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR9 = (p->IPR9 & ~NVIC_IPR9_IPR_N2) | ((val << 16) & NVIC_IPR9_IPR_N2);
}
inline void nvic_ipr9_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR9 = (p->IPR9 & ~NVIC_IPR9_IPR_N1) | ((val << 8) & NVIC_IPR9_IPR_N1);
}
inline void nvic_ipr9_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR9 = (p->IPR9 & ~NVIC_IPR9_IPR_N0) | ((val << 0) & NVIC_IPR9_IPR_N0);
}
inline uint32_t nvic_ipr9_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR9 & NVIC_IPR9_IPR_N3) >> 24; }
inline uint32_t nvic_ipr9_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR9 & NVIC_IPR9_IPR_N2) >> 16; }
inline uint32_t nvic_ipr9_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR9 & NVIC_IPR9_IPR_N1) >> 8; }
inline uint32_t nvic_ipr9_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR9 & NVIC_IPR9_IPR_N0) >> 0; }

// NVIC->IPR10 Interrupt Priority Register
enum {
	NVIC_IPR10_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR10_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR10_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR10_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr10_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR10 = (p->IPR10 & ~NVIC_IPR10_IPR_N3) | ((val << 24) & NVIC_IPR10_IPR_N3);
}
inline void nvic_ipr10_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR10 = (p->IPR10 & ~NVIC_IPR10_IPR_N2) | ((val << 16) & NVIC_IPR10_IPR_N2);
}
inline void nvic_ipr10_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR10 = (p->IPR10 & ~NVIC_IPR10_IPR_N1) | ((val << 8) & NVIC_IPR10_IPR_N1);
}
inline void nvic_ipr10_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR10 = (p->IPR10 & ~NVIC_IPR10_IPR_N0) | ((val << 0) & NVIC_IPR10_IPR_N0);
}
inline uint32_t nvic_ipr10_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR10 & NVIC_IPR10_IPR_N3) >> 24; }
inline uint32_t nvic_ipr10_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR10 & NVIC_IPR10_IPR_N2) >> 16; }
inline uint32_t nvic_ipr10_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR10 & NVIC_IPR10_IPR_N1) >> 8; }
inline uint32_t nvic_ipr10_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR10 & NVIC_IPR10_IPR_N0) >> 0; }

// NVIC->IPR11 Interrupt Priority Register
enum {
	NVIC_IPR11_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR11_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR11_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR11_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr11_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR11 = (p->IPR11 & ~NVIC_IPR11_IPR_N3) | ((val << 24) & NVIC_IPR11_IPR_N3);
}
inline void nvic_ipr11_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR11 = (p->IPR11 & ~NVIC_IPR11_IPR_N2) | ((val << 16) & NVIC_IPR11_IPR_N2);
}
inline void nvic_ipr11_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR11 = (p->IPR11 & ~NVIC_IPR11_IPR_N1) | ((val << 8) & NVIC_IPR11_IPR_N1);
}
inline void nvic_ipr11_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR11 = (p->IPR11 & ~NVIC_IPR11_IPR_N0) | ((val << 0) & NVIC_IPR11_IPR_N0);
}
inline uint32_t nvic_ipr11_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR11 & NVIC_IPR11_IPR_N3) >> 24; }
inline uint32_t nvic_ipr11_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR11 & NVIC_IPR11_IPR_N2) >> 16; }
inline uint32_t nvic_ipr11_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR11 & NVIC_IPR11_IPR_N1) >> 8; }
inline uint32_t nvic_ipr11_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR11 & NVIC_IPR11_IPR_N0) >> 0; }

// NVIC->IPR12 Interrupt Priority Register
enum {
	NVIC_IPR12_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR12_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR12_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR12_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr12_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR12 = (p->IPR12 & ~NVIC_IPR12_IPR_N3) | ((val << 24) & NVIC_IPR12_IPR_N3);
}
inline void nvic_ipr12_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR12 = (p->IPR12 & ~NVIC_IPR12_IPR_N2) | ((val << 16) & NVIC_IPR12_IPR_N2);
}
inline void nvic_ipr12_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR12 = (p->IPR12 & ~NVIC_IPR12_IPR_N1) | ((val << 8) & NVIC_IPR12_IPR_N1);
}
inline void nvic_ipr12_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR12 = (p->IPR12 & ~NVIC_IPR12_IPR_N0) | ((val << 0) & NVIC_IPR12_IPR_N0);
}
inline uint32_t nvic_ipr12_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR12 & NVIC_IPR12_IPR_N3) >> 24; }
inline uint32_t nvic_ipr12_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR12 & NVIC_IPR12_IPR_N2) >> 16; }
inline uint32_t nvic_ipr12_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR12 & NVIC_IPR12_IPR_N1) >> 8; }
inline uint32_t nvic_ipr12_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR12 & NVIC_IPR12_IPR_N0) >> 0; }

// NVIC->IPR13 Interrupt Priority Register
enum {
	NVIC_IPR13_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR13_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR13_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR13_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr13_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR13 = (p->IPR13 & ~NVIC_IPR13_IPR_N3) | ((val << 24) & NVIC_IPR13_IPR_N3);
}
inline void nvic_ipr13_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR13 = (p->IPR13 & ~NVIC_IPR13_IPR_N2) | ((val << 16) & NVIC_IPR13_IPR_N2);
}
inline void nvic_ipr13_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR13 = (p->IPR13 & ~NVIC_IPR13_IPR_N1) | ((val << 8) & NVIC_IPR13_IPR_N1);
}
inline void nvic_ipr13_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR13 = (p->IPR13 & ~NVIC_IPR13_IPR_N0) | ((val << 0) & NVIC_IPR13_IPR_N0);
}
inline uint32_t nvic_ipr13_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR13 & NVIC_IPR13_IPR_N3) >> 24; }
inline uint32_t nvic_ipr13_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR13 & NVIC_IPR13_IPR_N2) >> 16; }
inline uint32_t nvic_ipr13_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR13 & NVIC_IPR13_IPR_N1) >> 8; }
inline uint32_t nvic_ipr13_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR13 & NVIC_IPR13_IPR_N0) >> 0; }

// NVIC->IPR14 Interrupt Priority Register
enum {
	NVIC_IPR14_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR14_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR14_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR14_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr14_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR14 = (p->IPR14 & ~NVIC_IPR14_IPR_N3) | ((val << 24) & NVIC_IPR14_IPR_N3);
}
inline void nvic_ipr14_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR14 = (p->IPR14 & ~NVIC_IPR14_IPR_N2) | ((val << 16) & NVIC_IPR14_IPR_N2);
}
inline void nvic_ipr14_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR14 = (p->IPR14 & ~NVIC_IPR14_IPR_N1) | ((val << 8) & NVIC_IPR14_IPR_N1);
}
inline void nvic_ipr14_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR14 = (p->IPR14 & ~NVIC_IPR14_IPR_N0) | ((val << 0) & NVIC_IPR14_IPR_N0);
}
inline uint32_t nvic_ipr14_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR14 & NVIC_IPR14_IPR_N3) >> 24; }
inline uint32_t nvic_ipr14_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR14 & NVIC_IPR14_IPR_N2) >> 16; }
inline uint32_t nvic_ipr14_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR14 & NVIC_IPR14_IPR_N1) >> 8; }
inline uint32_t nvic_ipr14_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR14 & NVIC_IPR14_IPR_N0) >> 0; }

// NVIC->IPR15 Interrupt Priority Register
enum {
	NVIC_IPR15_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR15_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR15_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR15_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr15_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR15 = (p->IPR15 & ~NVIC_IPR15_IPR_N3) | ((val << 24) & NVIC_IPR15_IPR_N3);
}
inline void nvic_ipr15_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR15 = (p->IPR15 & ~NVIC_IPR15_IPR_N2) | ((val << 16) & NVIC_IPR15_IPR_N2);
}
inline void nvic_ipr15_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR15 = (p->IPR15 & ~NVIC_IPR15_IPR_N1) | ((val << 8) & NVIC_IPR15_IPR_N1);
}
inline void nvic_ipr15_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR15 = (p->IPR15 & ~NVIC_IPR15_IPR_N0) | ((val << 0) & NVIC_IPR15_IPR_N0);
}
inline uint32_t nvic_ipr15_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR15 & NVIC_IPR15_IPR_N3) >> 24; }
inline uint32_t nvic_ipr15_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR15 & NVIC_IPR15_IPR_N2) >> 16; }
inline uint32_t nvic_ipr15_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR15 & NVIC_IPR15_IPR_N1) >> 8; }
inline uint32_t nvic_ipr15_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR15 & NVIC_IPR15_IPR_N0) >> 0; }

// NVIC->IPR16 Interrupt Priority Register
enum {
	NVIC_IPR16_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR16_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR16_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR16_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr16_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR16 = (p->IPR16 & ~NVIC_IPR16_IPR_N3) | ((val << 24) & NVIC_IPR16_IPR_N3);
}
inline void nvic_ipr16_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR16 = (p->IPR16 & ~NVIC_IPR16_IPR_N2) | ((val << 16) & NVIC_IPR16_IPR_N2);
}
inline void nvic_ipr16_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR16 = (p->IPR16 & ~NVIC_IPR16_IPR_N1) | ((val << 8) & NVIC_IPR16_IPR_N1);
}
inline void nvic_ipr16_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR16 = (p->IPR16 & ~NVIC_IPR16_IPR_N0) | ((val << 0) & NVIC_IPR16_IPR_N0);
}
inline uint32_t nvic_ipr16_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR16 & NVIC_IPR16_IPR_N3) >> 24; }
inline uint32_t nvic_ipr16_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR16 & NVIC_IPR16_IPR_N2) >> 16; }
inline uint32_t nvic_ipr16_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR16 & NVIC_IPR16_IPR_N1) >> 8; }
inline uint32_t nvic_ipr16_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR16 & NVIC_IPR16_IPR_N0) >> 0; }

// NVIC->IPR17 Interrupt Priority Register
enum {
	NVIC_IPR17_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR17_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR17_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR17_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr17_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR17 = (p->IPR17 & ~NVIC_IPR17_IPR_N3) | ((val << 24) & NVIC_IPR17_IPR_N3);
}
inline void nvic_ipr17_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR17 = (p->IPR17 & ~NVIC_IPR17_IPR_N2) | ((val << 16) & NVIC_IPR17_IPR_N2);
}
inline void nvic_ipr17_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR17 = (p->IPR17 & ~NVIC_IPR17_IPR_N1) | ((val << 8) & NVIC_IPR17_IPR_N1);
}
inline void nvic_ipr17_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR17 = (p->IPR17 & ~NVIC_IPR17_IPR_N0) | ((val << 0) & NVIC_IPR17_IPR_N0);
}
inline uint32_t nvic_ipr17_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR17 & NVIC_IPR17_IPR_N3) >> 24; }
inline uint32_t nvic_ipr17_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR17 & NVIC_IPR17_IPR_N2) >> 16; }
inline uint32_t nvic_ipr17_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR17 & NVIC_IPR17_IPR_N1) >> 8; }
inline uint32_t nvic_ipr17_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR17 & NVIC_IPR17_IPR_N0) >> 0; }

// NVIC->IPR18 Interrupt Priority Register
enum {
	NVIC_IPR18_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR18_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR18_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR18_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr18_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR18 = (p->IPR18 & ~NVIC_IPR18_IPR_N3) | ((val << 24) & NVIC_IPR18_IPR_N3);
}
inline void nvic_ipr18_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR18 = (p->IPR18 & ~NVIC_IPR18_IPR_N2) | ((val << 16) & NVIC_IPR18_IPR_N2);
}
inline void nvic_ipr18_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR18 = (p->IPR18 & ~NVIC_IPR18_IPR_N1) | ((val << 8) & NVIC_IPR18_IPR_N1);
}
inline void nvic_ipr18_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR18 = (p->IPR18 & ~NVIC_IPR18_IPR_N0) | ((val << 0) & NVIC_IPR18_IPR_N0);
}
inline uint32_t nvic_ipr18_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR18 & NVIC_IPR18_IPR_N3) >> 24; }
inline uint32_t nvic_ipr18_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR18 & NVIC_IPR18_IPR_N2) >> 16; }
inline uint32_t nvic_ipr18_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR18 & NVIC_IPR18_IPR_N1) >> 8; }
inline uint32_t nvic_ipr18_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR18 & NVIC_IPR18_IPR_N0) >> 0; }

// NVIC->IPR19 Interrupt Priority Register
enum {
	NVIC_IPR19_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR19_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR19_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR19_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr19_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR19 = (p->IPR19 & ~NVIC_IPR19_IPR_N3) | ((val << 24) & NVIC_IPR19_IPR_N3);
}
inline void nvic_ipr19_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR19 = (p->IPR19 & ~NVIC_IPR19_IPR_N2) | ((val << 16) & NVIC_IPR19_IPR_N2);
}
inline void nvic_ipr19_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR19 = (p->IPR19 & ~NVIC_IPR19_IPR_N1) | ((val << 8) & NVIC_IPR19_IPR_N1);
}
inline void nvic_ipr19_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR19 = (p->IPR19 & ~NVIC_IPR19_IPR_N0) | ((val << 0) & NVIC_IPR19_IPR_N0);
}
inline uint32_t nvic_ipr19_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR19 & NVIC_IPR19_IPR_N3) >> 24; }
inline uint32_t nvic_ipr19_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR19 & NVIC_IPR19_IPR_N2) >> 16; }
inline uint32_t nvic_ipr19_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR19 & NVIC_IPR19_IPR_N1) >> 8; }
inline uint32_t nvic_ipr19_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR19 & NVIC_IPR19_IPR_N0) >> 0; }

/* Nested vectored interrupt controller */
struct NVIC_STIR_Type {
	__IO uint16_t STIR; // @0 Software trigger interrupt register
};

// NVIC_STIR->STIR Software trigger interrupt register
enum {
	NVIC_STIR_STIR_INTID = ((1UL << 9) - 1) << 0, // Software generated interrupt ID
};
inline void nvic_stir_stir_set_intid(struct NVIC_STIR_Type* p, uint32_t val) {
	p->STIR = (p->STIR & ~NVIC_STIR_STIR_INTID) | ((val << 0) & NVIC_STIR_STIR_INTID);
}
inline uint32_t nvic_stir_stir_get_intid(struct NVIC_STIR_Type* p) { return (p->STIR & NVIC_STIR_STIR_INTID) >> 0; }

/* USB on the go full speed */
struct OTG_FS_DEVICE_Type {
	__IO uint16_t FS_DCFG;        // @0 OTG_FS device configuration register (OTG_FS_DCFG)
	uint8_t       RESERVED0[2];   // @2
	__IO uint16_t FS_DCTL;        // @4 OTG_FS device control register (OTG_FS_DCTL)
	uint8_t       RESERVED1[2];   // @6
	__I uint32_t FS_DSTS;         // @8 OTG_FS device status register (OTG_FS_DSTS)
	uint8_t      RESERVED2[4];    // @12
	__IO uint8_t FS_DIEPMSK;      // @16 OTG_FS device IN endpoint common interrupt mask register (OTG_FS_DIEPMSK)
	uint8_t      RESERVED3[3];    // @17
	__IO uint8_t FS_DOEPMSK;      // @20 OTG_FS device OUT endpoint common interrupt mask register (OTG_FS_DOEPMSK)
	uint8_t      RESERVED4[3];    // @21
	__I uint32_t FS_DAINT;        // @24 OTG_FS device all endpoints interrupt register (OTG_FS_DAINT)
	__IO uint32_t FS_DAINTMSK;    // @28 OTG_FS all endpoints interrupt mask register (OTG_FS_DAINTMSK)
	uint8_t       RESERVED5[8];   // @32
	__IO uint16_t DVBUSDIS;       // @40 OTG_FS device VBUS discharge time register
	uint8_t       RESERVED6[2];   // @42
	__IO uint16_t DVBUSPULSE;     // @44 OTG_FS device VBUS pulsing time register
	uint8_t       RESERVED7[6];   // @46
	__IO uint16_t DIEPEMPMSK;     // @52 OTG_FS device IN endpoint FIFO empty interrupt mask register
	uint8_t       RESERVED8[202]; // @54
	__IO uint32_t FS_DIEPCTL0;    // @256 OTG_FS device control IN endpoint 0 control register (OTG_FS_DIEPCTL0)
	uint8_t       RESERVED9[4];   // @260
	__IO uint8_t DIEPINT0;        // @264 device endpoint-x interrupt register
	uint8_t      RESERVED10[7];   // @265
	__IO uint32_t DIEPTSIZ0;      // @272 device endpoint-0 transfer size register
	uint8_t       RESERVED11[4];  // @276
	__I uint16_t DTXFSTS0;        // @280 OTG_FS device IN endpoint transmit FIFO status register
	uint8_t      RESERVED12[6];   // @282
	__IO uint32_t DIEPCTL1;       // @288 OTG device endpoint-1 control register
	uint8_t       RESERVED13[4];  // @292
	__IO uint8_t DIEPINT1;        // @296 device endpoint-1 interrupt register
	uint8_t      RESERVED14[7];   // @297
	__IO uint32_t DIEPTSIZ1;      // @304 device endpoint-1 transfer size register
	uint8_t       RESERVED15[4];  // @308
	__I uint16_t DTXFSTS1;        // @312 OTG_FS device IN endpoint transmit FIFO status register
	uint8_t      RESERVED16[6];   // @314
	__IO uint32_t DIEPCTL2;       // @320 OTG device endpoint-2 control register
	uint8_t       RESERVED17[4];  // @324
	__IO uint8_t DIEPINT2;        // @328 device endpoint-2 interrupt register
	uint8_t      RESERVED18[7];   // @329
	__IO uint32_t DIEPTSIZ2;      // @336 device endpoint-2 transfer size register
	uint8_t       RESERVED19[4];  // @340
	__I uint16_t DTXFSTS2;        // @344 OTG_FS device IN endpoint transmit FIFO status register
	uint8_t      RESERVED20[6];   // @346
	__IO uint32_t DIEPCTL3;       // @352 OTG device endpoint-3 control register
	uint8_t       RESERVED21[4];  // @356
	__IO uint8_t DIEPINT3;        // @360 device endpoint-3 interrupt register
	uint8_t      RESERVED22[7];   // @361
	__IO uint32_t DIEPTSIZ3;      // @368 device endpoint-3 transfer size register
	uint8_t       RESERVED23[4];  // @372
	__I uint16_t DTXFSTS3;        // @376 OTG_FS device IN endpoint transmit FIFO status register
	uint8_t      RESERVED24[390]; // @378
	__IO uint32_t DOEPCTL0;       // @768 device endpoint-0 control register
	uint8_t       RESERVED25[4];  // @772
	__IO uint8_t DOEPINT0;        // @776 device endpoint-0 interrupt register
	uint8_t      RESERVED26[7];   // @777
	__IO uint32_t DOEPTSIZ0;      // @784 device OUT endpoint-0 transfer size register
	uint8_t       RESERVED27[12]; // @788
	__IO uint32_t DOEPCTL1;       // @800 device endpoint-1 control register
	uint8_t       RESERVED28[4];  // @804
	__IO uint8_t DOEPINT1;        // @808 device endpoint-1 interrupt register
	uint8_t      RESERVED29[7];   // @809
	__IO uint32_t DOEPTSIZ1;      // @816 device OUT endpoint-1 transfer size register
	uint8_t       RESERVED30[12]; // @820
	__IO uint32_t DOEPCTL2;       // @832 device endpoint-2 control register
	uint8_t       RESERVED31[4];  // @836
	__IO uint8_t DOEPINT2;        // @840 device endpoint-2 interrupt register
	uint8_t      RESERVED32[7];   // @841
	__IO uint32_t DOEPTSIZ2;      // @848 device OUT endpoint-2 transfer size register
	uint8_t       RESERVED33[12]; // @852
	__IO uint32_t DOEPCTL3;       // @864 device endpoint-3 control register
	uint8_t       RESERVED34[4];  // @868
	__IO uint8_t DOEPINT3;        // @872 device endpoint-3 interrupt register
	uint8_t      RESERVED35[7];   // @873
	__IO uint32_t DOEPTSIZ3;      // @880 device OUT endpoint-3 transfer size register
};

// OTG_FS_DEVICE->FS_DCFG OTG_FS device configuration register (OTG_FS_DCFG)
enum {
	OTG_FS_DEVICE_FS_DCFG_PFIVL    = ((1UL << 2) - 1) << 11, // Periodic frame interval
	OTG_FS_DEVICE_FS_DCFG_DAD      = ((1UL << 7) - 1) << 4,  // Device address
	OTG_FS_DEVICE_FS_DCFG_NZLSOHSK = 1UL << 2,               // Non-zero-length status OUT handshake
	OTG_FS_DEVICE_FS_DCFG_DSPD     = ((1UL << 2) - 1) << 0,  // Device speed
};
inline void otg_fs_device_fs_dcfg_set_pfivl(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->FS_DCFG = (p->FS_DCFG & ~OTG_FS_DEVICE_FS_DCFG_PFIVL) | ((val << 11) & OTG_FS_DEVICE_FS_DCFG_PFIVL);
}
inline void otg_fs_device_fs_dcfg_set_dad(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->FS_DCFG = (p->FS_DCFG & ~OTG_FS_DEVICE_FS_DCFG_DAD) | ((val << 4) & OTG_FS_DEVICE_FS_DCFG_DAD);
}
inline void otg_fs_device_fs_dcfg_set_dspd(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->FS_DCFG = (p->FS_DCFG & ~OTG_FS_DEVICE_FS_DCFG_DSPD) | ((val << 0) & OTG_FS_DEVICE_FS_DCFG_DSPD);
}
inline uint32_t otg_fs_device_fs_dcfg_get_pfivl(struct OTG_FS_DEVICE_Type* p) { return (p->FS_DCFG & OTG_FS_DEVICE_FS_DCFG_PFIVL) >> 11; }
inline uint32_t otg_fs_device_fs_dcfg_get_dad(struct OTG_FS_DEVICE_Type* p) { return (p->FS_DCFG & OTG_FS_DEVICE_FS_DCFG_DAD) >> 4; }
inline uint32_t otg_fs_device_fs_dcfg_get_dspd(struct OTG_FS_DEVICE_Type* p) { return (p->FS_DCFG & OTG_FS_DEVICE_FS_DCFG_DSPD) >> 0; }

// OTG_FS_DEVICE->FS_DCTL OTG_FS device control register (OTG_FS_DCTL)
enum {
	OTG_FS_DEVICE_FS_DCTL_POPRGDNE = 1UL << 11,             // Power-on programming done
	OTG_FS_DEVICE_FS_DCTL_CGONAK   = 1UL << 10,             // Clear global OUT NAK
	OTG_FS_DEVICE_FS_DCTL_SGONAK   = 1UL << 9,              // Set global OUT NAK
	OTG_FS_DEVICE_FS_DCTL_CGINAK   = 1UL << 8,              // Clear global IN NAK
	OTG_FS_DEVICE_FS_DCTL_SGINAK   = 1UL << 7,              // Set global IN NAK
	OTG_FS_DEVICE_FS_DCTL_TCTL     = ((1UL << 3) - 1) << 4, // Test control
	OTG_FS_DEVICE_FS_DCTL_GONSTS   = 1UL << 3,              // Global OUT NAK status
	OTG_FS_DEVICE_FS_DCTL_GINSTS   = 1UL << 2,              // Global IN NAK status
	OTG_FS_DEVICE_FS_DCTL_SDIS     = 1UL << 1,              // Soft disconnect
	OTG_FS_DEVICE_FS_DCTL_RWUSIG   = 1UL << 0,              // Remote wakeup signaling
};
inline void otg_fs_device_fs_dctl_set_tctl(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->FS_DCTL = (p->FS_DCTL & ~OTG_FS_DEVICE_FS_DCTL_TCTL) | ((val << 4) & OTG_FS_DEVICE_FS_DCTL_TCTL);
}
inline uint32_t otg_fs_device_fs_dctl_get_tctl(struct OTG_FS_DEVICE_Type* p) { return (p->FS_DCTL & OTG_FS_DEVICE_FS_DCTL_TCTL) >> 4; }

// OTG_FS_DEVICE->FS_DSTS OTG_FS device status register (OTG_FS_DSTS)
enum {
	OTG_FS_DEVICE_FS_DSTS_FNSOF   = ((1UL << 14) - 1) << 8, // Frame number of the received SOF
	OTG_FS_DEVICE_FS_DSTS_EERR    = 1UL << 3,               // Erratic error
	OTG_FS_DEVICE_FS_DSTS_ENUMSPD = ((1UL << 2) - 1) << 1,  // Enumerated speed
	OTG_FS_DEVICE_FS_DSTS_SUSPSTS = 1UL << 0,               // Suspend status
};
inline uint32_t otg_fs_device_fs_dsts_get_fnsof(struct OTG_FS_DEVICE_Type* p) { return (p->FS_DSTS & OTG_FS_DEVICE_FS_DSTS_FNSOF) >> 8; }
inline uint32_t otg_fs_device_fs_dsts_get_enumspd(struct OTG_FS_DEVICE_Type* p) {
	return (p->FS_DSTS & OTG_FS_DEVICE_FS_DSTS_ENUMSPD) >> 1;
}

// OTG_FS_DEVICE->FS_DIEPMSK OTG_FS device IN endpoint common interrupt mask register (OTG_FS_DIEPMSK)
enum {
	OTG_FS_DEVICE_FS_DIEPMSK_INEPNEM   = 1UL << 6, // IN endpoint NAK effective mask
	OTG_FS_DEVICE_FS_DIEPMSK_INEPNMM   = 1UL << 5, // IN token received with EP mismatch mask
	OTG_FS_DEVICE_FS_DIEPMSK_ITTXFEMSK = 1UL << 4, // IN token received when TxFIFO empty mask
	OTG_FS_DEVICE_FS_DIEPMSK_TOM       = 1UL << 3, // Timeout condition mask (Non-isochronous endpoints)
	OTG_FS_DEVICE_FS_DIEPMSK_EPDM      = 1UL << 1, // Endpoint disabled interrupt mask
	OTG_FS_DEVICE_FS_DIEPMSK_XFRCM     = 1UL << 0, // Transfer completed interrupt mask
};

// OTG_FS_DEVICE->FS_DOEPMSK OTG_FS device OUT endpoint common interrupt mask register (OTG_FS_DOEPMSK)
enum {
	OTG_FS_DEVICE_FS_DOEPMSK_OTEPDM = 1UL << 4, // OUT token received when endpoint disabled mask
	OTG_FS_DEVICE_FS_DOEPMSK_STUPM  = 1UL << 3, // SETUP phase done mask
	OTG_FS_DEVICE_FS_DOEPMSK_EPDM   = 1UL << 1, // Endpoint disabled interrupt mask
	OTG_FS_DEVICE_FS_DOEPMSK_XFRCM  = 1UL << 0, // Transfer completed interrupt mask
};

// OTG_FS_DEVICE->FS_DAINT OTG_FS device all endpoints interrupt register (OTG_FS_DAINT)
enum {
	OTG_FS_DEVICE_FS_DAINT_OEPINT = ((1UL << 16) - 1) << 16, // OUT endpoint interrupt bits
	OTG_FS_DEVICE_FS_DAINT_IEPINT = ((1UL << 16) - 1) << 0,  // IN endpoint interrupt bits
};
inline uint32_t otg_fs_device_fs_daint_get_oepint(struct OTG_FS_DEVICE_Type* p) {
	return (p->FS_DAINT & OTG_FS_DEVICE_FS_DAINT_OEPINT) >> 16;
}
inline uint32_t otg_fs_device_fs_daint_get_iepint(struct OTG_FS_DEVICE_Type* p) {
	return (p->FS_DAINT & OTG_FS_DEVICE_FS_DAINT_IEPINT) >> 0;
}

// OTG_FS_DEVICE->FS_DAINTMSK OTG_FS all endpoints interrupt mask register (OTG_FS_DAINTMSK)
enum {
	OTG_FS_DEVICE_FS_DAINTMSK_OEPINT = ((1UL << 16) - 1) << 16, // OUT endpoint interrupt bits
	OTG_FS_DEVICE_FS_DAINTMSK_IEPM   = ((1UL << 16) - 1) << 0,  // IN EP interrupt mask bits
};
inline void otg_fs_device_fs_daintmsk_set_oepint(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->FS_DAINTMSK = (p->FS_DAINTMSK & ~OTG_FS_DEVICE_FS_DAINTMSK_OEPINT) | ((val << 16) & OTG_FS_DEVICE_FS_DAINTMSK_OEPINT);
}
inline void otg_fs_device_fs_daintmsk_set_iepm(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->FS_DAINTMSK = (p->FS_DAINTMSK & ~OTG_FS_DEVICE_FS_DAINTMSK_IEPM) | ((val << 0) & OTG_FS_DEVICE_FS_DAINTMSK_IEPM);
}
inline uint32_t otg_fs_device_fs_daintmsk_get_oepint(struct OTG_FS_DEVICE_Type* p) {
	return (p->FS_DAINTMSK & OTG_FS_DEVICE_FS_DAINTMSK_OEPINT) >> 16;
}
inline uint32_t otg_fs_device_fs_daintmsk_get_iepm(struct OTG_FS_DEVICE_Type* p) {
	return (p->FS_DAINTMSK & OTG_FS_DEVICE_FS_DAINTMSK_IEPM) >> 0;
}

// OTG_FS_DEVICE->DVBUSPULSE OTG_FS device VBUS pulsing time register
enum {
	OTG_FS_DEVICE_DVBUSPULSE_DVBUSP = ((1UL << 12) - 1) << 0, // Device VBUS pulsing time
};
inline void otg_fs_device_dvbuspulse_set_dvbusp(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DVBUSPULSE = (p->DVBUSPULSE & ~OTG_FS_DEVICE_DVBUSPULSE_DVBUSP) | ((val << 0) & OTG_FS_DEVICE_DVBUSPULSE_DVBUSP);
}
inline uint32_t otg_fs_device_dvbuspulse_get_dvbusp(struct OTG_FS_DEVICE_Type* p) {
	return (p->DVBUSPULSE & OTG_FS_DEVICE_DVBUSPULSE_DVBUSP) >> 0;
}

// OTG_FS_DEVICE->FS_DIEPCTL0 OTG_FS device control IN endpoint 0 control register (OTG_FS_DIEPCTL0)
enum {
	OTG_FS_DEVICE_FS_DIEPCTL0_EPENA  = 1UL << 31,              // Endpoint enable
	OTG_FS_DEVICE_FS_DIEPCTL0_EPDIS  = 1UL << 30,              // Endpoint disable
	OTG_FS_DEVICE_FS_DIEPCTL0_SNAK   = 1UL << 27,              // Set NAK
	OTG_FS_DEVICE_FS_DIEPCTL0_CNAK   = 1UL << 26,              // Clear NAK
	OTG_FS_DEVICE_FS_DIEPCTL0_TXFNUM = ((1UL << 4) - 1) << 22, // TxFIFO number
	OTG_FS_DEVICE_FS_DIEPCTL0_STALL  = 1UL << 21,              // STALL handshake
	OTG_FS_DEVICE_FS_DIEPCTL0_EPTYP  = ((1UL << 2) - 1) << 18, // Endpoint type
	OTG_FS_DEVICE_FS_DIEPCTL0_NAKSTS = 1UL << 17,              // NAK status
	OTG_FS_DEVICE_FS_DIEPCTL0_USBAEP = 1UL << 15,              // USB active endpoint
	OTG_FS_DEVICE_FS_DIEPCTL0_MPSIZ  = ((1UL << 2) - 1) << 0,  // Maximum packet size
};
inline void otg_fs_device_fs_diepctl0_set_txfnum(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->FS_DIEPCTL0 = (p->FS_DIEPCTL0 & ~OTG_FS_DEVICE_FS_DIEPCTL0_TXFNUM) | ((val << 22) & OTG_FS_DEVICE_FS_DIEPCTL0_TXFNUM);
}
inline void otg_fs_device_fs_diepctl0_set_eptyp(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->FS_DIEPCTL0 = (p->FS_DIEPCTL0 & ~OTG_FS_DEVICE_FS_DIEPCTL0_EPTYP) | ((val << 18) & OTG_FS_DEVICE_FS_DIEPCTL0_EPTYP);
}
inline void otg_fs_device_fs_diepctl0_set_mpsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->FS_DIEPCTL0 = (p->FS_DIEPCTL0 & ~OTG_FS_DEVICE_FS_DIEPCTL0_MPSIZ) | ((val << 0) & OTG_FS_DEVICE_FS_DIEPCTL0_MPSIZ);
}
inline uint32_t otg_fs_device_fs_diepctl0_get_txfnum(struct OTG_FS_DEVICE_Type* p) {
	return (p->FS_DIEPCTL0 & OTG_FS_DEVICE_FS_DIEPCTL0_TXFNUM) >> 22;
}
inline uint32_t otg_fs_device_fs_diepctl0_get_eptyp(struct OTG_FS_DEVICE_Type* p) {
	return (p->FS_DIEPCTL0 & OTG_FS_DEVICE_FS_DIEPCTL0_EPTYP) >> 18;
}
inline uint32_t otg_fs_device_fs_diepctl0_get_mpsiz(struct OTG_FS_DEVICE_Type* p) {
	return (p->FS_DIEPCTL0 & OTG_FS_DEVICE_FS_DIEPCTL0_MPSIZ) >> 0;
}

// OTG_FS_DEVICE->DIEPINT0 device endpoint-x interrupt register
enum {
	OTG_FS_DEVICE_DIEPINT0_TXFE   = 1UL << 7, // TXFE
	OTG_FS_DEVICE_DIEPINT0_INEPNE = 1UL << 6, // INEPNE
	OTG_FS_DEVICE_DIEPINT0_ITTXFE = 1UL << 4, // ITTXFE
	OTG_FS_DEVICE_DIEPINT0_TOC    = 1UL << 3, // TOC
	OTG_FS_DEVICE_DIEPINT0_EPDISD = 1UL << 1, // EPDISD
	OTG_FS_DEVICE_DIEPINT0_XFRC   = 1UL << 0, // XFRC
};

// OTG_FS_DEVICE->DIEPTSIZ0 device endpoint-0 transfer size register
enum {
	OTG_FS_DEVICE_DIEPTSIZ0_PKTCNT = ((1UL << 2) - 1) << 19, // Packet count
	OTG_FS_DEVICE_DIEPTSIZ0_XFRSIZ = ((1UL << 7) - 1) << 0,  // Transfer size
};
inline void otg_fs_device_dieptsiz0_set_pktcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DIEPTSIZ0 = (p->DIEPTSIZ0 & ~OTG_FS_DEVICE_DIEPTSIZ0_PKTCNT) | ((val << 19) & OTG_FS_DEVICE_DIEPTSIZ0_PKTCNT);
}
inline void otg_fs_device_dieptsiz0_set_xfrsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DIEPTSIZ0 = (p->DIEPTSIZ0 & ~OTG_FS_DEVICE_DIEPTSIZ0_XFRSIZ) | ((val << 0) & OTG_FS_DEVICE_DIEPTSIZ0_XFRSIZ);
}
inline uint32_t otg_fs_device_dieptsiz0_get_pktcnt(struct OTG_FS_DEVICE_Type* p) {
	return (p->DIEPTSIZ0 & OTG_FS_DEVICE_DIEPTSIZ0_PKTCNT) >> 19;
}
inline uint32_t otg_fs_device_dieptsiz0_get_xfrsiz(struct OTG_FS_DEVICE_Type* p) {
	return (p->DIEPTSIZ0 & OTG_FS_DEVICE_DIEPTSIZ0_XFRSIZ) >> 0;
}

// OTG_FS_DEVICE->DIEPCTL1 OTG device endpoint-1 control register
enum {
	OTG_FS_DEVICE_DIEPCTL1_EPENA          = 1UL << 31,              // EPENA
	OTG_FS_DEVICE_DIEPCTL1_EPDIS          = 1UL << 30,              // EPDIS
	OTG_FS_DEVICE_DIEPCTL1_SODDFRM_SD1PID = 1UL << 29,              // SODDFRM/SD1PID
	OTG_FS_DEVICE_DIEPCTL1_SD0PID_SEVNFRM = 1UL << 28,              // SD0PID/SEVNFRM
	OTG_FS_DEVICE_DIEPCTL1_SNAK           = 1UL << 27,              // SNAK
	OTG_FS_DEVICE_DIEPCTL1_CNAK           = 1UL << 26,              // CNAK
	OTG_FS_DEVICE_DIEPCTL1_TXFNUM         = ((1UL << 4) - 1) << 22, // TXFNUM
	OTG_FS_DEVICE_DIEPCTL1_STALL          = 1UL << 21,              // Stall
	OTG_FS_DEVICE_DIEPCTL1_EPTYP          = ((1UL << 2) - 1) << 18, // EPTYP
	OTG_FS_DEVICE_DIEPCTL1_NAKSTS         = 1UL << 17,              // NAKSTS
	OTG_FS_DEVICE_DIEPCTL1_EONUM_DPID     = 1UL << 16,              // EONUM/DPID
	OTG_FS_DEVICE_DIEPCTL1_USBAEP         = 1UL << 15,              // USBAEP
	OTG_FS_DEVICE_DIEPCTL1_MPSIZ          = ((1UL << 11) - 1) << 0, // MPSIZ
};
inline void otg_fs_device_diepctl1_set_txfnum(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DIEPCTL1 = (p->DIEPCTL1 & ~OTG_FS_DEVICE_DIEPCTL1_TXFNUM) | ((val << 22) & OTG_FS_DEVICE_DIEPCTL1_TXFNUM);
}
inline void otg_fs_device_diepctl1_set_eptyp(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DIEPCTL1 = (p->DIEPCTL1 & ~OTG_FS_DEVICE_DIEPCTL1_EPTYP) | ((val << 18) & OTG_FS_DEVICE_DIEPCTL1_EPTYP);
}
inline void otg_fs_device_diepctl1_set_mpsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DIEPCTL1 = (p->DIEPCTL1 & ~OTG_FS_DEVICE_DIEPCTL1_MPSIZ) | ((val << 0) & OTG_FS_DEVICE_DIEPCTL1_MPSIZ);
}
inline uint32_t otg_fs_device_diepctl1_get_txfnum(struct OTG_FS_DEVICE_Type* p) {
	return (p->DIEPCTL1 & OTG_FS_DEVICE_DIEPCTL1_TXFNUM) >> 22;
}
inline uint32_t otg_fs_device_diepctl1_get_eptyp(struct OTG_FS_DEVICE_Type* p) {
	return (p->DIEPCTL1 & OTG_FS_DEVICE_DIEPCTL1_EPTYP) >> 18;
}
inline uint32_t otg_fs_device_diepctl1_get_mpsiz(struct OTG_FS_DEVICE_Type* p) { return (p->DIEPCTL1 & OTG_FS_DEVICE_DIEPCTL1_MPSIZ) >> 0; }

// OTG_FS_DEVICE->DIEPINT1 device endpoint-1 interrupt register
enum {
	OTG_FS_DEVICE_DIEPINT1_TXFE   = 1UL << 7, // TXFE
	OTG_FS_DEVICE_DIEPINT1_INEPNE = 1UL << 6, // INEPNE
	OTG_FS_DEVICE_DIEPINT1_ITTXFE = 1UL << 4, // ITTXFE
	OTG_FS_DEVICE_DIEPINT1_TOC    = 1UL << 3, // TOC
	OTG_FS_DEVICE_DIEPINT1_EPDISD = 1UL << 1, // EPDISD
	OTG_FS_DEVICE_DIEPINT1_XFRC   = 1UL << 0, // XFRC
};

// OTG_FS_DEVICE->DIEPTSIZ1 device endpoint-1 transfer size register
enum {
	OTG_FS_DEVICE_DIEPTSIZ1_MCNT   = ((1UL << 2) - 1) << 29,  // Multi count
	OTG_FS_DEVICE_DIEPTSIZ1_PKTCNT = ((1UL << 10) - 1) << 19, // Packet count
	OTG_FS_DEVICE_DIEPTSIZ1_XFRSIZ = ((1UL << 19) - 1) << 0,  // Transfer size
};
inline void otg_fs_device_dieptsiz1_set_mcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DIEPTSIZ1 = (p->DIEPTSIZ1 & ~OTG_FS_DEVICE_DIEPTSIZ1_MCNT) | ((val << 29) & OTG_FS_DEVICE_DIEPTSIZ1_MCNT);
}
inline void otg_fs_device_dieptsiz1_set_pktcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DIEPTSIZ1 = (p->DIEPTSIZ1 & ~OTG_FS_DEVICE_DIEPTSIZ1_PKTCNT) | ((val << 19) & OTG_FS_DEVICE_DIEPTSIZ1_PKTCNT);
}
inline void otg_fs_device_dieptsiz1_set_xfrsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DIEPTSIZ1 = (p->DIEPTSIZ1 & ~OTG_FS_DEVICE_DIEPTSIZ1_XFRSIZ) | ((val << 0) & OTG_FS_DEVICE_DIEPTSIZ1_XFRSIZ);
}
inline uint32_t otg_fs_device_dieptsiz1_get_mcnt(struct OTG_FS_DEVICE_Type* p) {
	return (p->DIEPTSIZ1 & OTG_FS_DEVICE_DIEPTSIZ1_MCNT) >> 29;
}
inline uint32_t otg_fs_device_dieptsiz1_get_pktcnt(struct OTG_FS_DEVICE_Type* p) {
	return (p->DIEPTSIZ1 & OTG_FS_DEVICE_DIEPTSIZ1_PKTCNT) >> 19;
}
inline uint32_t otg_fs_device_dieptsiz1_get_xfrsiz(struct OTG_FS_DEVICE_Type* p) {
	return (p->DIEPTSIZ1 & OTG_FS_DEVICE_DIEPTSIZ1_XFRSIZ) >> 0;
}

// OTG_FS_DEVICE->DIEPCTL2 OTG device endpoint-2 control register
enum {
	OTG_FS_DEVICE_DIEPCTL2_EPENA          = 1UL << 31,              // EPENA
	OTG_FS_DEVICE_DIEPCTL2_EPDIS          = 1UL << 30,              // EPDIS
	OTG_FS_DEVICE_DIEPCTL2_SODDFRM        = 1UL << 29,              // SODDFRM
	OTG_FS_DEVICE_DIEPCTL2_SD0PID_SEVNFRM = 1UL << 28,              // SD0PID/SEVNFRM
	OTG_FS_DEVICE_DIEPCTL2_SNAK           = 1UL << 27,              // SNAK
	OTG_FS_DEVICE_DIEPCTL2_CNAK           = 1UL << 26,              // CNAK
	OTG_FS_DEVICE_DIEPCTL2_TXFNUM         = ((1UL << 4) - 1) << 22, // TXFNUM
	OTG_FS_DEVICE_DIEPCTL2_STALL          = 1UL << 21,              // Stall
	OTG_FS_DEVICE_DIEPCTL2_EPTYP          = ((1UL << 2) - 1) << 18, // EPTYP
	OTG_FS_DEVICE_DIEPCTL2_NAKSTS         = 1UL << 17,              // NAKSTS
	OTG_FS_DEVICE_DIEPCTL2_EONUM_DPID     = 1UL << 16,              // EONUM/DPID
	OTG_FS_DEVICE_DIEPCTL2_USBAEP         = 1UL << 15,              // USBAEP
	OTG_FS_DEVICE_DIEPCTL2_MPSIZ          = ((1UL << 11) - 1) << 0, // MPSIZ
};
inline void otg_fs_device_diepctl2_set_txfnum(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DIEPCTL2 = (p->DIEPCTL2 & ~OTG_FS_DEVICE_DIEPCTL2_TXFNUM) | ((val << 22) & OTG_FS_DEVICE_DIEPCTL2_TXFNUM);
}
inline void otg_fs_device_diepctl2_set_eptyp(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DIEPCTL2 = (p->DIEPCTL2 & ~OTG_FS_DEVICE_DIEPCTL2_EPTYP) | ((val << 18) & OTG_FS_DEVICE_DIEPCTL2_EPTYP);
}
inline void otg_fs_device_diepctl2_set_mpsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DIEPCTL2 = (p->DIEPCTL2 & ~OTG_FS_DEVICE_DIEPCTL2_MPSIZ) | ((val << 0) & OTG_FS_DEVICE_DIEPCTL2_MPSIZ);
}
inline uint32_t otg_fs_device_diepctl2_get_txfnum(struct OTG_FS_DEVICE_Type* p) {
	return (p->DIEPCTL2 & OTG_FS_DEVICE_DIEPCTL2_TXFNUM) >> 22;
}
inline uint32_t otg_fs_device_diepctl2_get_eptyp(struct OTG_FS_DEVICE_Type* p) {
	return (p->DIEPCTL2 & OTG_FS_DEVICE_DIEPCTL2_EPTYP) >> 18;
}
inline uint32_t otg_fs_device_diepctl2_get_mpsiz(struct OTG_FS_DEVICE_Type* p) { return (p->DIEPCTL2 & OTG_FS_DEVICE_DIEPCTL2_MPSIZ) >> 0; }

// OTG_FS_DEVICE->DIEPINT2 device endpoint-2 interrupt register
enum {
	OTG_FS_DEVICE_DIEPINT2_TXFE   = 1UL << 7, // TXFE
	OTG_FS_DEVICE_DIEPINT2_INEPNE = 1UL << 6, // INEPNE
	OTG_FS_DEVICE_DIEPINT2_ITTXFE = 1UL << 4, // ITTXFE
	OTG_FS_DEVICE_DIEPINT2_TOC    = 1UL << 3, // TOC
	OTG_FS_DEVICE_DIEPINT2_EPDISD = 1UL << 1, // EPDISD
	OTG_FS_DEVICE_DIEPINT2_XFRC   = 1UL << 0, // XFRC
};

// OTG_FS_DEVICE->DIEPTSIZ2 device endpoint-2 transfer size register
enum {
	OTG_FS_DEVICE_DIEPTSIZ2_MCNT   = ((1UL << 2) - 1) << 29,  // Multi count
	OTG_FS_DEVICE_DIEPTSIZ2_PKTCNT = ((1UL << 10) - 1) << 19, // Packet count
	OTG_FS_DEVICE_DIEPTSIZ2_XFRSIZ = ((1UL << 19) - 1) << 0,  // Transfer size
};
inline void otg_fs_device_dieptsiz2_set_mcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DIEPTSIZ2 = (p->DIEPTSIZ2 & ~OTG_FS_DEVICE_DIEPTSIZ2_MCNT) | ((val << 29) & OTG_FS_DEVICE_DIEPTSIZ2_MCNT);
}
inline void otg_fs_device_dieptsiz2_set_pktcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DIEPTSIZ2 = (p->DIEPTSIZ2 & ~OTG_FS_DEVICE_DIEPTSIZ2_PKTCNT) | ((val << 19) & OTG_FS_DEVICE_DIEPTSIZ2_PKTCNT);
}
inline void otg_fs_device_dieptsiz2_set_xfrsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DIEPTSIZ2 = (p->DIEPTSIZ2 & ~OTG_FS_DEVICE_DIEPTSIZ2_XFRSIZ) | ((val << 0) & OTG_FS_DEVICE_DIEPTSIZ2_XFRSIZ);
}
inline uint32_t otg_fs_device_dieptsiz2_get_mcnt(struct OTG_FS_DEVICE_Type* p) {
	return (p->DIEPTSIZ2 & OTG_FS_DEVICE_DIEPTSIZ2_MCNT) >> 29;
}
inline uint32_t otg_fs_device_dieptsiz2_get_pktcnt(struct OTG_FS_DEVICE_Type* p) {
	return (p->DIEPTSIZ2 & OTG_FS_DEVICE_DIEPTSIZ2_PKTCNT) >> 19;
}
inline uint32_t otg_fs_device_dieptsiz2_get_xfrsiz(struct OTG_FS_DEVICE_Type* p) {
	return (p->DIEPTSIZ2 & OTG_FS_DEVICE_DIEPTSIZ2_XFRSIZ) >> 0;
}

// OTG_FS_DEVICE->DIEPCTL3 OTG device endpoint-3 control register
enum {
	OTG_FS_DEVICE_DIEPCTL3_EPENA          = 1UL << 31,              // EPENA
	OTG_FS_DEVICE_DIEPCTL3_EPDIS          = 1UL << 30,              // EPDIS
	OTG_FS_DEVICE_DIEPCTL3_SODDFRM        = 1UL << 29,              // SODDFRM
	OTG_FS_DEVICE_DIEPCTL3_SD0PID_SEVNFRM = 1UL << 28,              // SD0PID/SEVNFRM
	OTG_FS_DEVICE_DIEPCTL3_SNAK           = 1UL << 27,              // SNAK
	OTG_FS_DEVICE_DIEPCTL3_CNAK           = 1UL << 26,              // CNAK
	OTG_FS_DEVICE_DIEPCTL3_TXFNUM         = ((1UL << 4) - 1) << 22, // TXFNUM
	OTG_FS_DEVICE_DIEPCTL3_STALL          = 1UL << 21,              // Stall
	OTG_FS_DEVICE_DIEPCTL3_EPTYP          = ((1UL << 2) - 1) << 18, // EPTYP
	OTG_FS_DEVICE_DIEPCTL3_NAKSTS         = 1UL << 17,              // NAKSTS
	OTG_FS_DEVICE_DIEPCTL3_EONUM_DPID     = 1UL << 16,              // EONUM/DPID
	OTG_FS_DEVICE_DIEPCTL3_USBAEP         = 1UL << 15,              // USBAEP
	OTG_FS_DEVICE_DIEPCTL3_MPSIZ          = ((1UL << 11) - 1) << 0, // MPSIZ
};
inline void otg_fs_device_diepctl3_set_txfnum(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DIEPCTL3 = (p->DIEPCTL3 & ~OTG_FS_DEVICE_DIEPCTL3_TXFNUM) | ((val << 22) & OTG_FS_DEVICE_DIEPCTL3_TXFNUM);
}
inline void otg_fs_device_diepctl3_set_eptyp(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DIEPCTL3 = (p->DIEPCTL3 & ~OTG_FS_DEVICE_DIEPCTL3_EPTYP) | ((val << 18) & OTG_FS_DEVICE_DIEPCTL3_EPTYP);
}
inline void otg_fs_device_diepctl3_set_mpsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DIEPCTL3 = (p->DIEPCTL3 & ~OTG_FS_DEVICE_DIEPCTL3_MPSIZ) | ((val << 0) & OTG_FS_DEVICE_DIEPCTL3_MPSIZ);
}
inline uint32_t otg_fs_device_diepctl3_get_txfnum(struct OTG_FS_DEVICE_Type* p) {
	return (p->DIEPCTL3 & OTG_FS_DEVICE_DIEPCTL3_TXFNUM) >> 22;
}
inline uint32_t otg_fs_device_diepctl3_get_eptyp(struct OTG_FS_DEVICE_Type* p) {
	return (p->DIEPCTL3 & OTG_FS_DEVICE_DIEPCTL3_EPTYP) >> 18;
}
inline uint32_t otg_fs_device_diepctl3_get_mpsiz(struct OTG_FS_DEVICE_Type* p) { return (p->DIEPCTL3 & OTG_FS_DEVICE_DIEPCTL3_MPSIZ) >> 0; }

// OTG_FS_DEVICE->DIEPINT3 device endpoint-3 interrupt register
enum {
	OTG_FS_DEVICE_DIEPINT3_TXFE   = 1UL << 7, // TXFE
	OTG_FS_DEVICE_DIEPINT3_INEPNE = 1UL << 6, // INEPNE
	OTG_FS_DEVICE_DIEPINT3_ITTXFE = 1UL << 4, // ITTXFE
	OTG_FS_DEVICE_DIEPINT3_TOC    = 1UL << 3, // TOC
	OTG_FS_DEVICE_DIEPINT3_EPDISD = 1UL << 1, // EPDISD
	OTG_FS_DEVICE_DIEPINT3_XFRC   = 1UL << 0, // XFRC
};

// OTG_FS_DEVICE->DIEPTSIZ3 device endpoint-3 transfer size register
enum {
	OTG_FS_DEVICE_DIEPTSIZ3_MCNT   = ((1UL << 2) - 1) << 29,  // Multi count
	OTG_FS_DEVICE_DIEPTSIZ3_PKTCNT = ((1UL << 10) - 1) << 19, // Packet count
	OTG_FS_DEVICE_DIEPTSIZ3_XFRSIZ = ((1UL << 19) - 1) << 0,  // Transfer size
};
inline void otg_fs_device_dieptsiz3_set_mcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DIEPTSIZ3 = (p->DIEPTSIZ3 & ~OTG_FS_DEVICE_DIEPTSIZ3_MCNT) | ((val << 29) & OTG_FS_DEVICE_DIEPTSIZ3_MCNT);
}
inline void otg_fs_device_dieptsiz3_set_pktcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DIEPTSIZ3 = (p->DIEPTSIZ3 & ~OTG_FS_DEVICE_DIEPTSIZ3_PKTCNT) | ((val << 19) & OTG_FS_DEVICE_DIEPTSIZ3_PKTCNT);
}
inline void otg_fs_device_dieptsiz3_set_xfrsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DIEPTSIZ3 = (p->DIEPTSIZ3 & ~OTG_FS_DEVICE_DIEPTSIZ3_XFRSIZ) | ((val << 0) & OTG_FS_DEVICE_DIEPTSIZ3_XFRSIZ);
}
inline uint32_t otg_fs_device_dieptsiz3_get_mcnt(struct OTG_FS_DEVICE_Type* p) {
	return (p->DIEPTSIZ3 & OTG_FS_DEVICE_DIEPTSIZ3_MCNT) >> 29;
}
inline uint32_t otg_fs_device_dieptsiz3_get_pktcnt(struct OTG_FS_DEVICE_Type* p) {
	return (p->DIEPTSIZ3 & OTG_FS_DEVICE_DIEPTSIZ3_PKTCNT) >> 19;
}
inline uint32_t otg_fs_device_dieptsiz3_get_xfrsiz(struct OTG_FS_DEVICE_Type* p) {
	return (p->DIEPTSIZ3 & OTG_FS_DEVICE_DIEPTSIZ3_XFRSIZ) >> 0;
}

// OTG_FS_DEVICE->DOEPCTL0 device endpoint-0 control register
enum {
	OTG_FS_DEVICE_DOEPCTL0_EPENA  = 1UL << 31,              // EPENA
	OTG_FS_DEVICE_DOEPCTL0_EPDIS  = 1UL << 30,              // EPDIS
	OTG_FS_DEVICE_DOEPCTL0_SNAK   = 1UL << 27,              // SNAK
	OTG_FS_DEVICE_DOEPCTL0_CNAK   = 1UL << 26,              // CNAK
	OTG_FS_DEVICE_DOEPCTL0_STALL  = 1UL << 21,              // Stall
	OTG_FS_DEVICE_DOEPCTL0_SNPM   = 1UL << 20,              // SNPM
	OTG_FS_DEVICE_DOEPCTL0_EPTYP  = ((1UL << 2) - 1) << 18, // EPTYP
	OTG_FS_DEVICE_DOEPCTL0_NAKSTS = 1UL << 17,              // NAKSTS
	OTG_FS_DEVICE_DOEPCTL0_USBAEP = 1UL << 15,              // USBAEP
	OTG_FS_DEVICE_DOEPCTL0_MPSIZ  = ((1UL << 2) - 1) << 0,  // MPSIZ
};
inline void otg_fs_device_doepctl0_set_eptyp(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DOEPCTL0 = (p->DOEPCTL0 & ~OTG_FS_DEVICE_DOEPCTL0_EPTYP) | ((val << 18) & OTG_FS_DEVICE_DOEPCTL0_EPTYP);
}
inline void otg_fs_device_doepctl0_set_mpsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DOEPCTL0 = (p->DOEPCTL0 & ~OTG_FS_DEVICE_DOEPCTL0_MPSIZ) | ((val << 0) & OTG_FS_DEVICE_DOEPCTL0_MPSIZ);
}
inline uint32_t otg_fs_device_doepctl0_get_eptyp(struct OTG_FS_DEVICE_Type* p) {
	return (p->DOEPCTL0 & OTG_FS_DEVICE_DOEPCTL0_EPTYP) >> 18;
}
inline uint32_t otg_fs_device_doepctl0_get_mpsiz(struct OTG_FS_DEVICE_Type* p) { return (p->DOEPCTL0 & OTG_FS_DEVICE_DOEPCTL0_MPSIZ) >> 0; }

// OTG_FS_DEVICE->DOEPINT0 device endpoint-0 interrupt register
enum {
	OTG_FS_DEVICE_DOEPINT0_B2BSTUP = 1UL << 6, // B2BSTUP
	OTG_FS_DEVICE_DOEPINT0_OTEPDIS = 1UL << 4, // OTEPDIS
	OTG_FS_DEVICE_DOEPINT0_STUP    = 1UL << 3, // STUP
	OTG_FS_DEVICE_DOEPINT0_EPDISD  = 1UL << 1, // EPDISD
	OTG_FS_DEVICE_DOEPINT0_XFRC    = 1UL << 0, // XFRC
};

// OTG_FS_DEVICE->DOEPTSIZ0 device OUT endpoint-0 transfer size register
enum {
	OTG_FS_DEVICE_DOEPTSIZ0_STUPCNT = ((1UL << 2) - 1) << 29, // SETUP packet count
	OTG_FS_DEVICE_DOEPTSIZ0_PKTCNT  = 1UL << 19,              // Packet count
	OTG_FS_DEVICE_DOEPTSIZ0_XFRSIZ  = ((1UL << 7) - 1) << 0,  // Transfer size
};
inline void otg_fs_device_doeptsiz0_set_stupcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DOEPTSIZ0 = (p->DOEPTSIZ0 & ~OTG_FS_DEVICE_DOEPTSIZ0_STUPCNT) | ((val << 29) & OTG_FS_DEVICE_DOEPTSIZ0_STUPCNT);
}
inline void otg_fs_device_doeptsiz0_set_xfrsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DOEPTSIZ0 = (p->DOEPTSIZ0 & ~OTG_FS_DEVICE_DOEPTSIZ0_XFRSIZ) | ((val << 0) & OTG_FS_DEVICE_DOEPTSIZ0_XFRSIZ);
}
inline uint32_t otg_fs_device_doeptsiz0_get_stupcnt(struct OTG_FS_DEVICE_Type* p) {
	return (p->DOEPTSIZ0 & OTG_FS_DEVICE_DOEPTSIZ0_STUPCNT) >> 29;
}
inline uint32_t otg_fs_device_doeptsiz0_get_xfrsiz(struct OTG_FS_DEVICE_Type* p) {
	return (p->DOEPTSIZ0 & OTG_FS_DEVICE_DOEPTSIZ0_XFRSIZ) >> 0;
}

// OTG_FS_DEVICE->DOEPCTL1 device endpoint-1 control register
enum {
	OTG_FS_DEVICE_DOEPCTL1_EPENA          = 1UL << 31,              // EPENA
	OTG_FS_DEVICE_DOEPCTL1_EPDIS          = 1UL << 30,              // EPDIS
	OTG_FS_DEVICE_DOEPCTL1_SODDFRM        = 1UL << 29,              // SODDFRM
	OTG_FS_DEVICE_DOEPCTL1_SD0PID_SEVNFRM = 1UL << 28,              // SD0PID/SEVNFRM
	OTG_FS_DEVICE_DOEPCTL1_SNAK           = 1UL << 27,              // SNAK
	OTG_FS_DEVICE_DOEPCTL1_CNAK           = 1UL << 26,              // CNAK
	OTG_FS_DEVICE_DOEPCTL1_STALL          = 1UL << 21,              // Stall
	OTG_FS_DEVICE_DOEPCTL1_SNPM           = 1UL << 20,              // SNPM
	OTG_FS_DEVICE_DOEPCTL1_EPTYP          = ((1UL << 2) - 1) << 18, // EPTYP
	OTG_FS_DEVICE_DOEPCTL1_NAKSTS         = 1UL << 17,              // NAKSTS
	OTG_FS_DEVICE_DOEPCTL1_EONUM_DPID     = 1UL << 16,              // EONUM/DPID
	OTG_FS_DEVICE_DOEPCTL1_USBAEP         = 1UL << 15,              // USBAEP
	OTG_FS_DEVICE_DOEPCTL1_MPSIZ          = ((1UL << 11) - 1) << 0, // MPSIZ
};
inline void otg_fs_device_doepctl1_set_eptyp(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DOEPCTL1 = (p->DOEPCTL1 & ~OTG_FS_DEVICE_DOEPCTL1_EPTYP) | ((val << 18) & OTG_FS_DEVICE_DOEPCTL1_EPTYP);
}
inline void otg_fs_device_doepctl1_set_mpsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DOEPCTL1 = (p->DOEPCTL1 & ~OTG_FS_DEVICE_DOEPCTL1_MPSIZ) | ((val << 0) & OTG_FS_DEVICE_DOEPCTL1_MPSIZ);
}
inline uint32_t otg_fs_device_doepctl1_get_eptyp(struct OTG_FS_DEVICE_Type* p) {
	return (p->DOEPCTL1 & OTG_FS_DEVICE_DOEPCTL1_EPTYP) >> 18;
}
inline uint32_t otg_fs_device_doepctl1_get_mpsiz(struct OTG_FS_DEVICE_Type* p) { return (p->DOEPCTL1 & OTG_FS_DEVICE_DOEPCTL1_MPSIZ) >> 0; }

// OTG_FS_DEVICE->DOEPINT1 device endpoint-1 interrupt register
enum {
	OTG_FS_DEVICE_DOEPINT1_B2BSTUP = 1UL << 6, // B2BSTUP
	OTG_FS_DEVICE_DOEPINT1_OTEPDIS = 1UL << 4, // OTEPDIS
	OTG_FS_DEVICE_DOEPINT1_STUP    = 1UL << 3, // STUP
	OTG_FS_DEVICE_DOEPINT1_EPDISD  = 1UL << 1, // EPDISD
	OTG_FS_DEVICE_DOEPINT1_XFRC    = 1UL << 0, // XFRC
};

// OTG_FS_DEVICE->DOEPTSIZ1 device OUT endpoint-1 transfer size register
enum {
	OTG_FS_DEVICE_DOEPTSIZ1_RXDPID_STUPCNT = ((1UL << 2) - 1) << 29,  // Received data PID/SETUP packet count
	OTG_FS_DEVICE_DOEPTSIZ1_PKTCNT         = ((1UL << 10) - 1) << 19, // Packet count
	OTG_FS_DEVICE_DOEPTSIZ1_XFRSIZ         = ((1UL << 19) - 1) << 0,  // Transfer size
};
inline void otg_fs_device_doeptsiz1_set_rxdpid_stupcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DOEPTSIZ1 = (p->DOEPTSIZ1 & ~OTG_FS_DEVICE_DOEPTSIZ1_RXDPID_STUPCNT) | ((val << 29) & OTG_FS_DEVICE_DOEPTSIZ1_RXDPID_STUPCNT);
}
inline void otg_fs_device_doeptsiz1_set_pktcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DOEPTSIZ1 = (p->DOEPTSIZ1 & ~OTG_FS_DEVICE_DOEPTSIZ1_PKTCNT) | ((val << 19) & OTG_FS_DEVICE_DOEPTSIZ1_PKTCNT);
}
inline void otg_fs_device_doeptsiz1_set_xfrsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DOEPTSIZ1 = (p->DOEPTSIZ1 & ~OTG_FS_DEVICE_DOEPTSIZ1_XFRSIZ) | ((val << 0) & OTG_FS_DEVICE_DOEPTSIZ1_XFRSIZ);
}
inline uint32_t otg_fs_device_doeptsiz1_get_rxdpid_stupcnt(struct OTG_FS_DEVICE_Type* p) {
	return (p->DOEPTSIZ1 & OTG_FS_DEVICE_DOEPTSIZ1_RXDPID_STUPCNT) >> 29;
}
inline uint32_t otg_fs_device_doeptsiz1_get_pktcnt(struct OTG_FS_DEVICE_Type* p) {
	return (p->DOEPTSIZ1 & OTG_FS_DEVICE_DOEPTSIZ1_PKTCNT) >> 19;
}
inline uint32_t otg_fs_device_doeptsiz1_get_xfrsiz(struct OTG_FS_DEVICE_Type* p) {
	return (p->DOEPTSIZ1 & OTG_FS_DEVICE_DOEPTSIZ1_XFRSIZ) >> 0;
}

// OTG_FS_DEVICE->DOEPCTL2 device endpoint-2 control register
enum {
	OTG_FS_DEVICE_DOEPCTL2_EPENA          = 1UL << 31,              // EPENA
	OTG_FS_DEVICE_DOEPCTL2_EPDIS          = 1UL << 30,              // EPDIS
	OTG_FS_DEVICE_DOEPCTL2_SODDFRM        = 1UL << 29,              // SODDFRM
	OTG_FS_DEVICE_DOEPCTL2_SD0PID_SEVNFRM = 1UL << 28,              // SD0PID/SEVNFRM
	OTG_FS_DEVICE_DOEPCTL2_SNAK           = 1UL << 27,              // SNAK
	OTG_FS_DEVICE_DOEPCTL2_CNAK           = 1UL << 26,              // CNAK
	OTG_FS_DEVICE_DOEPCTL2_STALL          = 1UL << 21,              // Stall
	OTG_FS_DEVICE_DOEPCTL2_SNPM           = 1UL << 20,              // SNPM
	OTG_FS_DEVICE_DOEPCTL2_EPTYP          = ((1UL << 2) - 1) << 18, // EPTYP
	OTG_FS_DEVICE_DOEPCTL2_NAKSTS         = 1UL << 17,              // NAKSTS
	OTG_FS_DEVICE_DOEPCTL2_EONUM_DPID     = 1UL << 16,              // EONUM/DPID
	OTG_FS_DEVICE_DOEPCTL2_USBAEP         = 1UL << 15,              // USBAEP
	OTG_FS_DEVICE_DOEPCTL2_MPSIZ          = ((1UL << 11) - 1) << 0, // MPSIZ
};
inline void otg_fs_device_doepctl2_set_eptyp(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DOEPCTL2 = (p->DOEPCTL2 & ~OTG_FS_DEVICE_DOEPCTL2_EPTYP) | ((val << 18) & OTG_FS_DEVICE_DOEPCTL2_EPTYP);
}
inline void otg_fs_device_doepctl2_set_mpsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DOEPCTL2 = (p->DOEPCTL2 & ~OTG_FS_DEVICE_DOEPCTL2_MPSIZ) | ((val << 0) & OTG_FS_DEVICE_DOEPCTL2_MPSIZ);
}
inline uint32_t otg_fs_device_doepctl2_get_eptyp(struct OTG_FS_DEVICE_Type* p) {
	return (p->DOEPCTL2 & OTG_FS_DEVICE_DOEPCTL2_EPTYP) >> 18;
}
inline uint32_t otg_fs_device_doepctl2_get_mpsiz(struct OTG_FS_DEVICE_Type* p) { return (p->DOEPCTL2 & OTG_FS_DEVICE_DOEPCTL2_MPSIZ) >> 0; }

// OTG_FS_DEVICE->DOEPINT2 device endpoint-2 interrupt register
enum {
	OTG_FS_DEVICE_DOEPINT2_B2BSTUP = 1UL << 6, // B2BSTUP
	OTG_FS_DEVICE_DOEPINT2_OTEPDIS = 1UL << 4, // OTEPDIS
	OTG_FS_DEVICE_DOEPINT2_STUP    = 1UL << 3, // STUP
	OTG_FS_DEVICE_DOEPINT2_EPDISD  = 1UL << 1, // EPDISD
	OTG_FS_DEVICE_DOEPINT2_XFRC    = 1UL << 0, // XFRC
};

// OTG_FS_DEVICE->DOEPTSIZ2 device OUT endpoint-2 transfer size register
enum {
	OTG_FS_DEVICE_DOEPTSIZ2_RXDPID_STUPCNT = ((1UL << 2) - 1) << 29,  // Received data PID/SETUP packet count
	OTG_FS_DEVICE_DOEPTSIZ2_PKTCNT         = ((1UL << 10) - 1) << 19, // Packet count
	OTG_FS_DEVICE_DOEPTSIZ2_XFRSIZ         = ((1UL << 19) - 1) << 0,  // Transfer size
};
inline void otg_fs_device_doeptsiz2_set_rxdpid_stupcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DOEPTSIZ2 = (p->DOEPTSIZ2 & ~OTG_FS_DEVICE_DOEPTSIZ2_RXDPID_STUPCNT) | ((val << 29) & OTG_FS_DEVICE_DOEPTSIZ2_RXDPID_STUPCNT);
}
inline void otg_fs_device_doeptsiz2_set_pktcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DOEPTSIZ2 = (p->DOEPTSIZ2 & ~OTG_FS_DEVICE_DOEPTSIZ2_PKTCNT) | ((val << 19) & OTG_FS_DEVICE_DOEPTSIZ2_PKTCNT);
}
inline void otg_fs_device_doeptsiz2_set_xfrsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DOEPTSIZ2 = (p->DOEPTSIZ2 & ~OTG_FS_DEVICE_DOEPTSIZ2_XFRSIZ) | ((val << 0) & OTG_FS_DEVICE_DOEPTSIZ2_XFRSIZ);
}
inline uint32_t otg_fs_device_doeptsiz2_get_rxdpid_stupcnt(struct OTG_FS_DEVICE_Type* p) {
	return (p->DOEPTSIZ2 & OTG_FS_DEVICE_DOEPTSIZ2_RXDPID_STUPCNT) >> 29;
}
inline uint32_t otg_fs_device_doeptsiz2_get_pktcnt(struct OTG_FS_DEVICE_Type* p) {
	return (p->DOEPTSIZ2 & OTG_FS_DEVICE_DOEPTSIZ2_PKTCNT) >> 19;
}
inline uint32_t otg_fs_device_doeptsiz2_get_xfrsiz(struct OTG_FS_DEVICE_Type* p) {
	return (p->DOEPTSIZ2 & OTG_FS_DEVICE_DOEPTSIZ2_XFRSIZ) >> 0;
}

// OTG_FS_DEVICE->DOEPCTL3 device endpoint-3 control register
enum {
	OTG_FS_DEVICE_DOEPCTL3_EPENA          = 1UL << 31,              // EPENA
	OTG_FS_DEVICE_DOEPCTL3_EPDIS          = 1UL << 30,              // EPDIS
	OTG_FS_DEVICE_DOEPCTL3_SODDFRM        = 1UL << 29,              // SODDFRM
	OTG_FS_DEVICE_DOEPCTL3_SD0PID_SEVNFRM = 1UL << 28,              // SD0PID/SEVNFRM
	OTG_FS_DEVICE_DOEPCTL3_SNAK           = 1UL << 27,              // SNAK
	OTG_FS_DEVICE_DOEPCTL3_CNAK           = 1UL << 26,              // CNAK
	OTG_FS_DEVICE_DOEPCTL3_STALL          = 1UL << 21,              // Stall
	OTG_FS_DEVICE_DOEPCTL3_SNPM           = 1UL << 20,              // SNPM
	OTG_FS_DEVICE_DOEPCTL3_EPTYP          = ((1UL << 2) - 1) << 18, // EPTYP
	OTG_FS_DEVICE_DOEPCTL3_NAKSTS         = 1UL << 17,              // NAKSTS
	OTG_FS_DEVICE_DOEPCTL3_EONUM_DPID     = 1UL << 16,              // EONUM/DPID
	OTG_FS_DEVICE_DOEPCTL3_USBAEP         = 1UL << 15,              // USBAEP
	OTG_FS_DEVICE_DOEPCTL3_MPSIZ          = ((1UL << 11) - 1) << 0, // MPSIZ
};
inline void otg_fs_device_doepctl3_set_eptyp(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DOEPCTL3 = (p->DOEPCTL3 & ~OTG_FS_DEVICE_DOEPCTL3_EPTYP) | ((val << 18) & OTG_FS_DEVICE_DOEPCTL3_EPTYP);
}
inline void otg_fs_device_doepctl3_set_mpsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DOEPCTL3 = (p->DOEPCTL3 & ~OTG_FS_DEVICE_DOEPCTL3_MPSIZ) | ((val << 0) & OTG_FS_DEVICE_DOEPCTL3_MPSIZ);
}
inline uint32_t otg_fs_device_doepctl3_get_eptyp(struct OTG_FS_DEVICE_Type* p) {
	return (p->DOEPCTL3 & OTG_FS_DEVICE_DOEPCTL3_EPTYP) >> 18;
}
inline uint32_t otg_fs_device_doepctl3_get_mpsiz(struct OTG_FS_DEVICE_Type* p) { return (p->DOEPCTL3 & OTG_FS_DEVICE_DOEPCTL3_MPSIZ) >> 0; }

// OTG_FS_DEVICE->DOEPINT3 device endpoint-3 interrupt register
enum {
	OTG_FS_DEVICE_DOEPINT3_B2BSTUP = 1UL << 6, // B2BSTUP
	OTG_FS_DEVICE_DOEPINT3_OTEPDIS = 1UL << 4, // OTEPDIS
	OTG_FS_DEVICE_DOEPINT3_STUP    = 1UL << 3, // STUP
	OTG_FS_DEVICE_DOEPINT3_EPDISD  = 1UL << 1, // EPDISD
	OTG_FS_DEVICE_DOEPINT3_XFRC    = 1UL << 0, // XFRC
};

// OTG_FS_DEVICE->DOEPTSIZ3 device OUT endpoint-3 transfer size register
enum {
	OTG_FS_DEVICE_DOEPTSIZ3_RXDPID_STUPCNT = ((1UL << 2) - 1) << 29,  // Received data PID/SETUP packet count
	OTG_FS_DEVICE_DOEPTSIZ3_PKTCNT         = ((1UL << 10) - 1) << 19, // Packet count
	OTG_FS_DEVICE_DOEPTSIZ3_XFRSIZ         = ((1UL << 19) - 1) << 0,  // Transfer size
};
inline void otg_fs_device_doeptsiz3_set_rxdpid_stupcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DOEPTSIZ3 = (p->DOEPTSIZ3 & ~OTG_FS_DEVICE_DOEPTSIZ3_RXDPID_STUPCNT) | ((val << 29) & OTG_FS_DEVICE_DOEPTSIZ3_RXDPID_STUPCNT);
}
inline void otg_fs_device_doeptsiz3_set_pktcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DOEPTSIZ3 = (p->DOEPTSIZ3 & ~OTG_FS_DEVICE_DOEPTSIZ3_PKTCNT) | ((val << 19) & OTG_FS_DEVICE_DOEPTSIZ3_PKTCNT);
}
inline void otg_fs_device_doeptsiz3_set_xfrsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) {
	p->DOEPTSIZ3 = (p->DOEPTSIZ3 & ~OTG_FS_DEVICE_DOEPTSIZ3_XFRSIZ) | ((val << 0) & OTG_FS_DEVICE_DOEPTSIZ3_XFRSIZ);
}
inline uint32_t otg_fs_device_doeptsiz3_get_rxdpid_stupcnt(struct OTG_FS_DEVICE_Type* p) {
	return (p->DOEPTSIZ3 & OTG_FS_DEVICE_DOEPTSIZ3_RXDPID_STUPCNT) >> 29;
}
inline uint32_t otg_fs_device_doeptsiz3_get_pktcnt(struct OTG_FS_DEVICE_Type* p) {
	return (p->DOEPTSIZ3 & OTG_FS_DEVICE_DOEPTSIZ3_PKTCNT) >> 19;
}
inline uint32_t otg_fs_device_doeptsiz3_get_xfrsiz(struct OTG_FS_DEVICE_Type* p) {
	return (p->DOEPTSIZ3 & OTG_FS_DEVICE_DOEPTSIZ3_XFRSIZ) >> 0;
}

/* USB on the go full speed */
struct OTG_FS_GLOBAL_Type {
	__IO uint32_t FS_GOTGCTL;           // @0 OTG_FS control and status register (OTG_FS_GOTGCTL)
	__IO uint32_t FS_GOTGINT;           // @4 OTG_FS interrupt register (OTG_FS_GOTGINT)
	__IO uint16_t FS_GAHBCFG;           // @8 OTG_FS AHB configuration register (OTG_FS_GAHBCFG)
	uint8_t       RESERVED0[2];         // @10
	__IO uint32_t FS_GUSBCFG;           // @12 OTG_FS USB configuration register (OTG_FS_GUSBCFG)
	__IO uint32_t FS_GRSTCTL;           // @16 OTG_FS reset register (OTG_FS_GRSTCTL)
	__IO uint32_t FS_GINTSTS;           // @20 OTG_FS core interrupt register (OTG_FS_GINTSTS)
	__IO uint32_t FS_GINTMSK;           // @24 OTG_FS interrupt mask register (OTG_FS_GINTMSK)
	union {                             // @28
		__I uint32_t FS_GRXSTSR_Device; // OTG_FS Receive status debug read(Device mode)
		__I uint32_t FS_GRXSTSR_Host;   // OTG_FS Receive status debug read(Host mode)
	};
	uint8_t RESERVED1[4];                  // @32
	__IO uint16_t FS_GRXFSIZ;              // @36 OTG_FS Receive FIFO size register (OTG_FS_GRXFSIZ)
	uint8_t       RESERVED2[2];            // @38
	union {                                // @40
		__IO uint32_t FS_GNPTXFSIZ_Device; // OTG_FS non-periodic transmit FIFO size register (Device mode)
		__IO uint32_t FS_GNPTXFSIZ_Host;   // OTG_FS non-periodic transmit FIFO size register (Host mode)
	};
	__I uint32_t FS_GNPTXSTS;     // @44 OTG_FS non-periodic transmit FIFO/queue status register (OTG_FS_GNPTXSTS)
	uint8_t      RESERVED3[8];    // @48
	__IO uint32_t FS_GCCFG;       // @56 OTG_FS general core configuration register (OTG_FS_GCCFG)
	__IO uint32_t FS_CID;         // @60 core ID register
	uint8_t       RESERVED4[192]; // @64
	__IO uint32_t FS_HPTXFSIZ;    // @256 OTG_FS Host periodic transmit FIFO size register (OTG_FS_HPTXFSIZ)
	__IO uint32_t FS_DIEPTXF1;    // @260 OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF2)
	__IO uint32_t FS_DIEPTXF2;    // @264 OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF3)
	__IO uint32_t FS_DIEPTXF3;    // @268 OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF4)
};

// OTG_FS_GLOBAL->FS_GOTGCTL OTG_FS control and status register (OTG_FS_GOTGCTL)
enum {
	OTG_FS_GLOBAL_FS_GOTGCTL_BSVLD   = 1UL << 19, // B-session valid
	OTG_FS_GLOBAL_FS_GOTGCTL_ASVLD   = 1UL << 18, // A-session valid
	OTG_FS_GLOBAL_FS_GOTGCTL_DBCT    = 1UL << 17, // Long/short debounce time
	OTG_FS_GLOBAL_FS_GOTGCTL_CIDSTS  = 1UL << 16, // Connector ID status
	OTG_FS_GLOBAL_FS_GOTGCTL_DHNPEN  = 1UL << 11, // Device HNP enabled
	OTG_FS_GLOBAL_FS_GOTGCTL_HSHNPEN = 1UL << 10, // Host set HNP enable
	OTG_FS_GLOBAL_FS_GOTGCTL_HNPRQ   = 1UL << 9,  // HNP request
	OTG_FS_GLOBAL_FS_GOTGCTL_HNGSCS  = 1UL << 8,  // Host negotiation success
	OTG_FS_GLOBAL_FS_GOTGCTL_SRQ     = 1UL << 1,  // Session request
	OTG_FS_GLOBAL_FS_GOTGCTL_SRQSCS  = 1UL << 0,  // Session request success
};

// OTG_FS_GLOBAL->FS_GOTGINT OTG_FS interrupt register (OTG_FS_GOTGINT)
enum {
	OTG_FS_GLOBAL_FS_GOTGINT_DBCDNE  = 1UL << 19, // Debounce done
	OTG_FS_GLOBAL_FS_GOTGINT_ADTOCHG = 1UL << 18, // A-device timeout change
	OTG_FS_GLOBAL_FS_GOTGINT_HNGDET  = 1UL << 17, // Host negotiation detected
	OTG_FS_GLOBAL_FS_GOTGINT_HNSSCHG = 1UL << 9,  // Host negotiation success status change
	OTG_FS_GLOBAL_FS_GOTGINT_SRSSCHG = 1UL << 8,  // Session request success status change
	OTG_FS_GLOBAL_FS_GOTGINT_SEDET   = 1UL << 2,  // Session end detected
};

// OTG_FS_GLOBAL->FS_GAHBCFG OTG_FS AHB configuration register (OTG_FS_GAHBCFG)
enum {
	OTG_FS_GLOBAL_FS_GAHBCFG_PTXFELVL = 1UL << 8, // Periodic TxFIFO empty level
	OTG_FS_GLOBAL_FS_GAHBCFG_TXFELVL  = 1UL << 7, // TxFIFO empty level
	OTG_FS_GLOBAL_FS_GAHBCFG_GINT     = 1UL << 0, // Global interrupt mask
};

// OTG_FS_GLOBAL->FS_GUSBCFG OTG_FS USB configuration register (OTG_FS_GUSBCFG)
enum {
	OTG_FS_GLOBAL_FS_GUSBCFG_CTXPKT = 1UL << 31,              // Corrupt Tx packet
	OTG_FS_GLOBAL_FS_GUSBCFG_FDMOD  = 1UL << 30,              // Force device mode
	OTG_FS_GLOBAL_FS_GUSBCFG_FHMOD  = 1UL << 29,              // Force host mode
	OTG_FS_GLOBAL_FS_GUSBCFG_TRDT   = ((1UL << 4) - 1) << 10, // USB turnaround time
	OTG_FS_GLOBAL_FS_GUSBCFG_HNPCAP = 1UL << 9,               // HNP-capable
	OTG_FS_GLOBAL_FS_GUSBCFG_SRPCAP = 1UL << 8,               // SRP-capable
	OTG_FS_GLOBAL_FS_GUSBCFG_PHYSEL = 1UL << 6,               // Full Speed serial transceiver select
	OTG_FS_GLOBAL_FS_GUSBCFG_TOCAL  = ((1UL << 3) - 1) << 0,  // FS timeout calibration
};
inline void otg_fs_global_fs_gusbcfg_set_trdt(struct OTG_FS_GLOBAL_Type* p, uint32_t val) {
	p->FS_GUSBCFG = (p->FS_GUSBCFG & ~OTG_FS_GLOBAL_FS_GUSBCFG_TRDT) | ((val << 10) & OTG_FS_GLOBAL_FS_GUSBCFG_TRDT);
}
inline void otg_fs_global_fs_gusbcfg_set_tocal(struct OTG_FS_GLOBAL_Type* p, uint32_t val) {
	p->FS_GUSBCFG = (p->FS_GUSBCFG & ~OTG_FS_GLOBAL_FS_GUSBCFG_TOCAL) | ((val << 0) & OTG_FS_GLOBAL_FS_GUSBCFG_TOCAL);
}
inline uint32_t otg_fs_global_fs_gusbcfg_get_trdt(struct OTG_FS_GLOBAL_Type* p) {
	return (p->FS_GUSBCFG & OTG_FS_GLOBAL_FS_GUSBCFG_TRDT) >> 10;
}
inline uint32_t otg_fs_global_fs_gusbcfg_get_tocal(struct OTG_FS_GLOBAL_Type* p) {
	return (p->FS_GUSBCFG & OTG_FS_GLOBAL_FS_GUSBCFG_TOCAL) >> 0;
}

// OTG_FS_GLOBAL->FS_GRSTCTL OTG_FS reset register (OTG_FS_GRSTCTL)
enum {
	OTG_FS_GLOBAL_FS_GRSTCTL_AHBIDL  = 1UL << 31,             // AHB master idle
	OTG_FS_GLOBAL_FS_GRSTCTL_TXFNUM  = ((1UL << 5) - 1) << 6, // TxFIFO number
	OTG_FS_GLOBAL_FS_GRSTCTL_TXFFLSH = 1UL << 5,              // TxFIFO flush
	OTG_FS_GLOBAL_FS_GRSTCTL_RXFFLSH = 1UL << 4,              // RxFIFO flush
	OTG_FS_GLOBAL_FS_GRSTCTL_FCRST   = 1UL << 2,              // Host frame counter reset
	OTG_FS_GLOBAL_FS_GRSTCTL_HSRST   = 1UL << 1,              // HCLK soft reset
	OTG_FS_GLOBAL_FS_GRSTCTL_CSRST   = 1UL << 0,              // Core soft reset
};
inline void otg_fs_global_fs_grstctl_set_txfnum(struct OTG_FS_GLOBAL_Type* p, uint32_t val) {
	p->FS_GRSTCTL = (p->FS_GRSTCTL & ~OTG_FS_GLOBAL_FS_GRSTCTL_TXFNUM) | ((val << 6) & OTG_FS_GLOBAL_FS_GRSTCTL_TXFNUM);
}
inline uint32_t otg_fs_global_fs_grstctl_get_txfnum(struct OTG_FS_GLOBAL_Type* p) {
	return (p->FS_GRSTCTL & OTG_FS_GLOBAL_FS_GRSTCTL_TXFNUM) >> 6;
}

// OTG_FS_GLOBAL->FS_GINTSTS OTG_FS core interrupt register (OTG_FS_GINTSTS)
enum {
	OTG_FS_GLOBAL_FS_GINTSTS_WKUPINT = 1UL << 31, // Resume/remote wakeup detected interrupt
	OTG_FS_GLOBAL_FS_GINTSTS_SRQINT  = 1UL << 30, // Session request/new session detected interrupt
	OTG_FS_GLOBAL_FS_GINTSTS_DISCINT = 1UL << 29, // Disconnect detected interrupt
	OTG_FS_GLOBAL_FS_GINTSTS_CIDSCHG = 1UL << 28, // Connector ID status change
	OTG_FS_GLOBAL_FS_GINTSTS_PTXFE   = 1UL << 26, // Periodic TxFIFO empty
	OTG_FS_GLOBAL_FS_GINTSTS_HCINT   = 1UL << 25, // Host channels interrupt
	OTG_FS_GLOBAL_FS_GINTSTS_HPRTINT = 1UL << 24, // Host port interrupt
	OTG_FS_GLOBAL_FS_GINTSTS_IPXFR_INCOMPISOOUT =
	    1UL << 21, // Incomplete periodic transfer(Host mode)/Incomplete isochronous OUT transfer(Device mode)
	OTG_FS_GLOBAL_FS_GINTSTS_IISOIXFR   = 1UL << 20, // Incomplete isochronous IN transfer
	OTG_FS_GLOBAL_FS_GINTSTS_OEPINT     = 1UL << 19, // OUT endpoint interrupt
	OTG_FS_GLOBAL_FS_GINTSTS_IEPINT     = 1UL << 18, // IN endpoint interrupt
	OTG_FS_GLOBAL_FS_GINTSTS_EOPF       = 1UL << 15, // End of periodic frame interrupt
	OTG_FS_GLOBAL_FS_GINTSTS_ISOODRP    = 1UL << 14, // Isochronous OUT packet dropped interrupt
	OTG_FS_GLOBAL_FS_GINTSTS_ENUMDNE    = 1UL << 13, // Enumeration done
	OTG_FS_GLOBAL_FS_GINTSTS_USBRST     = 1UL << 12, // USB reset
	OTG_FS_GLOBAL_FS_GINTSTS_USBSUSP    = 1UL << 11, // USB suspend
	OTG_FS_GLOBAL_FS_GINTSTS_ESUSP      = 1UL << 10, // Early suspend
	OTG_FS_GLOBAL_FS_GINTSTS_GOUTNAKEFF = 1UL << 7,  // Global OUT NAK effective
	OTG_FS_GLOBAL_FS_GINTSTS_GINAKEFF   = 1UL << 6,  // Global IN non-periodic NAK effective
	OTG_FS_GLOBAL_FS_GINTSTS_NPTXFE     = 1UL << 5,  // Non-periodic TxFIFO empty
	OTG_FS_GLOBAL_FS_GINTSTS_RXFLVL     = 1UL << 4,  // RxFIFO non-empty
	OTG_FS_GLOBAL_FS_GINTSTS_SOF        = 1UL << 3,  // Start of frame
	OTG_FS_GLOBAL_FS_GINTSTS_OTGINT     = 1UL << 2,  // OTG interrupt
	OTG_FS_GLOBAL_FS_GINTSTS_MMIS       = 1UL << 1,  // Mode mismatch interrupt
	OTG_FS_GLOBAL_FS_GINTSTS_CMOD       = 1UL << 0,  // Current mode of operation
};

// OTG_FS_GLOBAL->FS_GINTMSK OTG_FS interrupt mask register (OTG_FS_GINTMSK)
enum {
	OTG_FS_GLOBAL_FS_GINTMSK_WUIM     = 1UL << 31, // Resume/remote wakeup detected interrupt mask
	OTG_FS_GLOBAL_FS_GINTMSK_SRQIM    = 1UL << 30, // Session request/new session detected interrupt mask
	OTG_FS_GLOBAL_FS_GINTMSK_DISCINT  = 1UL << 29, // Disconnect detected interrupt mask
	OTG_FS_GLOBAL_FS_GINTMSK_CIDSCHGM = 1UL << 28, // Connector ID status change mask
	OTG_FS_GLOBAL_FS_GINTMSK_PTXFEM   = 1UL << 26, // Periodic TxFIFO empty mask
	OTG_FS_GLOBAL_FS_GINTMSK_HCIM     = 1UL << 25, // Host channels interrupt mask
	OTG_FS_GLOBAL_FS_GINTMSK_PRTIM    = 1UL << 24, // Host port interrupt mask
	OTG_FS_GLOBAL_FS_GINTMSK_IPXFRM_IISOOXFRM =
	    1UL << 21, // Incomplete periodic transfer mask(Host mode)/Incomplete isochronous OUT transfer mask(Device mode)
	OTG_FS_GLOBAL_FS_GINTMSK_IISOIXFRM = 1UL << 20, // Incomplete isochronous IN transfer mask
	OTG_FS_GLOBAL_FS_GINTMSK_OEPINT    = 1UL << 19, // OUT endpoints interrupt mask
	OTG_FS_GLOBAL_FS_GINTMSK_IEPINT    = 1UL << 18, // IN endpoints interrupt mask
	OTG_FS_GLOBAL_FS_GINTMSK_EPMISM    = 1UL << 17, // Endpoint mismatch interrupt mask
	OTG_FS_GLOBAL_FS_GINTMSK_EOPFM     = 1UL << 15, // End of periodic frame interrupt mask
	OTG_FS_GLOBAL_FS_GINTMSK_ISOODRPM  = 1UL << 14, // Isochronous OUT packet dropped interrupt mask
	OTG_FS_GLOBAL_FS_GINTMSK_ENUMDNEM  = 1UL << 13, // Enumeration done mask
	OTG_FS_GLOBAL_FS_GINTMSK_USBRST    = 1UL << 12, // USB reset mask
	OTG_FS_GLOBAL_FS_GINTMSK_USBSUSPM  = 1UL << 11, // USB suspend mask
	OTG_FS_GLOBAL_FS_GINTMSK_ESUSPM    = 1UL << 10, // Early suspend mask
	OTG_FS_GLOBAL_FS_GINTMSK_GONAKEFFM = 1UL << 7,  // Global OUT NAK effective mask
	OTG_FS_GLOBAL_FS_GINTMSK_GINAKEFFM = 1UL << 6,  // Global non-periodic IN NAK effective mask
	OTG_FS_GLOBAL_FS_GINTMSK_NPTXFEM   = 1UL << 5,  // Non-periodic TxFIFO empty mask
	OTG_FS_GLOBAL_FS_GINTMSK_RXFLVLM   = 1UL << 4,  // Receive FIFO non-empty mask
	OTG_FS_GLOBAL_FS_GINTMSK_SOFM      = 1UL << 3,  // Start of frame mask
	OTG_FS_GLOBAL_FS_GINTMSK_OTGINT    = 1UL << 2,  // OTG interrupt mask
	OTG_FS_GLOBAL_FS_GINTMSK_MMISM     = 1UL << 1,  // Mode mismatch interrupt mask
};

// OTG_FS_GLOBAL->FS_GRXSTSR_Device OTG_FS Receive status debug read(Device mode)
enum {
	OTG_FS_GLOBAL_FS_GRXSTSR_DEVICE_FRMNUM = ((1UL << 4) - 1) << 21, // Frame number
	OTG_FS_GLOBAL_FS_GRXSTSR_DEVICE_PKTSTS = ((1UL << 4) - 1) << 17, // Packet status
	OTG_FS_GLOBAL_FS_GRXSTSR_DEVICE_DPID   = ((1UL << 2) - 1) << 15, // Data PID
	OTG_FS_GLOBAL_FS_GRXSTSR_DEVICE_BCNT   = ((1UL << 11) - 1) << 4, // Byte count
	OTG_FS_GLOBAL_FS_GRXSTSR_DEVICE_EPNUM  = ((1UL << 4) - 1) << 0,  // Endpoint number
};
inline uint32_t otg_fs_global_fs_grxstsr_device_get_frmnum(struct OTG_FS_GLOBAL_Type* p) {
	return (p->FS_GRXSTSR_Device & OTG_FS_GLOBAL_FS_GRXSTSR_DEVICE_FRMNUM) >> 21;
}
inline uint32_t otg_fs_global_fs_grxstsr_device_get_pktsts(struct OTG_FS_GLOBAL_Type* p) {
	return (p->FS_GRXSTSR_Device & OTG_FS_GLOBAL_FS_GRXSTSR_DEVICE_PKTSTS) >> 17;
}
inline uint32_t otg_fs_global_fs_grxstsr_device_get_dpid(struct OTG_FS_GLOBAL_Type* p) {
	return (p->FS_GRXSTSR_Device & OTG_FS_GLOBAL_FS_GRXSTSR_DEVICE_DPID) >> 15;
}
inline uint32_t otg_fs_global_fs_grxstsr_device_get_bcnt(struct OTG_FS_GLOBAL_Type* p) {
	return (p->FS_GRXSTSR_Device & OTG_FS_GLOBAL_FS_GRXSTSR_DEVICE_BCNT) >> 4;
}
inline uint32_t otg_fs_global_fs_grxstsr_device_get_epnum(struct OTG_FS_GLOBAL_Type* p) {
	return (p->FS_GRXSTSR_Device & OTG_FS_GLOBAL_FS_GRXSTSR_DEVICE_EPNUM) >> 0;
}

// OTG_FS_GLOBAL->FS_GNPTXFSIZ_Device OTG_FS non-periodic transmit FIFO size register (Device mode)
enum {
	OTG_FS_GLOBAL_FS_GNPTXFSIZ_DEVICE_TX0FD  = ((1UL << 16) - 1) << 16, // Endpoint 0 TxFIFO depth
	OTG_FS_GLOBAL_FS_GNPTXFSIZ_DEVICE_TX0FSA = ((1UL << 16) - 1) << 0,  // Endpoint 0 transmit RAM start address
};
inline void otg_fs_global_fs_gnptxfsiz_device_set_tx0fd(struct OTG_FS_GLOBAL_Type* p, uint32_t val) {
	p->FS_GNPTXFSIZ_Device =
	    (p->FS_GNPTXFSIZ_Device & ~OTG_FS_GLOBAL_FS_GNPTXFSIZ_DEVICE_TX0FD) | ((val << 16) & OTG_FS_GLOBAL_FS_GNPTXFSIZ_DEVICE_TX0FD);
}
inline void otg_fs_global_fs_gnptxfsiz_device_set_tx0fsa(struct OTG_FS_GLOBAL_Type* p, uint32_t val) {
	p->FS_GNPTXFSIZ_Device =
	    (p->FS_GNPTXFSIZ_Device & ~OTG_FS_GLOBAL_FS_GNPTXFSIZ_DEVICE_TX0FSA) | ((val << 0) & OTG_FS_GLOBAL_FS_GNPTXFSIZ_DEVICE_TX0FSA);
}
inline uint32_t otg_fs_global_fs_gnptxfsiz_device_get_tx0fd(struct OTG_FS_GLOBAL_Type* p) {
	return (p->FS_GNPTXFSIZ_Device & OTG_FS_GLOBAL_FS_GNPTXFSIZ_DEVICE_TX0FD) >> 16;
}
inline uint32_t otg_fs_global_fs_gnptxfsiz_device_get_tx0fsa(struct OTG_FS_GLOBAL_Type* p) {
	return (p->FS_GNPTXFSIZ_Device & OTG_FS_GLOBAL_FS_GNPTXFSIZ_DEVICE_TX0FSA) >> 0;
}

// OTG_FS_GLOBAL->FS_GNPTXSTS OTG_FS non-periodic transmit FIFO/queue status register (OTG_FS_GNPTXSTS)
enum {
	OTG_FS_GLOBAL_FS_GNPTXSTS_NPTXQTOP = ((1UL << 7) - 1) << 24, // Top of the non-periodic transmit request queue
	OTG_FS_GLOBAL_FS_GNPTXSTS_NPTQXSAV = ((1UL << 8) - 1) << 16, // Non-periodic transmit request queue space available
	OTG_FS_GLOBAL_FS_GNPTXSTS_NPTXFSAV = ((1UL << 16) - 1) << 0, // Non-periodic TxFIFO space available
};
inline uint32_t otg_fs_global_fs_gnptxsts_get_nptxqtop(struct OTG_FS_GLOBAL_Type* p) {
	return (p->FS_GNPTXSTS & OTG_FS_GLOBAL_FS_GNPTXSTS_NPTXQTOP) >> 24;
}
inline uint32_t otg_fs_global_fs_gnptxsts_get_nptqxsav(struct OTG_FS_GLOBAL_Type* p) {
	return (p->FS_GNPTXSTS & OTG_FS_GLOBAL_FS_GNPTXSTS_NPTQXSAV) >> 16;
}
inline uint32_t otg_fs_global_fs_gnptxsts_get_nptxfsav(struct OTG_FS_GLOBAL_Type* p) {
	return (p->FS_GNPTXSTS & OTG_FS_GLOBAL_FS_GNPTXSTS_NPTXFSAV) >> 0;
}

// OTG_FS_GLOBAL->FS_GCCFG OTG_FS general core configuration register (OTG_FS_GCCFG)
enum {
	OTG_FS_GLOBAL_FS_GCCFG_SOFOUTEN = 1UL << 20, // SOF output enable
	OTG_FS_GLOBAL_FS_GCCFG_VBUSBSEN = 1UL << 19, // Enable the VBUS sensing device
	OTG_FS_GLOBAL_FS_GCCFG_VBUSASEN = 1UL << 18, // Enable the VBUS sensing device
	OTG_FS_GLOBAL_FS_GCCFG_PWRDWN   = 1UL << 16, // Power down
};

// OTG_FS_GLOBAL->FS_HPTXFSIZ OTG_FS Host periodic transmit FIFO size register (OTG_FS_HPTXFSIZ)
enum {
	OTG_FS_GLOBAL_FS_HPTXFSIZ_PTXFSIZ = ((1UL << 16) - 1) << 16, // Host periodic TxFIFO depth
	OTG_FS_GLOBAL_FS_HPTXFSIZ_PTXSA   = ((1UL << 16) - 1) << 0,  // Host periodic TxFIFO start address
};
inline void otg_fs_global_fs_hptxfsiz_set_ptxfsiz(struct OTG_FS_GLOBAL_Type* p, uint32_t val) {
	p->FS_HPTXFSIZ = (p->FS_HPTXFSIZ & ~OTG_FS_GLOBAL_FS_HPTXFSIZ_PTXFSIZ) | ((val << 16) & OTG_FS_GLOBAL_FS_HPTXFSIZ_PTXFSIZ);
}
inline void otg_fs_global_fs_hptxfsiz_set_ptxsa(struct OTG_FS_GLOBAL_Type* p, uint32_t val) {
	p->FS_HPTXFSIZ = (p->FS_HPTXFSIZ & ~OTG_FS_GLOBAL_FS_HPTXFSIZ_PTXSA) | ((val << 0) & OTG_FS_GLOBAL_FS_HPTXFSIZ_PTXSA);
}
inline uint32_t otg_fs_global_fs_hptxfsiz_get_ptxfsiz(struct OTG_FS_GLOBAL_Type* p) {
	return (p->FS_HPTXFSIZ & OTG_FS_GLOBAL_FS_HPTXFSIZ_PTXFSIZ) >> 16;
}
inline uint32_t otg_fs_global_fs_hptxfsiz_get_ptxsa(struct OTG_FS_GLOBAL_Type* p) {
	return (p->FS_HPTXFSIZ & OTG_FS_GLOBAL_FS_HPTXFSIZ_PTXSA) >> 0;
}

// OTG_FS_GLOBAL->FS_DIEPTXF1 OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF2)
enum {
	OTG_FS_GLOBAL_FS_DIEPTXF1_INEPTXFD = ((1UL << 16) - 1) << 16, // IN endpoint TxFIFO depth
	OTG_FS_GLOBAL_FS_DIEPTXF1_INEPTXSA = ((1UL << 16) - 1) << 0,  // IN endpoint FIFO2 transmit RAM start address
};
inline void otg_fs_global_fs_dieptxf1_set_ineptxfd(struct OTG_FS_GLOBAL_Type* p, uint32_t val) {
	p->FS_DIEPTXF1 = (p->FS_DIEPTXF1 & ~OTG_FS_GLOBAL_FS_DIEPTXF1_INEPTXFD) | ((val << 16) & OTG_FS_GLOBAL_FS_DIEPTXF1_INEPTXFD);
}
inline void otg_fs_global_fs_dieptxf1_set_ineptxsa(struct OTG_FS_GLOBAL_Type* p, uint32_t val) {
	p->FS_DIEPTXF1 = (p->FS_DIEPTXF1 & ~OTG_FS_GLOBAL_FS_DIEPTXF1_INEPTXSA) | ((val << 0) & OTG_FS_GLOBAL_FS_DIEPTXF1_INEPTXSA);
}
inline uint32_t otg_fs_global_fs_dieptxf1_get_ineptxfd(struct OTG_FS_GLOBAL_Type* p) {
	return (p->FS_DIEPTXF1 & OTG_FS_GLOBAL_FS_DIEPTXF1_INEPTXFD) >> 16;
}
inline uint32_t otg_fs_global_fs_dieptxf1_get_ineptxsa(struct OTG_FS_GLOBAL_Type* p) {
	return (p->FS_DIEPTXF1 & OTG_FS_GLOBAL_FS_DIEPTXF1_INEPTXSA) >> 0;
}

// OTG_FS_GLOBAL->FS_DIEPTXF2 OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF3)
enum {
	OTG_FS_GLOBAL_FS_DIEPTXF2_INEPTXFD = ((1UL << 16) - 1) << 16, // IN endpoint TxFIFO depth
	OTG_FS_GLOBAL_FS_DIEPTXF2_INEPTXSA = ((1UL << 16) - 1) << 0,  // IN endpoint FIFO3 transmit RAM start address
};
inline void otg_fs_global_fs_dieptxf2_set_ineptxfd(struct OTG_FS_GLOBAL_Type* p, uint32_t val) {
	p->FS_DIEPTXF2 = (p->FS_DIEPTXF2 & ~OTG_FS_GLOBAL_FS_DIEPTXF2_INEPTXFD) | ((val << 16) & OTG_FS_GLOBAL_FS_DIEPTXF2_INEPTXFD);
}
inline void otg_fs_global_fs_dieptxf2_set_ineptxsa(struct OTG_FS_GLOBAL_Type* p, uint32_t val) {
	p->FS_DIEPTXF2 = (p->FS_DIEPTXF2 & ~OTG_FS_GLOBAL_FS_DIEPTXF2_INEPTXSA) | ((val << 0) & OTG_FS_GLOBAL_FS_DIEPTXF2_INEPTXSA);
}
inline uint32_t otg_fs_global_fs_dieptxf2_get_ineptxfd(struct OTG_FS_GLOBAL_Type* p) {
	return (p->FS_DIEPTXF2 & OTG_FS_GLOBAL_FS_DIEPTXF2_INEPTXFD) >> 16;
}
inline uint32_t otg_fs_global_fs_dieptxf2_get_ineptxsa(struct OTG_FS_GLOBAL_Type* p) {
	return (p->FS_DIEPTXF2 & OTG_FS_GLOBAL_FS_DIEPTXF2_INEPTXSA) >> 0;
}

// OTG_FS_GLOBAL->FS_DIEPTXF3 OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF4)
enum {
	OTG_FS_GLOBAL_FS_DIEPTXF3_INEPTXFD = ((1UL << 16) - 1) << 16, // IN endpoint TxFIFO depth
	OTG_FS_GLOBAL_FS_DIEPTXF3_INEPTXSA = ((1UL << 16) - 1) << 0,  // IN endpoint FIFO4 transmit RAM start address
};
inline void otg_fs_global_fs_dieptxf3_set_ineptxfd(struct OTG_FS_GLOBAL_Type* p, uint32_t val) {
	p->FS_DIEPTXF3 = (p->FS_DIEPTXF3 & ~OTG_FS_GLOBAL_FS_DIEPTXF3_INEPTXFD) | ((val << 16) & OTG_FS_GLOBAL_FS_DIEPTXF3_INEPTXFD);
}
inline void otg_fs_global_fs_dieptxf3_set_ineptxsa(struct OTG_FS_GLOBAL_Type* p, uint32_t val) {
	p->FS_DIEPTXF3 = (p->FS_DIEPTXF3 & ~OTG_FS_GLOBAL_FS_DIEPTXF3_INEPTXSA) | ((val << 0) & OTG_FS_GLOBAL_FS_DIEPTXF3_INEPTXSA);
}
inline uint32_t otg_fs_global_fs_dieptxf3_get_ineptxfd(struct OTG_FS_GLOBAL_Type* p) {
	return (p->FS_DIEPTXF3 & OTG_FS_GLOBAL_FS_DIEPTXF3_INEPTXFD) >> 16;
}
inline uint32_t otg_fs_global_fs_dieptxf3_get_ineptxsa(struct OTG_FS_GLOBAL_Type* p) {
	return (p->FS_DIEPTXF3 & OTG_FS_GLOBAL_FS_DIEPTXF3_INEPTXSA) >> 0;
}

/* USB on the go full speed */
struct OTG_FS_HOST_Type {
	__IO uint8_t FS_HCFG;         // @0 OTG_FS host configuration register (OTG_FS_HCFG)
	uint8_t      RESERVED0[3];    // @1
	__IO uint16_t HFIR;           // @4 OTG_FS Host frame interval register
	uint8_t       RESERVED1[2];   // @6
	__I uint32_t FS_HFNUM;        // @8 OTG_FS host frame number/frame time remaining register (OTG_FS_HFNUM)
	uint8_t      RESERVED2[4];    // @12
	__IO uint32_t FS_HPTXSTS;     // @16 OTG_FS_Host periodic transmit FIFO/queue status register (OTG_FS_HPTXSTS)
	__I uint16_t HAINT;           // @20 OTG_FS Host all channels interrupt register
	uint8_t      RESERVED3[2];    // @22
	__IO uint16_t HAINTMSK;       // @24 OTG_FS host all channels interrupt mask register
	uint8_t       RESERVED4[38];  // @26
	__IO uint32_t FS_HPRT;        // @64 OTG_FS host port control and status register (OTG_FS_HPRT)
	uint8_t       RESERVED5[188]; // @68
	__IO uint32_t FS_HCCHAR0;     // @256 OTG_FS host channel-0 characteristics register (OTG_FS_HCCHAR0)
	uint8_t       RESERVED6[4];   // @260
	__IO uint16_t FS_HCINT0;      // @264 OTG_FS host channel-0 interrupt register (OTG_FS_HCINT0)
	uint8_t       RESERVED7[2];   // @266
	__IO uint16_t FS_HCINTMSK0;   // @268 OTG_FS host channel-0 mask register (OTG_FS_HCINTMSK0)
	uint8_t       RESERVED8[2];   // @270
	__IO uint32_t FS_HCTSIZ0;     // @272 OTG_FS host channel-0 transfer size register
	uint8_t       RESERVED9[12];  // @276
	__IO uint32_t FS_HCCHAR1;     // @288 OTG_FS host channel-1 characteristics register (OTG_FS_HCCHAR1)
	uint8_t       RESERVED10[4];  // @292
	__IO uint16_t FS_HCINT1;      // @296 OTG_FS host channel-1 interrupt register (OTG_FS_HCINT1)
	uint8_t       RESERVED11[2];  // @298
	__IO uint16_t FS_HCINTMSK1;   // @300 OTG_FS host channel-1 mask register (OTG_FS_HCINTMSK1)
	uint8_t       RESERVED12[2];  // @302
	__IO uint32_t FS_HCTSIZ1;     // @304 OTG_FS host channel-1 transfer size register
	uint8_t       RESERVED13[12]; // @308
	__IO uint32_t FS_HCCHAR2;     // @320 OTG_FS host channel-2 characteristics register (OTG_FS_HCCHAR2)
	uint8_t       RESERVED14[4];  // @324
	__IO uint16_t FS_HCINT2;      // @328 OTG_FS host channel-2 interrupt register (OTG_FS_HCINT2)
	uint8_t       RESERVED15[2];  // @330
	__IO uint16_t FS_HCINTMSK2;   // @332 OTG_FS host channel-2 mask register (OTG_FS_HCINTMSK2)
	uint8_t       RESERVED16[2];  // @334
	__IO uint32_t FS_HCTSIZ2;     // @336 OTG_FS host channel-2 transfer size register
	uint8_t       RESERVED17[12]; // @340
	__IO uint32_t FS_HCCHAR3;     // @352 OTG_FS host channel-3 characteristics register (OTG_FS_HCCHAR3)
	uint8_t       RESERVED18[4];  // @356
	__IO uint16_t FS_HCINT3;      // @360 OTG_FS host channel-3 interrupt register (OTG_FS_HCINT3)
	uint8_t       RESERVED19[2];  // @362
	__IO uint16_t FS_HCINTMSK3;   // @364 OTG_FS host channel-3 mask register (OTG_FS_HCINTMSK3)
	uint8_t       RESERVED20[2];  // @366
	__IO uint32_t FS_HCTSIZ3;     // @368 OTG_FS host channel-3 transfer size register
	uint8_t       RESERVED21[12]; // @372
	__IO uint32_t FS_HCCHAR4;     // @384 OTG_FS host channel-4 characteristics register (OTG_FS_HCCHAR4)
	uint8_t       RESERVED22[4];  // @388
	__IO uint16_t FS_HCINT4;      // @392 OTG_FS host channel-4 interrupt register (OTG_FS_HCINT4)
	uint8_t       RESERVED23[2];  // @394
	__IO uint16_t FS_HCINTMSK4;   // @396 OTG_FS host channel-4 mask register (OTG_FS_HCINTMSK4)
	uint8_t       RESERVED24[2];  // @398
	__IO uint32_t FS_HCTSIZ4;     // @400 OTG_FS host channel-x transfer size register
	uint8_t       RESERVED25[12]; // @404
	__IO uint32_t FS_HCCHAR5;     // @416 OTG_FS host channel-5 characteristics register (OTG_FS_HCCHAR5)
	uint8_t       RESERVED26[4];  // @420
	__IO uint16_t FS_HCINT5;      // @424 OTG_FS host channel-5 interrupt register (OTG_FS_HCINT5)
	uint8_t       RESERVED27[2];  // @426
	__IO uint16_t FS_HCINTMSK5;   // @428 OTG_FS host channel-5 mask register (OTG_FS_HCINTMSK5)
	uint8_t       RESERVED28[2];  // @430
	__IO uint32_t FS_HCTSIZ5;     // @432 OTG_FS host channel-5 transfer size register
	uint8_t       RESERVED29[12]; // @436
	__IO uint32_t FS_HCCHAR6;     // @448 OTG_FS host channel-6 characteristics register (OTG_FS_HCCHAR6)
	uint8_t       RESERVED30[4];  // @452
	__IO uint16_t FS_HCINT6;      // @456 OTG_FS host channel-6 interrupt register (OTG_FS_HCINT6)
	uint8_t       RESERVED31[2];  // @458
	__IO uint16_t FS_HCINTMSK6;   // @460 OTG_FS host channel-6 mask register (OTG_FS_HCINTMSK6)
	uint8_t       RESERVED32[2];  // @462
	__IO uint32_t FS_HCTSIZ6;     // @464 OTG_FS host channel-6 transfer size register
	uint8_t       RESERVED33[12]; // @468
	__IO uint32_t FS_HCCHAR7;     // @480 OTG_FS host channel-7 characteristics register (OTG_FS_HCCHAR7)
	uint8_t       RESERVED34[4];  // @484
	__IO uint16_t FS_HCINT7;      // @488 OTG_FS host channel-7 interrupt register (OTG_FS_HCINT7)
	uint8_t       RESERVED35[2];  // @490
	__IO uint16_t FS_HCINTMSK7;   // @492 OTG_FS host channel-7 mask register (OTG_FS_HCINTMSK7)
	uint8_t       RESERVED36[2];  // @494
	__IO uint32_t FS_HCTSIZ7;     // @496 OTG_FS host channel-7 transfer size register
};

// OTG_FS_HOST->FS_HCFG OTG_FS host configuration register (OTG_FS_HCFG)
enum {
	OTG_FS_HOST_FS_HCFG_FSLSS   = 1UL << 2,              // FS- and LS-only support
	OTG_FS_HOST_FS_HCFG_FSLSPCS = ((1UL << 2) - 1) << 0, // FS/LS PHY clock select
};
inline void otg_fs_host_fs_hcfg_set_fslspcs(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCFG = (p->FS_HCFG & ~OTG_FS_HOST_FS_HCFG_FSLSPCS) | ((val << 0) & OTG_FS_HOST_FS_HCFG_FSLSPCS);
}
inline uint32_t otg_fs_host_fs_hcfg_get_fslspcs(struct OTG_FS_HOST_Type* p) { return (p->FS_HCFG & OTG_FS_HOST_FS_HCFG_FSLSPCS) >> 0; }

// OTG_FS_HOST->FS_HFNUM OTG_FS host frame number/frame time remaining register (OTG_FS_HFNUM)
enum {
	OTG_FS_HOST_FS_HFNUM_FTREM = ((1UL << 16) - 1) << 16, // Frame time remaining
	OTG_FS_HOST_FS_HFNUM_FRNUM = ((1UL << 16) - 1) << 0,  // Frame number
};
inline uint32_t otg_fs_host_fs_hfnum_get_ftrem(struct OTG_FS_HOST_Type* p) { return (p->FS_HFNUM & OTG_FS_HOST_FS_HFNUM_FTREM) >> 16; }
inline uint32_t otg_fs_host_fs_hfnum_get_frnum(struct OTG_FS_HOST_Type* p) { return (p->FS_HFNUM & OTG_FS_HOST_FS_HFNUM_FRNUM) >> 0; }

// OTG_FS_HOST->FS_HPTXSTS OTG_FS_Host periodic transmit FIFO/queue status register (OTG_FS_HPTXSTS)
enum {
	OTG_FS_HOST_FS_HPTXSTS_PTXQTOP  = ((1UL << 8) - 1) << 24, // Top of the periodic transmit request queue
	OTG_FS_HOST_FS_HPTXSTS_PTXQSAV  = ((1UL << 8) - 1) << 16, // Periodic transmit request queue space available
	OTG_FS_HOST_FS_HPTXSTS_PTXFSAVL = ((1UL << 16) - 1) << 0, // Periodic transmit data FIFO space available
};
inline void otg_fs_host_fs_hptxsts_set_ptxqtop(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HPTXSTS = (p->FS_HPTXSTS & ~OTG_FS_HOST_FS_HPTXSTS_PTXQTOP) | ((val << 24) & OTG_FS_HOST_FS_HPTXSTS_PTXQTOP);
}
inline void otg_fs_host_fs_hptxsts_set_ptxqsav(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HPTXSTS = (p->FS_HPTXSTS & ~OTG_FS_HOST_FS_HPTXSTS_PTXQSAV) | ((val << 16) & OTG_FS_HOST_FS_HPTXSTS_PTXQSAV);
}
inline void otg_fs_host_fs_hptxsts_set_ptxfsavl(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HPTXSTS = (p->FS_HPTXSTS & ~OTG_FS_HOST_FS_HPTXSTS_PTXFSAVL) | ((val << 0) & OTG_FS_HOST_FS_HPTXSTS_PTXFSAVL);
}
inline uint32_t otg_fs_host_fs_hptxsts_get_ptxqtop(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HPTXSTS & OTG_FS_HOST_FS_HPTXSTS_PTXQTOP) >> 24;
}
inline uint32_t otg_fs_host_fs_hptxsts_get_ptxqsav(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HPTXSTS & OTG_FS_HOST_FS_HPTXSTS_PTXQSAV) >> 16;
}
inline uint32_t otg_fs_host_fs_hptxsts_get_ptxfsavl(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HPTXSTS & OTG_FS_HOST_FS_HPTXSTS_PTXFSAVL) >> 0;
}

// OTG_FS_HOST->FS_HPRT OTG_FS host port control and status register (OTG_FS_HPRT)
enum {
	OTG_FS_HOST_FS_HPRT_PSPD    = ((1UL << 2) - 1) << 17, // Port speed
	OTG_FS_HOST_FS_HPRT_PTCTL   = ((1UL << 4) - 1) << 13, // Port test control
	OTG_FS_HOST_FS_HPRT_PPWR    = 1UL << 12,              // Port power
	OTG_FS_HOST_FS_HPRT_PLSTS   = ((1UL << 2) - 1) << 10, // Port line status
	OTG_FS_HOST_FS_HPRT_PRST    = 1UL << 8,               // Port reset
	OTG_FS_HOST_FS_HPRT_PSUSP   = 1UL << 7,               // Port suspend
	OTG_FS_HOST_FS_HPRT_PRES    = 1UL << 6,               // Port resume
	OTG_FS_HOST_FS_HPRT_POCCHNG = 1UL << 5,               // Port overcurrent change
	OTG_FS_HOST_FS_HPRT_POCA    = 1UL << 4,               // Port overcurrent active
	OTG_FS_HOST_FS_HPRT_PENCHNG = 1UL << 3,               // Port enable/disable change
	OTG_FS_HOST_FS_HPRT_PENA    = 1UL << 2,               // Port enable
	OTG_FS_HOST_FS_HPRT_PCDET   = 1UL << 1,               // Port connect detected
	OTG_FS_HOST_FS_HPRT_PCSTS   = 1UL << 0,               // Port connect status
};
inline void otg_fs_host_fs_hprt_set_pspd(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HPRT = (p->FS_HPRT & ~OTG_FS_HOST_FS_HPRT_PSPD) | ((val << 17) & OTG_FS_HOST_FS_HPRT_PSPD);
}
inline void otg_fs_host_fs_hprt_set_ptctl(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HPRT = (p->FS_HPRT & ~OTG_FS_HOST_FS_HPRT_PTCTL) | ((val << 13) & OTG_FS_HOST_FS_HPRT_PTCTL);
}
inline void otg_fs_host_fs_hprt_set_plsts(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HPRT = (p->FS_HPRT & ~OTG_FS_HOST_FS_HPRT_PLSTS) | ((val << 10) & OTG_FS_HOST_FS_HPRT_PLSTS);
}
inline uint32_t otg_fs_host_fs_hprt_get_pspd(struct OTG_FS_HOST_Type* p) { return (p->FS_HPRT & OTG_FS_HOST_FS_HPRT_PSPD) >> 17; }
inline uint32_t otg_fs_host_fs_hprt_get_ptctl(struct OTG_FS_HOST_Type* p) { return (p->FS_HPRT & OTG_FS_HOST_FS_HPRT_PTCTL) >> 13; }
inline uint32_t otg_fs_host_fs_hprt_get_plsts(struct OTG_FS_HOST_Type* p) { return (p->FS_HPRT & OTG_FS_HOST_FS_HPRT_PLSTS) >> 10; }

// OTG_FS_HOST->FS_HCCHAR0 OTG_FS host channel-0 characteristics register (OTG_FS_HCCHAR0)
enum {
	OTG_FS_HOST_FS_HCCHAR0_CHENA  = 1UL << 31,              // Channel enable
	OTG_FS_HOST_FS_HCCHAR0_CHDIS  = 1UL << 30,              // Channel disable
	OTG_FS_HOST_FS_HCCHAR0_ODDFRM = 1UL << 29,              // Odd frame
	OTG_FS_HOST_FS_HCCHAR0_DAD    = ((1UL << 7) - 1) << 22, // Device address
	OTG_FS_HOST_FS_HCCHAR0_MCNT   = ((1UL << 2) - 1) << 20, // Multicount
	OTG_FS_HOST_FS_HCCHAR0_EPTYP  = ((1UL << 2) - 1) << 18, // Endpoint type
	OTG_FS_HOST_FS_HCCHAR0_LSDEV  = 1UL << 17,              // Low-speed device
	OTG_FS_HOST_FS_HCCHAR0_EPDIR  = 1UL << 15,              // Endpoint direction
	OTG_FS_HOST_FS_HCCHAR0_EPNUM  = ((1UL << 4) - 1) << 11, // Endpoint number
	OTG_FS_HOST_FS_HCCHAR0_MPSIZ  = ((1UL << 11) - 1) << 0, // Maximum packet size
};
inline void otg_fs_host_fs_hcchar0_set_dad(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR0 = (p->FS_HCCHAR0 & ~OTG_FS_HOST_FS_HCCHAR0_DAD) | ((val << 22) & OTG_FS_HOST_FS_HCCHAR0_DAD);
}
inline void otg_fs_host_fs_hcchar0_set_mcnt(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR0 = (p->FS_HCCHAR0 & ~OTG_FS_HOST_FS_HCCHAR0_MCNT) | ((val << 20) & OTG_FS_HOST_FS_HCCHAR0_MCNT);
}
inline void otg_fs_host_fs_hcchar0_set_eptyp(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR0 = (p->FS_HCCHAR0 & ~OTG_FS_HOST_FS_HCCHAR0_EPTYP) | ((val << 18) & OTG_FS_HOST_FS_HCCHAR0_EPTYP);
}
inline void otg_fs_host_fs_hcchar0_set_epnum(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR0 = (p->FS_HCCHAR0 & ~OTG_FS_HOST_FS_HCCHAR0_EPNUM) | ((val << 11) & OTG_FS_HOST_FS_HCCHAR0_EPNUM);
}
inline void otg_fs_host_fs_hcchar0_set_mpsiz(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR0 = (p->FS_HCCHAR0 & ~OTG_FS_HOST_FS_HCCHAR0_MPSIZ) | ((val << 0) & OTG_FS_HOST_FS_HCCHAR0_MPSIZ);
}
inline uint32_t otg_fs_host_fs_hcchar0_get_dad(struct OTG_FS_HOST_Type* p) { return (p->FS_HCCHAR0 & OTG_FS_HOST_FS_HCCHAR0_DAD) >> 22; }
inline uint32_t otg_fs_host_fs_hcchar0_get_mcnt(struct OTG_FS_HOST_Type* p) { return (p->FS_HCCHAR0 & OTG_FS_HOST_FS_HCCHAR0_MCNT) >> 20; }
inline uint32_t otg_fs_host_fs_hcchar0_get_eptyp(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCCHAR0 & OTG_FS_HOST_FS_HCCHAR0_EPTYP) >> 18;
}
inline uint32_t otg_fs_host_fs_hcchar0_get_epnum(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCCHAR0 & OTG_FS_HOST_FS_HCCHAR0_EPNUM) >> 11;
}
inline uint32_t otg_fs_host_fs_hcchar0_get_mpsiz(struct OTG_FS_HOST_Type* p) { return (p->FS_HCCHAR0 & OTG_FS_HOST_FS_HCCHAR0_MPSIZ) >> 0; }

// OTG_FS_HOST->FS_HCINT0 OTG_FS host channel-0 interrupt register (OTG_FS_HCINT0)
enum {
	OTG_FS_HOST_FS_HCINT0_DTERR = 1UL << 10, // Data toggle error
	OTG_FS_HOST_FS_HCINT0_FRMOR = 1UL << 9,  // Frame overrun
	OTG_FS_HOST_FS_HCINT0_BBERR = 1UL << 8,  // Babble error
	OTG_FS_HOST_FS_HCINT0_TXERR = 1UL << 7,  // Transaction error
	OTG_FS_HOST_FS_HCINT0_ACK   = 1UL << 5,  // ACK response received/transmitted interrupt
	OTG_FS_HOST_FS_HCINT0_NAK   = 1UL << 4,  // NAK response received interrupt
	OTG_FS_HOST_FS_HCINT0_STALL = 1UL << 3,  // STALL response received interrupt
	OTG_FS_HOST_FS_HCINT0_CHH   = 1UL << 1,  // Channel halted
	OTG_FS_HOST_FS_HCINT0_XFRC  = 1UL << 0,  // Transfer completed
};

// OTG_FS_HOST->FS_HCINTMSK0 OTG_FS host channel-0 mask register (OTG_FS_HCINTMSK0)
enum {
	OTG_FS_HOST_FS_HCINTMSK0_DTERRM = 1UL << 10, // Data toggle error mask
	OTG_FS_HOST_FS_HCINTMSK0_FRMORM = 1UL << 9,  // Frame overrun mask
	OTG_FS_HOST_FS_HCINTMSK0_BBERRM = 1UL << 8,  // Babble error mask
	OTG_FS_HOST_FS_HCINTMSK0_TXERRM = 1UL << 7,  // Transaction error mask
	OTG_FS_HOST_FS_HCINTMSK0_NYET   = 1UL << 6,  // response received interrupt mask
	OTG_FS_HOST_FS_HCINTMSK0_ACKM   = 1UL << 5,  // ACK response received/transmitted interrupt mask
	OTG_FS_HOST_FS_HCINTMSK0_NAKM   = 1UL << 4,  // NAK response received interrupt mask
	OTG_FS_HOST_FS_HCINTMSK0_STALLM = 1UL << 3,  // STALL response received interrupt mask
	OTG_FS_HOST_FS_HCINTMSK0_CHHM   = 1UL << 1,  // Channel halted mask
	OTG_FS_HOST_FS_HCINTMSK0_XFRCM  = 1UL << 0,  // Transfer completed mask
};

// OTG_FS_HOST->FS_HCTSIZ0 OTG_FS host channel-0 transfer size register
enum {
	OTG_FS_HOST_FS_HCTSIZ0_DPID   = ((1UL << 2) - 1) << 29,  // Data PID
	OTG_FS_HOST_FS_HCTSIZ0_PKTCNT = ((1UL << 10) - 1) << 19, // Packet count
	OTG_FS_HOST_FS_HCTSIZ0_XFRSIZ = ((1UL << 19) - 1) << 0,  // Transfer size
};
inline void otg_fs_host_fs_hctsiz0_set_dpid(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCTSIZ0 = (p->FS_HCTSIZ0 & ~OTG_FS_HOST_FS_HCTSIZ0_DPID) | ((val << 29) & OTG_FS_HOST_FS_HCTSIZ0_DPID);
}
inline void otg_fs_host_fs_hctsiz0_set_pktcnt(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCTSIZ0 = (p->FS_HCTSIZ0 & ~OTG_FS_HOST_FS_HCTSIZ0_PKTCNT) | ((val << 19) & OTG_FS_HOST_FS_HCTSIZ0_PKTCNT);
}
inline void otg_fs_host_fs_hctsiz0_set_xfrsiz(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCTSIZ0 = (p->FS_HCTSIZ0 & ~OTG_FS_HOST_FS_HCTSIZ0_XFRSIZ) | ((val << 0) & OTG_FS_HOST_FS_HCTSIZ0_XFRSIZ);
}
inline uint32_t otg_fs_host_fs_hctsiz0_get_dpid(struct OTG_FS_HOST_Type* p) { return (p->FS_HCTSIZ0 & OTG_FS_HOST_FS_HCTSIZ0_DPID) >> 29; }
inline uint32_t otg_fs_host_fs_hctsiz0_get_pktcnt(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCTSIZ0 & OTG_FS_HOST_FS_HCTSIZ0_PKTCNT) >> 19;
}
inline uint32_t otg_fs_host_fs_hctsiz0_get_xfrsiz(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCTSIZ0 & OTG_FS_HOST_FS_HCTSIZ0_XFRSIZ) >> 0;
}

// OTG_FS_HOST->FS_HCCHAR1 OTG_FS host channel-1 characteristics register (OTG_FS_HCCHAR1)
enum {
	OTG_FS_HOST_FS_HCCHAR1_CHENA  = 1UL << 31,              // Channel enable
	OTG_FS_HOST_FS_HCCHAR1_CHDIS  = 1UL << 30,              // Channel disable
	OTG_FS_HOST_FS_HCCHAR1_ODDFRM = 1UL << 29,              // Odd frame
	OTG_FS_HOST_FS_HCCHAR1_DAD    = ((1UL << 7) - 1) << 22, // Device address
	OTG_FS_HOST_FS_HCCHAR1_MCNT   = ((1UL << 2) - 1) << 20, // Multicount
	OTG_FS_HOST_FS_HCCHAR1_EPTYP  = ((1UL << 2) - 1) << 18, // Endpoint type
	OTG_FS_HOST_FS_HCCHAR1_LSDEV  = 1UL << 17,              // Low-speed device
	OTG_FS_HOST_FS_HCCHAR1_EPDIR  = 1UL << 15,              // Endpoint direction
	OTG_FS_HOST_FS_HCCHAR1_EPNUM  = ((1UL << 4) - 1) << 11, // Endpoint number
	OTG_FS_HOST_FS_HCCHAR1_MPSIZ  = ((1UL << 11) - 1) << 0, // Maximum packet size
};
inline void otg_fs_host_fs_hcchar1_set_dad(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR1 = (p->FS_HCCHAR1 & ~OTG_FS_HOST_FS_HCCHAR1_DAD) | ((val << 22) & OTG_FS_HOST_FS_HCCHAR1_DAD);
}
inline void otg_fs_host_fs_hcchar1_set_mcnt(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR1 = (p->FS_HCCHAR1 & ~OTG_FS_HOST_FS_HCCHAR1_MCNT) | ((val << 20) & OTG_FS_HOST_FS_HCCHAR1_MCNT);
}
inline void otg_fs_host_fs_hcchar1_set_eptyp(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR1 = (p->FS_HCCHAR1 & ~OTG_FS_HOST_FS_HCCHAR1_EPTYP) | ((val << 18) & OTG_FS_HOST_FS_HCCHAR1_EPTYP);
}
inline void otg_fs_host_fs_hcchar1_set_epnum(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR1 = (p->FS_HCCHAR1 & ~OTG_FS_HOST_FS_HCCHAR1_EPNUM) | ((val << 11) & OTG_FS_HOST_FS_HCCHAR1_EPNUM);
}
inline void otg_fs_host_fs_hcchar1_set_mpsiz(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR1 = (p->FS_HCCHAR1 & ~OTG_FS_HOST_FS_HCCHAR1_MPSIZ) | ((val << 0) & OTG_FS_HOST_FS_HCCHAR1_MPSIZ);
}
inline uint32_t otg_fs_host_fs_hcchar1_get_dad(struct OTG_FS_HOST_Type* p) { return (p->FS_HCCHAR1 & OTG_FS_HOST_FS_HCCHAR1_DAD) >> 22; }
inline uint32_t otg_fs_host_fs_hcchar1_get_mcnt(struct OTG_FS_HOST_Type* p) { return (p->FS_HCCHAR1 & OTG_FS_HOST_FS_HCCHAR1_MCNT) >> 20; }
inline uint32_t otg_fs_host_fs_hcchar1_get_eptyp(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCCHAR1 & OTG_FS_HOST_FS_HCCHAR1_EPTYP) >> 18;
}
inline uint32_t otg_fs_host_fs_hcchar1_get_epnum(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCCHAR1 & OTG_FS_HOST_FS_HCCHAR1_EPNUM) >> 11;
}
inline uint32_t otg_fs_host_fs_hcchar1_get_mpsiz(struct OTG_FS_HOST_Type* p) { return (p->FS_HCCHAR1 & OTG_FS_HOST_FS_HCCHAR1_MPSIZ) >> 0; }

// OTG_FS_HOST->FS_HCINT1 OTG_FS host channel-1 interrupt register (OTG_FS_HCINT1)
enum {
	OTG_FS_HOST_FS_HCINT1_DTERR = 1UL << 10, // Data toggle error
	OTG_FS_HOST_FS_HCINT1_FRMOR = 1UL << 9,  // Frame overrun
	OTG_FS_HOST_FS_HCINT1_BBERR = 1UL << 8,  // Babble error
	OTG_FS_HOST_FS_HCINT1_TXERR = 1UL << 7,  // Transaction error
	OTG_FS_HOST_FS_HCINT1_ACK   = 1UL << 5,  // ACK response received/transmitted interrupt
	OTG_FS_HOST_FS_HCINT1_NAK   = 1UL << 4,  // NAK response received interrupt
	OTG_FS_HOST_FS_HCINT1_STALL = 1UL << 3,  // STALL response received interrupt
	OTG_FS_HOST_FS_HCINT1_CHH   = 1UL << 1,  // Channel halted
	OTG_FS_HOST_FS_HCINT1_XFRC  = 1UL << 0,  // Transfer completed
};

// OTG_FS_HOST->FS_HCINTMSK1 OTG_FS host channel-1 mask register (OTG_FS_HCINTMSK1)
enum {
	OTG_FS_HOST_FS_HCINTMSK1_DTERRM = 1UL << 10, // Data toggle error mask
	OTG_FS_HOST_FS_HCINTMSK1_FRMORM = 1UL << 9,  // Frame overrun mask
	OTG_FS_HOST_FS_HCINTMSK1_BBERRM = 1UL << 8,  // Babble error mask
	OTG_FS_HOST_FS_HCINTMSK1_TXERRM = 1UL << 7,  // Transaction error mask
	OTG_FS_HOST_FS_HCINTMSK1_NYET   = 1UL << 6,  // response received interrupt mask
	OTG_FS_HOST_FS_HCINTMSK1_ACKM   = 1UL << 5,  // ACK response received/transmitted interrupt mask
	OTG_FS_HOST_FS_HCINTMSK1_NAKM   = 1UL << 4,  // NAK response received interrupt mask
	OTG_FS_HOST_FS_HCINTMSK1_STALLM = 1UL << 3,  // STALL response received interrupt mask
	OTG_FS_HOST_FS_HCINTMSK1_CHHM   = 1UL << 1,  // Channel halted mask
	OTG_FS_HOST_FS_HCINTMSK1_XFRCM  = 1UL << 0,  // Transfer completed mask
};

// OTG_FS_HOST->FS_HCTSIZ1 OTG_FS host channel-1 transfer size register
enum {
	OTG_FS_HOST_FS_HCTSIZ1_DPID   = ((1UL << 2) - 1) << 29,  // Data PID
	OTG_FS_HOST_FS_HCTSIZ1_PKTCNT = ((1UL << 10) - 1) << 19, // Packet count
	OTG_FS_HOST_FS_HCTSIZ1_XFRSIZ = ((1UL << 19) - 1) << 0,  // Transfer size
};
inline void otg_fs_host_fs_hctsiz1_set_dpid(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCTSIZ1 = (p->FS_HCTSIZ1 & ~OTG_FS_HOST_FS_HCTSIZ1_DPID) | ((val << 29) & OTG_FS_HOST_FS_HCTSIZ1_DPID);
}
inline void otg_fs_host_fs_hctsiz1_set_pktcnt(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCTSIZ1 = (p->FS_HCTSIZ1 & ~OTG_FS_HOST_FS_HCTSIZ1_PKTCNT) | ((val << 19) & OTG_FS_HOST_FS_HCTSIZ1_PKTCNT);
}
inline void otg_fs_host_fs_hctsiz1_set_xfrsiz(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCTSIZ1 = (p->FS_HCTSIZ1 & ~OTG_FS_HOST_FS_HCTSIZ1_XFRSIZ) | ((val << 0) & OTG_FS_HOST_FS_HCTSIZ1_XFRSIZ);
}
inline uint32_t otg_fs_host_fs_hctsiz1_get_dpid(struct OTG_FS_HOST_Type* p) { return (p->FS_HCTSIZ1 & OTG_FS_HOST_FS_HCTSIZ1_DPID) >> 29; }
inline uint32_t otg_fs_host_fs_hctsiz1_get_pktcnt(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCTSIZ1 & OTG_FS_HOST_FS_HCTSIZ1_PKTCNT) >> 19;
}
inline uint32_t otg_fs_host_fs_hctsiz1_get_xfrsiz(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCTSIZ1 & OTG_FS_HOST_FS_HCTSIZ1_XFRSIZ) >> 0;
}

// OTG_FS_HOST->FS_HCCHAR2 OTG_FS host channel-2 characteristics register (OTG_FS_HCCHAR2)
enum {
	OTG_FS_HOST_FS_HCCHAR2_CHENA  = 1UL << 31,              // Channel enable
	OTG_FS_HOST_FS_HCCHAR2_CHDIS  = 1UL << 30,              // Channel disable
	OTG_FS_HOST_FS_HCCHAR2_ODDFRM = 1UL << 29,              // Odd frame
	OTG_FS_HOST_FS_HCCHAR2_DAD    = ((1UL << 7) - 1) << 22, // Device address
	OTG_FS_HOST_FS_HCCHAR2_MCNT   = ((1UL << 2) - 1) << 20, // Multicount
	OTG_FS_HOST_FS_HCCHAR2_EPTYP  = ((1UL << 2) - 1) << 18, // Endpoint type
	OTG_FS_HOST_FS_HCCHAR2_LSDEV  = 1UL << 17,              // Low-speed device
	OTG_FS_HOST_FS_HCCHAR2_EPDIR  = 1UL << 15,              // Endpoint direction
	OTG_FS_HOST_FS_HCCHAR2_EPNUM  = ((1UL << 4) - 1) << 11, // Endpoint number
	OTG_FS_HOST_FS_HCCHAR2_MPSIZ  = ((1UL << 11) - 1) << 0, // Maximum packet size
};
inline void otg_fs_host_fs_hcchar2_set_dad(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR2 = (p->FS_HCCHAR2 & ~OTG_FS_HOST_FS_HCCHAR2_DAD) | ((val << 22) & OTG_FS_HOST_FS_HCCHAR2_DAD);
}
inline void otg_fs_host_fs_hcchar2_set_mcnt(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR2 = (p->FS_HCCHAR2 & ~OTG_FS_HOST_FS_HCCHAR2_MCNT) | ((val << 20) & OTG_FS_HOST_FS_HCCHAR2_MCNT);
}
inline void otg_fs_host_fs_hcchar2_set_eptyp(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR2 = (p->FS_HCCHAR2 & ~OTG_FS_HOST_FS_HCCHAR2_EPTYP) | ((val << 18) & OTG_FS_HOST_FS_HCCHAR2_EPTYP);
}
inline void otg_fs_host_fs_hcchar2_set_epnum(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR2 = (p->FS_HCCHAR2 & ~OTG_FS_HOST_FS_HCCHAR2_EPNUM) | ((val << 11) & OTG_FS_HOST_FS_HCCHAR2_EPNUM);
}
inline void otg_fs_host_fs_hcchar2_set_mpsiz(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR2 = (p->FS_HCCHAR2 & ~OTG_FS_HOST_FS_HCCHAR2_MPSIZ) | ((val << 0) & OTG_FS_HOST_FS_HCCHAR2_MPSIZ);
}
inline uint32_t otg_fs_host_fs_hcchar2_get_dad(struct OTG_FS_HOST_Type* p) { return (p->FS_HCCHAR2 & OTG_FS_HOST_FS_HCCHAR2_DAD) >> 22; }
inline uint32_t otg_fs_host_fs_hcchar2_get_mcnt(struct OTG_FS_HOST_Type* p) { return (p->FS_HCCHAR2 & OTG_FS_HOST_FS_HCCHAR2_MCNT) >> 20; }
inline uint32_t otg_fs_host_fs_hcchar2_get_eptyp(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCCHAR2 & OTG_FS_HOST_FS_HCCHAR2_EPTYP) >> 18;
}
inline uint32_t otg_fs_host_fs_hcchar2_get_epnum(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCCHAR2 & OTG_FS_HOST_FS_HCCHAR2_EPNUM) >> 11;
}
inline uint32_t otg_fs_host_fs_hcchar2_get_mpsiz(struct OTG_FS_HOST_Type* p) { return (p->FS_HCCHAR2 & OTG_FS_HOST_FS_HCCHAR2_MPSIZ) >> 0; }

// OTG_FS_HOST->FS_HCINT2 OTG_FS host channel-2 interrupt register (OTG_FS_HCINT2)
enum {
	OTG_FS_HOST_FS_HCINT2_DTERR = 1UL << 10, // Data toggle error
	OTG_FS_HOST_FS_HCINT2_FRMOR = 1UL << 9,  // Frame overrun
	OTG_FS_HOST_FS_HCINT2_BBERR = 1UL << 8,  // Babble error
	OTG_FS_HOST_FS_HCINT2_TXERR = 1UL << 7,  // Transaction error
	OTG_FS_HOST_FS_HCINT2_ACK   = 1UL << 5,  // ACK response received/transmitted interrupt
	OTG_FS_HOST_FS_HCINT2_NAK   = 1UL << 4,  // NAK response received interrupt
	OTG_FS_HOST_FS_HCINT2_STALL = 1UL << 3,  // STALL response received interrupt
	OTG_FS_HOST_FS_HCINT2_CHH   = 1UL << 1,  // Channel halted
	OTG_FS_HOST_FS_HCINT2_XFRC  = 1UL << 0,  // Transfer completed
};

// OTG_FS_HOST->FS_HCINTMSK2 OTG_FS host channel-2 mask register (OTG_FS_HCINTMSK2)
enum {
	OTG_FS_HOST_FS_HCINTMSK2_DTERRM = 1UL << 10, // Data toggle error mask
	OTG_FS_HOST_FS_HCINTMSK2_FRMORM = 1UL << 9,  // Frame overrun mask
	OTG_FS_HOST_FS_HCINTMSK2_BBERRM = 1UL << 8,  // Babble error mask
	OTG_FS_HOST_FS_HCINTMSK2_TXERRM = 1UL << 7,  // Transaction error mask
	OTG_FS_HOST_FS_HCINTMSK2_NYET   = 1UL << 6,  // response received interrupt mask
	OTG_FS_HOST_FS_HCINTMSK2_ACKM   = 1UL << 5,  // ACK response received/transmitted interrupt mask
	OTG_FS_HOST_FS_HCINTMSK2_NAKM   = 1UL << 4,  // NAK response received interrupt mask
	OTG_FS_HOST_FS_HCINTMSK2_STALLM = 1UL << 3,  // STALL response received interrupt mask
	OTG_FS_HOST_FS_HCINTMSK2_CHHM   = 1UL << 1,  // Channel halted mask
	OTG_FS_HOST_FS_HCINTMSK2_XFRCM  = 1UL << 0,  // Transfer completed mask
};

// OTG_FS_HOST->FS_HCTSIZ2 OTG_FS host channel-2 transfer size register
enum {
	OTG_FS_HOST_FS_HCTSIZ2_DPID   = ((1UL << 2) - 1) << 29,  // Data PID
	OTG_FS_HOST_FS_HCTSIZ2_PKTCNT = ((1UL << 10) - 1) << 19, // Packet count
	OTG_FS_HOST_FS_HCTSIZ2_XFRSIZ = ((1UL << 19) - 1) << 0,  // Transfer size
};
inline void otg_fs_host_fs_hctsiz2_set_dpid(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCTSIZ2 = (p->FS_HCTSIZ2 & ~OTG_FS_HOST_FS_HCTSIZ2_DPID) | ((val << 29) & OTG_FS_HOST_FS_HCTSIZ2_DPID);
}
inline void otg_fs_host_fs_hctsiz2_set_pktcnt(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCTSIZ2 = (p->FS_HCTSIZ2 & ~OTG_FS_HOST_FS_HCTSIZ2_PKTCNT) | ((val << 19) & OTG_FS_HOST_FS_HCTSIZ2_PKTCNT);
}
inline void otg_fs_host_fs_hctsiz2_set_xfrsiz(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCTSIZ2 = (p->FS_HCTSIZ2 & ~OTG_FS_HOST_FS_HCTSIZ2_XFRSIZ) | ((val << 0) & OTG_FS_HOST_FS_HCTSIZ2_XFRSIZ);
}
inline uint32_t otg_fs_host_fs_hctsiz2_get_dpid(struct OTG_FS_HOST_Type* p) { return (p->FS_HCTSIZ2 & OTG_FS_HOST_FS_HCTSIZ2_DPID) >> 29; }
inline uint32_t otg_fs_host_fs_hctsiz2_get_pktcnt(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCTSIZ2 & OTG_FS_HOST_FS_HCTSIZ2_PKTCNT) >> 19;
}
inline uint32_t otg_fs_host_fs_hctsiz2_get_xfrsiz(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCTSIZ2 & OTG_FS_HOST_FS_HCTSIZ2_XFRSIZ) >> 0;
}

// OTG_FS_HOST->FS_HCCHAR3 OTG_FS host channel-3 characteristics register (OTG_FS_HCCHAR3)
enum {
	OTG_FS_HOST_FS_HCCHAR3_CHENA  = 1UL << 31,              // Channel enable
	OTG_FS_HOST_FS_HCCHAR3_CHDIS  = 1UL << 30,              // Channel disable
	OTG_FS_HOST_FS_HCCHAR3_ODDFRM = 1UL << 29,              // Odd frame
	OTG_FS_HOST_FS_HCCHAR3_DAD    = ((1UL << 7) - 1) << 22, // Device address
	OTG_FS_HOST_FS_HCCHAR3_MCNT   = ((1UL << 2) - 1) << 20, // Multicount
	OTG_FS_HOST_FS_HCCHAR3_EPTYP  = ((1UL << 2) - 1) << 18, // Endpoint type
	OTG_FS_HOST_FS_HCCHAR3_LSDEV  = 1UL << 17,              // Low-speed device
	OTG_FS_HOST_FS_HCCHAR3_EPDIR  = 1UL << 15,              // Endpoint direction
	OTG_FS_HOST_FS_HCCHAR3_EPNUM  = ((1UL << 4) - 1) << 11, // Endpoint number
	OTG_FS_HOST_FS_HCCHAR3_MPSIZ  = ((1UL << 11) - 1) << 0, // Maximum packet size
};
inline void otg_fs_host_fs_hcchar3_set_dad(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR3 = (p->FS_HCCHAR3 & ~OTG_FS_HOST_FS_HCCHAR3_DAD) | ((val << 22) & OTG_FS_HOST_FS_HCCHAR3_DAD);
}
inline void otg_fs_host_fs_hcchar3_set_mcnt(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR3 = (p->FS_HCCHAR3 & ~OTG_FS_HOST_FS_HCCHAR3_MCNT) | ((val << 20) & OTG_FS_HOST_FS_HCCHAR3_MCNT);
}
inline void otg_fs_host_fs_hcchar3_set_eptyp(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR3 = (p->FS_HCCHAR3 & ~OTG_FS_HOST_FS_HCCHAR3_EPTYP) | ((val << 18) & OTG_FS_HOST_FS_HCCHAR3_EPTYP);
}
inline void otg_fs_host_fs_hcchar3_set_epnum(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR3 = (p->FS_HCCHAR3 & ~OTG_FS_HOST_FS_HCCHAR3_EPNUM) | ((val << 11) & OTG_FS_HOST_FS_HCCHAR3_EPNUM);
}
inline void otg_fs_host_fs_hcchar3_set_mpsiz(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR3 = (p->FS_HCCHAR3 & ~OTG_FS_HOST_FS_HCCHAR3_MPSIZ) | ((val << 0) & OTG_FS_HOST_FS_HCCHAR3_MPSIZ);
}
inline uint32_t otg_fs_host_fs_hcchar3_get_dad(struct OTG_FS_HOST_Type* p) { return (p->FS_HCCHAR3 & OTG_FS_HOST_FS_HCCHAR3_DAD) >> 22; }
inline uint32_t otg_fs_host_fs_hcchar3_get_mcnt(struct OTG_FS_HOST_Type* p) { return (p->FS_HCCHAR3 & OTG_FS_HOST_FS_HCCHAR3_MCNT) >> 20; }
inline uint32_t otg_fs_host_fs_hcchar3_get_eptyp(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCCHAR3 & OTG_FS_HOST_FS_HCCHAR3_EPTYP) >> 18;
}
inline uint32_t otg_fs_host_fs_hcchar3_get_epnum(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCCHAR3 & OTG_FS_HOST_FS_HCCHAR3_EPNUM) >> 11;
}
inline uint32_t otg_fs_host_fs_hcchar3_get_mpsiz(struct OTG_FS_HOST_Type* p) { return (p->FS_HCCHAR3 & OTG_FS_HOST_FS_HCCHAR3_MPSIZ) >> 0; }

// OTG_FS_HOST->FS_HCINT3 OTG_FS host channel-3 interrupt register (OTG_FS_HCINT3)
enum {
	OTG_FS_HOST_FS_HCINT3_DTERR = 1UL << 10, // Data toggle error
	OTG_FS_HOST_FS_HCINT3_FRMOR = 1UL << 9,  // Frame overrun
	OTG_FS_HOST_FS_HCINT3_BBERR = 1UL << 8,  // Babble error
	OTG_FS_HOST_FS_HCINT3_TXERR = 1UL << 7,  // Transaction error
	OTG_FS_HOST_FS_HCINT3_ACK   = 1UL << 5,  // ACK response received/transmitted interrupt
	OTG_FS_HOST_FS_HCINT3_NAK   = 1UL << 4,  // NAK response received interrupt
	OTG_FS_HOST_FS_HCINT3_STALL = 1UL << 3,  // STALL response received interrupt
	OTG_FS_HOST_FS_HCINT3_CHH   = 1UL << 1,  // Channel halted
	OTG_FS_HOST_FS_HCINT3_XFRC  = 1UL << 0,  // Transfer completed
};

// OTG_FS_HOST->FS_HCINTMSK3 OTG_FS host channel-3 mask register (OTG_FS_HCINTMSK3)
enum {
	OTG_FS_HOST_FS_HCINTMSK3_DTERRM = 1UL << 10, // Data toggle error mask
	OTG_FS_HOST_FS_HCINTMSK3_FRMORM = 1UL << 9,  // Frame overrun mask
	OTG_FS_HOST_FS_HCINTMSK3_BBERRM = 1UL << 8,  // Babble error mask
	OTG_FS_HOST_FS_HCINTMSK3_TXERRM = 1UL << 7,  // Transaction error mask
	OTG_FS_HOST_FS_HCINTMSK3_NYET   = 1UL << 6,  // response received interrupt mask
	OTG_FS_HOST_FS_HCINTMSK3_ACKM   = 1UL << 5,  // ACK response received/transmitted interrupt mask
	OTG_FS_HOST_FS_HCINTMSK3_NAKM   = 1UL << 4,  // NAK response received interrupt mask
	OTG_FS_HOST_FS_HCINTMSK3_STALLM = 1UL << 3,  // STALL response received interrupt mask
	OTG_FS_HOST_FS_HCINTMSK3_CHHM   = 1UL << 1,  // Channel halted mask
	OTG_FS_HOST_FS_HCINTMSK3_XFRCM  = 1UL << 0,  // Transfer completed mask
};

// OTG_FS_HOST->FS_HCTSIZ3 OTG_FS host channel-3 transfer size register
enum {
	OTG_FS_HOST_FS_HCTSIZ3_DPID   = ((1UL << 2) - 1) << 29,  // Data PID
	OTG_FS_HOST_FS_HCTSIZ3_PKTCNT = ((1UL << 10) - 1) << 19, // Packet count
	OTG_FS_HOST_FS_HCTSIZ3_XFRSIZ = ((1UL << 19) - 1) << 0,  // Transfer size
};
inline void otg_fs_host_fs_hctsiz3_set_dpid(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCTSIZ3 = (p->FS_HCTSIZ3 & ~OTG_FS_HOST_FS_HCTSIZ3_DPID) | ((val << 29) & OTG_FS_HOST_FS_HCTSIZ3_DPID);
}
inline void otg_fs_host_fs_hctsiz3_set_pktcnt(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCTSIZ3 = (p->FS_HCTSIZ3 & ~OTG_FS_HOST_FS_HCTSIZ3_PKTCNT) | ((val << 19) & OTG_FS_HOST_FS_HCTSIZ3_PKTCNT);
}
inline void otg_fs_host_fs_hctsiz3_set_xfrsiz(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCTSIZ3 = (p->FS_HCTSIZ3 & ~OTG_FS_HOST_FS_HCTSIZ3_XFRSIZ) | ((val << 0) & OTG_FS_HOST_FS_HCTSIZ3_XFRSIZ);
}
inline uint32_t otg_fs_host_fs_hctsiz3_get_dpid(struct OTG_FS_HOST_Type* p) { return (p->FS_HCTSIZ3 & OTG_FS_HOST_FS_HCTSIZ3_DPID) >> 29; }
inline uint32_t otg_fs_host_fs_hctsiz3_get_pktcnt(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCTSIZ3 & OTG_FS_HOST_FS_HCTSIZ3_PKTCNT) >> 19;
}
inline uint32_t otg_fs_host_fs_hctsiz3_get_xfrsiz(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCTSIZ3 & OTG_FS_HOST_FS_HCTSIZ3_XFRSIZ) >> 0;
}

// OTG_FS_HOST->FS_HCCHAR4 OTG_FS host channel-4 characteristics register (OTG_FS_HCCHAR4)
enum {
	OTG_FS_HOST_FS_HCCHAR4_CHENA  = 1UL << 31,              // Channel enable
	OTG_FS_HOST_FS_HCCHAR4_CHDIS  = 1UL << 30,              // Channel disable
	OTG_FS_HOST_FS_HCCHAR4_ODDFRM = 1UL << 29,              // Odd frame
	OTG_FS_HOST_FS_HCCHAR4_DAD    = ((1UL << 7) - 1) << 22, // Device address
	OTG_FS_HOST_FS_HCCHAR4_MCNT   = ((1UL << 2) - 1) << 20, // Multicount
	OTG_FS_HOST_FS_HCCHAR4_EPTYP  = ((1UL << 2) - 1) << 18, // Endpoint type
	OTG_FS_HOST_FS_HCCHAR4_LSDEV  = 1UL << 17,              // Low-speed device
	OTG_FS_HOST_FS_HCCHAR4_EPDIR  = 1UL << 15,              // Endpoint direction
	OTG_FS_HOST_FS_HCCHAR4_EPNUM  = ((1UL << 4) - 1) << 11, // Endpoint number
	OTG_FS_HOST_FS_HCCHAR4_MPSIZ  = ((1UL << 11) - 1) << 0, // Maximum packet size
};
inline void otg_fs_host_fs_hcchar4_set_dad(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR4 = (p->FS_HCCHAR4 & ~OTG_FS_HOST_FS_HCCHAR4_DAD) | ((val << 22) & OTG_FS_HOST_FS_HCCHAR4_DAD);
}
inline void otg_fs_host_fs_hcchar4_set_mcnt(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR4 = (p->FS_HCCHAR4 & ~OTG_FS_HOST_FS_HCCHAR4_MCNT) | ((val << 20) & OTG_FS_HOST_FS_HCCHAR4_MCNT);
}
inline void otg_fs_host_fs_hcchar4_set_eptyp(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR4 = (p->FS_HCCHAR4 & ~OTG_FS_HOST_FS_HCCHAR4_EPTYP) | ((val << 18) & OTG_FS_HOST_FS_HCCHAR4_EPTYP);
}
inline void otg_fs_host_fs_hcchar4_set_epnum(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR4 = (p->FS_HCCHAR4 & ~OTG_FS_HOST_FS_HCCHAR4_EPNUM) | ((val << 11) & OTG_FS_HOST_FS_HCCHAR4_EPNUM);
}
inline void otg_fs_host_fs_hcchar4_set_mpsiz(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR4 = (p->FS_HCCHAR4 & ~OTG_FS_HOST_FS_HCCHAR4_MPSIZ) | ((val << 0) & OTG_FS_HOST_FS_HCCHAR4_MPSIZ);
}
inline uint32_t otg_fs_host_fs_hcchar4_get_dad(struct OTG_FS_HOST_Type* p) { return (p->FS_HCCHAR4 & OTG_FS_HOST_FS_HCCHAR4_DAD) >> 22; }
inline uint32_t otg_fs_host_fs_hcchar4_get_mcnt(struct OTG_FS_HOST_Type* p) { return (p->FS_HCCHAR4 & OTG_FS_HOST_FS_HCCHAR4_MCNT) >> 20; }
inline uint32_t otg_fs_host_fs_hcchar4_get_eptyp(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCCHAR4 & OTG_FS_HOST_FS_HCCHAR4_EPTYP) >> 18;
}
inline uint32_t otg_fs_host_fs_hcchar4_get_epnum(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCCHAR4 & OTG_FS_HOST_FS_HCCHAR4_EPNUM) >> 11;
}
inline uint32_t otg_fs_host_fs_hcchar4_get_mpsiz(struct OTG_FS_HOST_Type* p) { return (p->FS_HCCHAR4 & OTG_FS_HOST_FS_HCCHAR4_MPSIZ) >> 0; }

// OTG_FS_HOST->FS_HCINT4 OTG_FS host channel-4 interrupt register (OTG_FS_HCINT4)
enum {
	OTG_FS_HOST_FS_HCINT4_DTERR = 1UL << 10, // Data toggle error
	OTG_FS_HOST_FS_HCINT4_FRMOR = 1UL << 9,  // Frame overrun
	OTG_FS_HOST_FS_HCINT4_BBERR = 1UL << 8,  // Babble error
	OTG_FS_HOST_FS_HCINT4_TXERR = 1UL << 7,  // Transaction error
	OTG_FS_HOST_FS_HCINT4_ACK   = 1UL << 5,  // ACK response received/transmitted interrupt
	OTG_FS_HOST_FS_HCINT4_NAK   = 1UL << 4,  // NAK response received interrupt
	OTG_FS_HOST_FS_HCINT4_STALL = 1UL << 3,  // STALL response received interrupt
	OTG_FS_HOST_FS_HCINT4_CHH   = 1UL << 1,  // Channel halted
	OTG_FS_HOST_FS_HCINT4_XFRC  = 1UL << 0,  // Transfer completed
};

// OTG_FS_HOST->FS_HCINTMSK4 OTG_FS host channel-4 mask register (OTG_FS_HCINTMSK4)
enum {
	OTG_FS_HOST_FS_HCINTMSK4_DTERRM = 1UL << 10, // Data toggle error mask
	OTG_FS_HOST_FS_HCINTMSK4_FRMORM = 1UL << 9,  // Frame overrun mask
	OTG_FS_HOST_FS_HCINTMSK4_BBERRM = 1UL << 8,  // Babble error mask
	OTG_FS_HOST_FS_HCINTMSK4_TXERRM = 1UL << 7,  // Transaction error mask
	OTG_FS_HOST_FS_HCINTMSK4_NYET   = 1UL << 6,  // response received interrupt mask
	OTG_FS_HOST_FS_HCINTMSK4_ACKM   = 1UL << 5,  // ACK response received/transmitted interrupt mask
	OTG_FS_HOST_FS_HCINTMSK4_NAKM   = 1UL << 4,  // NAK response received interrupt mask
	OTG_FS_HOST_FS_HCINTMSK4_STALLM = 1UL << 3,  // STALL response received interrupt mask
	OTG_FS_HOST_FS_HCINTMSK4_CHHM   = 1UL << 1,  // Channel halted mask
	OTG_FS_HOST_FS_HCINTMSK4_XFRCM  = 1UL << 0,  // Transfer completed mask
};

// OTG_FS_HOST->FS_HCTSIZ4 OTG_FS host channel-x transfer size register
enum {
	OTG_FS_HOST_FS_HCTSIZ4_DPID   = ((1UL << 2) - 1) << 29,  // Data PID
	OTG_FS_HOST_FS_HCTSIZ4_PKTCNT = ((1UL << 10) - 1) << 19, // Packet count
	OTG_FS_HOST_FS_HCTSIZ4_XFRSIZ = ((1UL << 19) - 1) << 0,  // Transfer size
};
inline void otg_fs_host_fs_hctsiz4_set_dpid(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCTSIZ4 = (p->FS_HCTSIZ4 & ~OTG_FS_HOST_FS_HCTSIZ4_DPID) | ((val << 29) & OTG_FS_HOST_FS_HCTSIZ4_DPID);
}
inline void otg_fs_host_fs_hctsiz4_set_pktcnt(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCTSIZ4 = (p->FS_HCTSIZ4 & ~OTG_FS_HOST_FS_HCTSIZ4_PKTCNT) | ((val << 19) & OTG_FS_HOST_FS_HCTSIZ4_PKTCNT);
}
inline void otg_fs_host_fs_hctsiz4_set_xfrsiz(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCTSIZ4 = (p->FS_HCTSIZ4 & ~OTG_FS_HOST_FS_HCTSIZ4_XFRSIZ) | ((val << 0) & OTG_FS_HOST_FS_HCTSIZ4_XFRSIZ);
}
inline uint32_t otg_fs_host_fs_hctsiz4_get_dpid(struct OTG_FS_HOST_Type* p) { return (p->FS_HCTSIZ4 & OTG_FS_HOST_FS_HCTSIZ4_DPID) >> 29; }
inline uint32_t otg_fs_host_fs_hctsiz4_get_pktcnt(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCTSIZ4 & OTG_FS_HOST_FS_HCTSIZ4_PKTCNT) >> 19;
}
inline uint32_t otg_fs_host_fs_hctsiz4_get_xfrsiz(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCTSIZ4 & OTG_FS_HOST_FS_HCTSIZ4_XFRSIZ) >> 0;
}

// OTG_FS_HOST->FS_HCCHAR5 OTG_FS host channel-5 characteristics register (OTG_FS_HCCHAR5)
enum {
	OTG_FS_HOST_FS_HCCHAR5_CHENA  = 1UL << 31,              // Channel enable
	OTG_FS_HOST_FS_HCCHAR5_CHDIS  = 1UL << 30,              // Channel disable
	OTG_FS_HOST_FS_HCCHAR5_ODDFRM = 1UL << 29,              // Odd frame
	OTG_FS_HOST_FS_HCCHAR5_DAD    = ((1UL << 7) - 1) << 22, // Device address
	OTG_FS_HOST_FS_HCCHAR5_MCNT   = ((1UL << 2) - 1) << 20, // Multicount
	OTG_FS_HOST_FS_HCCHAR5_EPTYP  = ((1UL << 2) - 1) << 18, // Endpoint type
	OTG_FS_HOST_FS_HCCHAR5_LSDEV  = 1UL << 17,              // Low-speed device
	OTG_FS_HOST_FS_HCCHAR5_EPDIR  = 1UL << 15,              // Endpoint direction
	OTG_FS_HOST_FS_HCCHAR5_EPNUM  = ((1UL << 4) - 1) << 11, // Endpoint number
	OTG_FS_HOST_FS_HCCHAR5_MPSIZ  = ((1UL << 11) - 1) << 0, // Maximum packet size
};
inline void otg_fs_host_fs_hcchar5_set_dad(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR5 = (p->FS_HCCHAR5 & ~OTG_FS_HOST_FS_HCCHAR5_DAD) | ((val << 22) & OTG_FS_HOST_FS_HCCHAR5_DAD);
}
inline void otg_fs_host_fs_hcchar5_set_mcnt(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR5 = (p->FS_HCCHAR5 & ~OTG_FS_HOST_FS_HCCHAR5_MCNT) | ((val << 20) & OTG_FS_HOST_FS_HCCHAR5_MCNT);
}
inline void otg_fs_host_fs_hcchar5_set_eptyp(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR5 = (p->FS_HCCHAR5 & ~OTG_FS_HOST_FS_HCCHAR5_EPTYP) | ((val << 18) & OTG_FS_HOST_FS_HCCHAR5_EPTYP);
}
inline void otg_fs_host_fs_hcchar5_set_epnum(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR5 = (p->FS_HCCHAR5 & ~OTG_FS_HOST_FS_HCCHAR5_EPNUM) | ((val << 11) & OTG_FS_HOST_FS_HCCHAR5_EPNUM);
}
inline void otg_fs_host_fs_hcchar5_set_mpsiz(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR5 = (p->FS_HCCHAR5 & ~OTG_FS_HOST_FS_HCCHAR5_MPSIZ) | ((val << 0) & OTG_FS_HOST_FS_HCCHAR5_MPSIZ);
}
inline uint32_t otg_fs_host_fs_hcchar5_get_dad(struct OTG_FS_HOST_Type* p) { return (p->FS_HCCHAR5 & OTG_FS_HOST_FS_HCCHAR5_DAD) >> 22; }
inline uint32_t otg_fs_host_fs_hcchar5_get_mcnt(struct OTG_FS_HOST_Type* p) { return (p->FS_HCCHAR5 & OTG_FS_HOST_FS_HCCHAR5_MCNT) >> 20; }
inline uint32_t otg_fs_host_fs_hcchar5_get_eptyp(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCCHAR5 & OTG_FS_HOST_FS_HCCHAR5_EPTYP) >> 18;
}
inline uint32_t otg_fs_host_fs_hcchar5_get_epnum(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCCHAR5 & OTG_FS_HOST_FS_HCCHAR5_EPNUM) >> 11;
}
inline uint32_t otg_fs_host_fs_hcchar5_get_mpsiz(struct OTG_FS_HOST_Type* p) { return (p->FS_HCCHAR5 & OTG_FS_HOST_FS_HCCHAR5_MPSIZ) >> 0; }

// OTG_FS_HOST->FS_HCINT5 OTG_FS host channel-5 interrupt register (OTG_FS_HCINT5)
enum {
	OTG_FS_HOST_FS_HCINT5_DTERR = 1UL << 10, // Data toggle error
	OTG_FS_HOST_FS_HCINT5_FRMOR = 1UL << 9,  // Frame overrun
	OTG_FS_HOST_FS_HCINT5_BBERR = 1UL << 8,  // Babble error
	OTG_FS_HOST_FS_HCINT5_TXERR = 1UL << 7,  // Transaction error
	OTG_FS_HOST_FS_HCINT5_ACK   = 1UL << 5,  // ACK response received/transmitted interrupt
	OTG_FS_HOST_FS_HCINT5_NAK   = 1UL << 4,  // NAK response received interrupt
	OTG_FS_HOST_FS_HCINT5_STALL = 1UL << 3,  // STALL response received interrupt
	OTG_FS_HOST_FS_HCINT5_CHH   = 1UL << 1,  // Channel halted
	OTG_FS_HOST_FS_HCINT5_XFRC  = 1UL << 0,  // Transfer completed
};

// OTG_FS_HOST->FS_HCINTMSK5 OTG_FS host channel-5 mask register (OTG_FS_HCINTMSK5)
enum {
	OTG_FS_HOST_FS_HCINTMSK5_DTERRM = 1UL << 10, // Data toggle error mask
	OTG_FS_HOST_FS_HCINTMSK5_FRMORM = 1UL << 9,  // Frame overrun mask
	OTG_FS_HOST_FS_HCINTMSK5_BBERRM = 1UL << 8,  // Babble error mask
	OTG_FS_HOST_FS_HCINTMSK5_TXERRM = 1UL << 7,  // Transaction error mask
	OTG_FS_HOST_FS_HCINTMSK5_NYET   = 1UL << 6,  // response received interrupt mask
	OTG_FS_HOST_FS_HCINTMSK5_ACKM   = 1UL << 5,  // ACK response received/transmitted interrupt mask
	OTG_FS_HOST_FS_HCINTMSK5_NAKM   = 1UL << 4,  // NAK response received interrupt mask
	OTG_FS_HOST_FS_HCINTMSK5_STALLM = 1UL << 3,  // STALL response received interrupt mask
	OTG_FS_HOST_FS_HCINTMSK5_CHHM   = 1UL << 1,  // Channel halted mask
	OTG_FS_HOST_FS_HCINTMSK5_XFRCM  = 1UL << 0,  // Transfer completed mask
};

// OTG_FS_HOST->FS_HCTSIZ5 OTG_FS host channel-5 transfer size register
enum {
	OTG_FS_HOST_FS_HCTSIZ5_DPID   = ((1UL << 2) - 1) << 29,  // Data PID
	OTG_FS_HOST_FS_HCTSIZ5_PKTCNT = ((1UL << 10) - 1) << 19, // Packet count
	OTG_FS_HOST_FS_HCTSIZ5_XFRSIZ = ((1UL << 19) - 1) << 0,  // Transfer size
};
inline void otg_fs_host_fs_hctsiz5_set_dpid(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCTSIZ5 = (p->FS_HCTSIZ5 & ~OTG_FS_HOST_FS_HCTSIZ5_DPID) | ((val << 29) & OTG_FS_HOST_FS_HCTSIZ5_DPID);
}
inline void otg_fs_host_fs_hctsiz5_set_pktcnt(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCTSIZ5 = (p->FS_HCTSIZ5 & ~OTG_FS_HOST_FS_HCTSIZ5_PKTCNT) | ((val << 19) & OTG_FS_HOST_FS_HCTSIZ5_PKTCNT);
}
inline void otg_fs_host_fs_hctsiz5_set_xfrsiz(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCTSIZ5 = (p->FS_HCTSIZ5 & ~OTG_FS_HOST_FS_HCTSIZ5_XFRSIZ) | ((val << 0) & OTG_FS_HOST_FS_HCTSIZ5_XFRSIZ);
}
inline uint32_t otg_fs_host_fs_hctsiz5_get_dpid(struct OTG_FS_HOST_Type* p) { return (p->FS_HCTSIZ5 & OTG_FS_HOST_FS_HCTSIZ5_DPID) >> 29; }
inline uint32_t otg_fs_host_fs_hctsiz5_get_pktcnt(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCTSIZ5 & OTG_FS_HOST_FS_HCTSIZ5_PKTCNT) >> 19;
}
inline uint32_t otg_fs_host_fs_hctsiz5_get_xfrsiz(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCTSIZ5 & OTG_FS_HOST_FS_HCTSIZ5_XFRSIZ) >> 0;
}

// OTG_FS_HOST->FS_HCCHAR6 OTG_FS host channel-6 characteristics register (OTG_FS_HCCHAR6)
enum {
	OTG_FS_HOST_FS_HCCHAR6_CHENA  = 1UL << 31,              // Channel enable
	OTG_FS_HOST_FS_HCCHAR6_CHDIS  = 1UL << 30,              // Channel disable
	OTG_FS_HOST_FS_HCCHAR6_ODDFRM = 1UL << 29,              // Odd frame
	OTG_FS_HOST_FS_HCCHAR6_DAD    = ((1UL << 7) - 1) << 22, // Device address
	OTG_FS_HOST_FS_HCCHAR6_MCNT   = ((1UL << 2) - 1) << 20, // Multicount
	OTG_FS_HOST_FS_HCCHAR6_EPTYP  = ((1UL << 2) - 1) << 18, // Endpoint type
	OTG_FS_HOST_FS_HCCHAR6_LSDEV  = 1UL << 17,              // Low-speed device
	OTG_FS_HOST_FS_HCCHAR6_EPDIR  = 1UL << 15,              // Endpoint direction
	OTG_FS_HOST_FS_HCCHAR6_EPNUM  = ((1UL << 4) - 1) << 11, // Endpoint number
	OTG_FS_HOST_FS_HCCHAR6_MPSIZ  = ((1UL << 11) - 1) << 0, // Maximum packet size
};
inline void otg_fs_host_fs_hcchar6_set_dad(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR6 = (p->FS_HCCHAR6 & ~OTG_FS_HOST_FS_HCCHAR6_DAD) | ((val << 22) & OTG_FS_HOST_FS_HCCHAR6_DAD);
}
inline void otg_fs_host_fs_hcchar6_set_mcnt(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR6 = (p->FS_HCCHAR6 & ~OTG_FS_HOST_FS_HCCHAR6_MCNT) | ((val << 20) & OTG_FS_HOST_FS_HCCHAR6_MCNT);
}
inline void otg_fs_host_fs_hcchar6_set_eptyp(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR6 = (p->FS_HCCHAR6 & ~OTG_FS_HOST_FS_HCCHAR6_EPTYP) | ((val << 18) & OTG_FS_HOST_FS_HCCHAR6_EPTYP);
}
inline void otg_fs_host_fs_hcchar6_set_epnum(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR6 = (p->FS_HCCHAR6 & ~OTG_FS_HOST_FS_HCCHAR6_EPNUM) | ((val << 11) & OTG_FS_HOST_FS_HCCHAR6_EPNUM);
}
inline void otg_fs_host_fs_hcchar6_set_mpsiz(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR6 = (p->FS_HCCHAR6 & ~OTG_FS_HOST_FS_HCCHAR6_MPSIZ) | ((val << 0) & OTG_FS_HOST_FS_HCCHAR6_MPSIZ);
}
inline uint32_t otg_fs_host_fs_hcchar6_get_dad(struct OTG_FS_HOST_Type* p) { return (p->FS_HCCHAR6 & OTG_FS_HOST_FS_HCCHAR6_DAD) >> 22; }
inline uint32_t otg_fs_host_fs_hcchar6_get_mcnt(struct OTG_FS_HOST_Type* p) { return (p->FS_HCCHAR6 & OTG_FS_HOST_FS_HCCHAR6_MCNT) >> 20; }
inline uint32_t otg_fs_host_fs_hcchar6_get_eptyp(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCCHAR6 & OTG_FS_HOST_FS_HCCHAR6_EPTYP) >> 18;
}
inline uint32_t otg_fs_host_fs_hcchar6_get_epnum(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCCHAR6 & OTG_FS_HOST_FS_HCCHAR6_EPNUM) >> 11;
}
inline uint32_t otg_fs_host_fs_hcchar6_get_mpsiz(struct OTG_FS_HOST_Type* p) { return (p->FS_HCCHAR6 & OTG_FS_HOST_FS_HCCHAR6_MPSIZ) >> 0; }

// OTG_FS_HOST->FS_HCINT6 OTG_FS host channel-6 interrupt register (OTG_FS_HCINT6)
enum {
	OTG_FS_HOST_FS_HCINT6_DTERR = 1UL << 10, // Data toggle error
	OTG_FS_HOST_FS_HCINT6_FRMOR = 1UL << 9,  // Frame overrun
	OTG_FS_HOST_FS_HCINT6_BBERR = 1UL << 8,  // Babble error
	OTG_FS_HOST_FS_HCINT6_TXERR = 1UL << 7,  // Transaction error
	OTG_FS_HOST_FS_HCINT6_ACK   = 1UL << 5,  // ACK response received/transmitted interrupt
	OTG_FS_HOST_FS_HCINT6_NAK   = 1UL << 4,  // NAK response received interrupt
	OTG_FS_HOST_FS_HCINT6_STALL = 1UL << 3,  // STALL response received interrupt
	OTG_FS_HOST_FS_HCINT6_CHH   = 1UL << 1,  // Channel halted
	OTG_FS_HOST_FS_HCINT6_XFRC  = 1UL << 0,  // Transfer completed
};

// OTG_FS_HOST->FS_HCINTMSK6 OTG_FS host channel-6 mask register (OTG_FS_HCINTMSK6)
enum {
	OTG_FS_HOST_FS_HCINTMSK6_DTERRM = 1UL << 10, // Data toggle error mask
	OTG_FS_HOST_FS_HCINTMSK6_FRMORM = 1UL << 9,  // Frame overrun mask
	OTG_FS_HOST_FS_HCINTMSK6_BBERRM = 1UL << 8,  // Babble error mask
	OTG_FS_HOST_FS_HCINTMSK6_TXERRM = 1UL << 7,  // Transaction error mask
	OTG_FS_HOST_FS_HCINTMSK6_NYET   = 1UL << 6,  // response received interrupt mask
	OTG_FS_HOST_FS_HCINTMSK6_ACKM   = 1UL << 5,  // ACK response received/transmitted interrupt mask
	OTG_FS_HOST_FS_HCINTMSK6_NAKM   = 1UL << 4,  // NAK response received interrupt mask
	OTG_FS_HOST_FS_HCINTMSK6_STALLM = 1UL << 3,  // STALL response received interrupt mask
	OTG_FS_HOST_FS_HCINTMSK6_CHHM   = 1UL << 1,  // Channel halted mask
	OTG_FS_HOST_FS_HCINTMSK6_XFRCM  = 1UL << 0,  // Transfer completed mask
};

// OTG_FS_HOST->FS_HCTSIZ6 OTG_FS host channel-6 transfer size register
enum {
	OTG_FS_HOST_FS_HCTSIZ6_DPID   = ((1UL << 2) - 1) << 29,  // Data PID
	OTG_FS_HOST_FS_HCTSIZ6_PKTCNT = ((1UL << 10) - 1) << 19, // Packet count
	OTG_FS_HOST_FS_HCTSIZ6_XFRSIZ = ((1UL << 19) - 1) << 0,  // Transfer size
};
inline void otg_fs_host_fs_hctsiz6_set_dpid(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCTSIZ6 = (p->FS_HCTSIZ6 & ~OTG_FS_HOST_FS_HCTSIZ6_DPID) | ((val << 29) & OTG_FS_HOST_FS_HCTSIZ6_DPID);
}
inline void otg_fs_host_fs_hctsiz6_set_pktcnt(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCTSIZ6 = (p->FS_HCTSIZ6 & ~OTG_FS_HOST_FS_HCTSIZ6_PKTCNT) | ((val << 19) & OTG_FS_HOST_FS_HCTSIZ6_PKTCNT);
}
inline void otg_fs_host_fs_hctsiz6_set_xfrsiz(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCTSIZ6 = (p->FS_HCTSIZ6 & ~OTG_FS_HOST_FS_HCTSIZ6_XFRSIZ) | ((val << 0) & OTG_FS_HOST_FS_HCTSIZ6_XFRSIZ);
}
inline uint32_t otg_fs_host_fs_hctsiz6_get_dpid(struct OTG_FS_HOST_Type* p) { return (p->FS_HCTSIZ6 & OTG_FS_HOST_FS_HCTSIZ6_DPID) >> 29; }
inline uint32_t otg_fs_host_fs_hctsiz6_get_pktcnt(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCTSIZ6 & OTG_FS_HOST_FS_HCTSIZ6_PKTCNT) >> 19;
}
inline uint32_t otg_fs_host_fs_hctsiz6_get_xfrsiz(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCTSIZ6 & OTG_FS_HOST_FS_HCTSIZ6_XFRSIZ) >> 0;
}

// OTG_FS_HOST->FS_HCCHAR7 OTG_FS host channel-7 characteristics register (OTG_FS_HCCHAR7)
enum {
	OTG_FS_HOST_FS_HCCHAR7_CHENA  = 1UL << 31,              // Channel enable
	OTG_FS_HOST_FS_HCCHAR7_CHDIS  = 1UL << 30,              // Channel disable
	OTG_FS_HOST_FS_HCCHAR7_ODDFRM = 1UL << 29,              // Odd frame
	OTG_FS_HOST_FS_HCCHAR7_DAD    = ((1UL << 7) - 1) << 22, // Device address
	OTG_FS_HOST_FS_HCCHAR7_MCNT   = ((1UL << 2) - 1) << 20, // Multicount
	OTG_FS_HOST_FS_HCCHAR7_EPTYP  = ((1UL << 2) - 1) << 18, // Endpoint type
	OTG_FS_HOST_FS_HCCHAR7_LSDEV  = 1UL << 17,              // Low-speed device
	OTG_FS_HOST_FS_HCCHAR7_EPDIR  = 1UL << 15,              // Endpoint direction
	OTG_FS_HOST_FS_HCCHAR7_EPNUM  = ((1UL << 4) - 1) << 11, // Endpoint number
	OTG_FS_HOST_FS_HCCHAR7_MPSIZ  = ((1UL << 11) - 1) << 0, // Maximum packet size
};
inline void otg_fs_host_fs_hcchar7_set_dad(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR7 = (p->FS_HCCHAR7 & ~OTG_FS_HOST_FS_HCCHAR7_DAD) | ((val << 22) & OTG_FS_HOST_FS_HCCHAR7_DAD);
}
inline void otg_fs_host_fs_hcchar7_set_mcnt(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR7 = (p->FS_HCCHAR7 & ~OTG_FS_HOST_FS_HCCHAR7_MCNT) | ((val << 20) & OTG_FS_HOST_FS_HCCHAR7_MCNT);
}
inline void otg_fs_host_fs_hcchar7_set_eptyp(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR7 = (p->FS_HCCHAR7 & ~OTG_FS_HOST_FS_HCCHAR7_EPTYP) | ((val << 18) & OTG_FS_HOST_FS_HCCHAR7_EPTYP);
}
inline void otg_fs_host_fs_hcchar7_set_epnum(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR7 = (p->FS_HCCHAR7 & ~OTG_FS_HOST_FS_HCCHAR7_EPNUM) | ((val << 11) & OTG_FS_HOST_FS_HCCHAR7_EPNUM);
}
inline void otg_fs_host_fs_hcchar7_set_mpsiz(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCCHAR7 = (p->FS_HCCHAR7 & ~OTG_FS_HOST_FS_HCCHAR7_MPSIZ) | ((val << 0) & OTG_FS_HOST_FS_HCCHAR7_MPSIZ);
}
inline uint32_t otg_fs_host_fs_hcchar7_get_dad(struct OTG_FS_HOST_Type* p) { return (p->FS_HCCHAR7 & OTG_FS_HOST_FS_HCCHAR7_DAD) >> 22; }
inline uint32_t otg_fs_host_fs_hcchar7_get_mcnt(struct OTG_FS_HOST_Type* p) { return (p->FS_HCCHAR7 & OTG_FS_HOST_FS_HCCHAR7_MCNT) >> 20; }
inline uint32_t otg_fs_host_fs_hcchar7_get_eptyp(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCCHAR7 & OTG_FS_HOST_FS_HCCHAR7_EPTYP) >> 18;
}
inline uint32_t otg_fs_host_fs_hcchar7_get_epnum(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCCHAR7 & OTG_FS_HOST_FS_HCCHAR7_EPNUM) >> 11;
}
inline uint32_t otg_fs_host_fs_hcchar7_get_mpsiz(struct OTG_FS_HOST_Type* p) { return (p->FS_HCCHAR7 & OTG_FS_HOST_FS_HCCHAR7_MPSIZ) >> 0; }

// OTG_FS_HOST->FS_HCINT7 OTG_FS host channel-7 interrupt register (OTG_FS_HCINT7)
enum {
	OTG_FS_HOST_FS_HCINT7_DTERR = 1UL << 10, // Data toggle error
	OTG_FS_HOST_FS_HCINT7_FRMOR = 1UL << 9,  // Frame overrun
	OTG_FS_HOST_FS_HCINT7_BBERR = 1UL << 8,  // Babble error
	OTG_FS_HOST_FS_HCINT7_TXERR = 1UL << 7,  // Transaction error
	OTG_FS_HOST_FS_HCINT7_ACK   = 1UL << 5,  // ACK response received/transmitted interrupt
	OTG_FS_HOST_FS_HCINT7_NAK   = 1UL << 4,  // NAK response received interrupt
	OTG_FS_HOST_FS_HCINT7_STALL = 1UL << 3,  // STALL response received interrupt
	OTG_FS_HOST_FS_HCINT7_CHH   = 1UL << 1,  // Channel halted
	OTG_FS_HOST_FS_HCINT7_XFRC  = 1UL << 0,  // Transfer completed
};

// OTG_FS_HOST->FS_HCINTMSK7 OTG_FS host channel-7 mask register (OTG_FS_HCINTMSK7)
enum {
	OTG_FS_HOST_FS_HCINTMSK7_DTERRM = 1UL << 10, // Data toggle error mask
	OTG_FS_HOST_FS_HCINTMSK7_FRMORM = 1UL << 9,  // Frame overrun mask
	OTG_FS_HOST_FS_HCINTMSK7_BBERRM = 1UL << 8,  // Babble error mask
	OTG_FS_HOST_FS_HCINTMSK7_TXERRM = 1UL << 7,  // Transaction error mask
	OTG_FS_HOST_FS_HCINTMSK7_NYET   = 1UL << 6,  // response received interrupt mask
	OTG_FS_HOST_FS_HCINTMSK7_ACKM   = 1UL << 5,  // ACK response received/transmitted interrupt mask
	OTG_FS_HOST_FS_HCINTMSK7_NAKM   = 1UL << 4,  // NAK response received interrupt mask
	OTG_FS_HOST_FS_HCINTMSK7_STALLM = 1UL << 3,  // STALL response received interrupt mask
	OTG_FS_HOST_FS_HCINTMSK7_CHHM   = 1UL << 1,  // Channel halted mask
	OTG_FS_HOST_FS_HCINTMSK7_XFRCM  = 1UL << 0,  // Transfer completed mask
};

// OTG_FS_HOST->FS_HCTSIZ7 OTG_FS host channel-7 transfer size register
enum {
	OTG_FS_HOST_FS_HCTSIZ7_DPID   = ((1UL << 2) - 1) << 29,  // Data PID
	OTG_FS_HOST_FS_HCTSIZ7_PKTCNT = ((1UL << 10) - 1) << 19, // Packet count
	OTG_FS_HOST_FS_HCTSIZ7_XFRSIZ = ((1UL << 19) - 1) << 0,  // Transfer size
};
inline void otg_fs_host_fs_hctsiz7_set_dpid(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCTSIZ7 = (p->FS_HCTSIZ7 & ~OTG_FS_HOST_FS_HCTSIZ7_DPID) | ((val << 29) & OTG_FS_HOST_FS_HCTSIZ7_DPID);
}
inline void otg_fs_host_fs_hctsiz7_set_pktcnt(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCTSIZ7 = (p->FS_HCTSIZ7 & ~OTG_FS_HOST_FS_HCTSIZ7_PKTCNT) | ((val << 19) & OTG_FS_HOST_FS_HCTSIZ7_PKTCNT);
}
inline void otg_fs_host_fs_hctsiz7_set_xfrsiz(struct OTG_FS_HOST_Type* p, uint32_t val) {
	p->FS_HCTSIZ7 = (p->FS_HCTSIZ7 & ~OTG_FS_HOST_FS_HCTSIZ7_XFRSIZ) | ((val << 0) & OTG_FS_HOST_FS_HCTSIZ7_XFRSIZ);
}
inline uint32_t otg_fs_host_fs_hctsiz7_get_dpid(struct OTG_FS_HOST_Type* p) { return (p->FS_HCTSIZ7 & OTG_FS_HOST_FS_HCTSIZ7_DPID) >> 29; }
inline uint32_t otg_fs_host_fs_hctsiz7_get_pktcnt(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCTSIZ7 & OTG_FS_HOST_FS_HCTSIZ7_PKTCNT) >> 19;
}
inline uint32_t otg_fs_host_fs_hctsiz7_get_xfrsiz(struct OTG_FS_HOST_Type* p) {
	return (p->FS_HCTSIZ7 & OTG_FS_HOST_FS_HCTSIZ7_XFRSIZ) >> 0;
}

/* USB on the go full speed */
struct OTG_FS_PWRCLK_Type {
	__IO uint8_t FS_PCGCCTL; // @0 OTG_FS power and clock gating control register
};

// OTG_FS_PWRCLK->FS_PCGCCTL OTG_FS power and clock gating control register
enum {
	OTG_FS_PWRCLK_FS_PCGCCTL_PHYSUSP  = 1UL << 4, // PHY Suspended
	OTG_FS_PWRCLK_FS_PCGCCTL_GATEHCLK = 1UL << 1, // Gate HCLK
	OTG_FS_PWRCLK_FS_PCGCCTL_STPPCLK  = 1UL << 0, // Stop PHY clock
};

/* Power control */
struct PWR_Type {
	__IO uint16_t CR;           // @0 power control register
	uint8_t       RESERVED0[2]; // @2
	__IO uint16_t CSR;          // @4 power control/status register
};

// PWR->CR power control register
enum {
	PWR_CR_VOS    = ((1UL << 2) - 1) << 14, // Regulator voltage scaling output selection
	PWR_CR_ADCDC1 = 1UL << 13,              // ADCDC1
	PWR_CR_FPDS   = 1UL << 9,               // Flash power down in Stop mode
	PWR_CR_DBP    = 1UL << 8,               // Disable backup domain write protection
	PWR_CR_PLS    = ((1UL << 3) - 1) << 5,  // PVD level selection
	PWR_CR_PVDE   = 1UL << 4,               // Power voltage detector enable
	PWR_CR_CSBF   = 1UL << 3,               // Clear standby flag
	PWR_CR_CWUF   = 1UL << 2,               // Clear wakeup flag
	PWR_CR_PDDS   = 1UL << 1,               // Power down deepsleep
	PWR_CR_LPDS   = 1UL << 0,               // Low-power deep sleep
};
inline void     pwr_cr_set_vos(struct PWR_Type* p, uint32_t val) { p->CR = (p->CR & ~PWR_CR_VOS) | ((val << 14) & PWR_CR_VOS); }
inline void     pwr_cr_set_pls(struct PWR_Type* p, uint32_t val) { p->CR = (p->CR & ~PWR_CR_PLS) | ((val << 5) & PWR_CR_PLS); }
inline uint32_t pwr_cr_get_vos(struct PWR_Type* p) { return (p->CR & PWR_CR_VOS) >> 14; }
inline uint32_t pwr_cr_get_pls(struct PWR_Type* p) { return (p->CR & PWR_CR_PLS) >> 5; }

// PWR->CSR power control/status register
enum {
	PWR_CSR_VOSRDY = 1UL << 14, // Regulator voltage scaling output selection ready bit
	PWR_CSR_BRE    = 1UL << 9,  // Backup regulator enable
	PWR_CSR_EWUP   = 1UL << 8,  // Enable WKUP pin
	PWR_CSR_BRR    = 1UL << 3,  // Backup regulator ready
	PWR_CSR_PVDO   = 1UL << 2,  // PVD output
	PWR_CSR_SBF    = 1UL << 1,  // Standby flag
	PWR_CSR_WUF    = 1UL << 0,  // Wakeup flag
};

/* Reset and clock control */
struct RCC_Type {
	__IO uint32_t CR;           // @0 clock control register
	__IO uint32_t PLLCFGR;      // @4 PLL configuration register
	__IO uint32_t CFGR;         // @8 clock configuration register
	__IO uint32_t CIR;          // @12 clock interrupt register
	__IO uint32_t AHB1RSTR;     // @16 AHB1 peripheral reset register
	__IO uint8_t AHB2RSTR;      // @20 AHB2 peripheral reset register
	uint8_t      RESERVED0[11]; // @21
	__IO uint32_t APB1RSTR;     // @32 APB1 peripheral reset register
	__IO uint32_t APB2RSTR;     // @36 APB2 peripheral reset register
	uint8_t       RESERVED1[8]; // @40
	__IO uint32_t AHB1ENR;      // @48 AHB1 peripheral clock register
	__IO uint8_t AHB2ENR;       // @52 AHB2 peripheral clock enable register
	uint8_t      RESERVED2[11]; // @53
	__IO uint32_t APB1ENR;      // @64 APB1 peripheral clock enable register
	__IO uint32_t APB2ENR;      // @68 APB2 peripheral clock enable register
	uint8_t       RESERVED3[8]; // @72
	__IO uint32_t AHB1LPENR;    // @80 AHB1 peripheral clock enable in low power mode register
	__IO uint8_t AHB2LPENR;     // @84 AHB2 peripheral clock enable in low power mode register
	uint8_t      RESERVED4[11]; // @85
	__IO uint32_t APB1LPENR;    // @96 APB1 peripheral clock enable in low power mode register
	__IO uint32_t APB2LPENR;    // @100 APB2 peripheral clock enabled in low power mode register
	uint8_t       RESERVED5[8]; // @104
	__IO uint32_t BDCR;         // @112 Backup domain control register
	__IO uint32_t CSR;          // @116 clock control & status register
	uint8_t       RESERVED6[8]; // @120
	__IO uint32_t SSCGR;        // @128 spread spectrum clock generation register
	__IO uint32_t PLLI2SCFGR;   // @132 PLLI2S configuration register
};

// RCC->CR clock control register
enum {
	RCC_CR_PLLI2SRDY = 1UL << 27,             // PLLI2S clock ready flag
	RCC_CR_PLLI2SON  = 1UL << 26,             // PLLI2S enable
	RCC_CR_PLLRDY    = 1UL << 25,             // Main PLL (PLL) clock ready flag
	RCC_CR_PLLON     = 1UL << 24,             // Main PLL (PLL) enable
	RCC_CR_CSSON     = 1UL << 19,             // Clock security system enable
	RCC_CR_HSEBYP    = 1UL << 18,             // HSE clock bypass
	RCC_CR_HSERDY    = 1UL << 17,             // HSE clock ready flag
	RCC_CR_HSEON     = 1UL << 16,             // HSE clock enable
	RCC_CR_HSICAL    = ((1UL << 8) - 1) << 8, // Internal high-speed clock calibration
	RCC_CR_HSITRIM   = ((1UL << 5) - 1) << 3, // Internal high-speed clock trimming
	RCC_CR_HSIRDY    = 1UL << 1,              // Internal high-speed clock ready flag
	RCC_CR_HSION     = 1UL << 0,              // Internal high-speed clock enable
};
inline void     rcc_cr_set_hsical(struct RCC_Type* p, uint32_t val) { p->CR = (p->CR & ~RCC_CR_HSICAL) | ((val << 8) & RCC_CR_HSICAL); }
inline void     rcc_cr_set_hsitrim(struct RCC_Type* p, uint32_t val) { p->CR = (p->CR & ~RCC_CR_HSITRIM) | ((val << 3) & RCC_CR_HSITRIM); }
inline uint32_t rcc_cr_get_hsical(struct RCC_Type* p) { return (p->CR & RCC_CR_HSICAL) >> 8; }
inline uint32_t rcc_cr_get_hsitrim(struct RCC_Type* p) { return (p->CR & RCC_CR_HSITRIM) >> 3; }

// RCC->PLLCFGR PLL configuration register
enum {
	RCC_PLLCFGR_PLLQ   = ((1UL << 4) - 1) << 24, // Main PLL (PLL) division factor for USB OTG FS, SDIO and random number generator clocks
	RCC_PLLCFGR_PLLSRC = 1UL << 22,              // Main PLL(PLL) and audio PLL (PLLI2S) entry clock source
	RCC_PLLCFGR_PLLP   = ((1UL << 2) - 1) << 16, // Main PLL (PLL) division factor for main system clock
	RCC_PLLCFGR_PLLN   = ((1UL << 9) - 1) << 6,  // Main PLL (PLL) multiplication factor for VCO
	RCC_PLLCFGR_PLLM   = ((1UL << 6) - 1) << 0,  // Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock
};
inline void rcc_pllcfgr_set_pllq(struct RCC_Type* p, uint32_t val) {
	p->PLLCFGR = (p->PLLCFGR & ~RCC_PLLCFGR_PLLQ) | ((val << 24) & RCC_PLLCFGR_PLLQ);
}
inline void rcc_pllcfgr_set_pllp(struct RCC_Type* p, uint32_t val) {
	p->PLLCFGR = (p->PLLCFGR & ~RCC_PLLCFGR_PLLP) | ((val << 16) & RCC_PLLCFGR_PLLP);
}
inline void rcc_pllcfgr_set_plln(struct RCC_Type* p, uint32_t val) {
	p->PLLCFGR = (p->PLLCFGR & ~RCC_PLLCFGR_PLLN) | ((val << 6) & RCC_PLLCFGR_PLLN);
}
inline void rcc_pllcfgr_set_pllm(struct RCC_Type* p, uint32_t val) {
	p->PLLCFGR = (p->PLLCFGR & ~RCC_PLLCFGR_PLLM) | ((val << 0) & RCC_PLLCFGR_PLLM);
}
inline uint32_t rcc_pllcfgr_get_pllq(struct RCC_Type* p) { return (p->PLLCFGR & RCC_PLLCFGR_PLLQ) >> 24; }
inline uint32_t rcc_pllcfgr_get_pllp(struct RCC_Type* p) { return (p->PLLCFGR & RCC_PLLCFGR_PLLP) >> 16; }
inline uint32_t rcc_pllcfgr_get_plln(struct RCC_Type* p) { return (p->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6; }
inline uint32_t rcc_pllcfgr_get_pllm(struct RCC_Type* p) { return (p->PLLCFGR & RCC_PLLCFGR_PLLM) >> 0; }

// RCC->CFGR clock configuration register
enum {
	RCC_CFGR_MCO2    = ((1UL << 2) - 1) << 30, // Microcontroller clock output 2
	RCC_CFGR_MCO2PRE = ((1UL << 3) - 1) << 27, // MCO2 prescaler
	RCC_CFGR_MCO1PRE = ((1UL << 3) - 1) << 24, // MCO1 prescaler
	RCC_CFGR_I2SSRC  = 1UL << 23,              // I2S clock selection
	RCC_CFGR_MCO1    = ((1UL << 2) - 1) << 21, // Microcontroller clock output 1
	RCC_CFGR_RTCPRE  = ((1UL << 5) - 1) << 16, // HSE division factor for RTC clock
	RCC_CFGR_PPRE2   = ((1UL << 3) - 1) << 13, // APB high-speed prescaler (APB2)
	RCC_CFGR_PPRE1   = ((1UL << 3) - 1) << 10, // APB Low speed prescaler (APB1)
	RCC_CFGR_HPRE    = ((1UL << 4) - 1) << 4,  // AHB prescaler
	RCC_CFGR_SWS     = ((1UL << 2) - 1) << 2,  // System clock switch status
	RCC_CFGR_SW      = ((1UL << 2) - 1) << 0,  // System clock switch
};
inline void rcc_cfgr_set_mco2(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_MCO2) | ((val << 30) & RCC_CFGR_MCO2); }
inline void rcc_cfgr_set_mco2pre(struct RCC_Type* p, uint32_t val) {
	p->CFGR = (p->CFGR & ~RCC_CFGR_MCO2PRE) | ((val << 27) & RCC_CFGR_MCO2PRE);
}
inline void rcc_cfgr_set_mco1pre(struct RCC_Type* p, uint32_t val) {
	p->CFGR = (p->CFGR & ~RCC_CFGR_MCO1PRE) | ((val << 24) & RCC_CFGR_MCO1PRE);
}
inline void rcc_cfgr_set_mco1(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_MCO1) | ((val << 21) & RCC_CFGR_MCO1); }
inline void rcc_cfgr_set_rtcpre(struct RCC_Type* p, uint32_t val) {
	p->CFGR = (p->CFGR & ~RCC_CFGR_RTCPRE) | ((val << 16) & RCC_CFGR_RTCPRE);
}
inline void rcc_cfgr_set_ppre2(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_PPRE2) | ((val << 13) & RCC_CFGR_PPRE2); }
inline void rcc_cfgr_set_ppre1(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_PPRE1) | ((val << 10) & RCC_CFGR_PPRE1); }
inline void rcc_cfgr_set_hpre(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_HPRE) | ((val << 4) & RCC_CFGR_HPRE); }
inline void rcc_cfgr_set_sws(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_SWS) | ((val << 2) & RCC_CFGR_SWS); }
inline void rcc_cfgr_set_sw(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_SW) | ((val << 0) & RCC_CFGR_SW); }
inline uint32_t rcc_cfgr_get_mco2(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_MCO2) >> 30; }
inline uint32_t rcc_cfgr_get_mco2pre(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_MCO2PRE) >> 27; }
inline uint32_t rcc_cfgr_get_mco1pre(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_MCO1PRE) >> 24; }
inline uint32_t rcc_cfgr_get_mco1(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_MCO1) >> 21; }
inline uint32_t rcc_cfgr_get_rtcpre(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_RTCPRE) >> 16; }
inline uint32_t rcc_cfgr_get_ppre2(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_PPRE2) >> 13; }
inline uint32_t rcc_cfgr_get_ppre1(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_PPRE1) >> 10; }
inline uint32_t rcc_cfgr_get_hpre(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_HPRE) >> 4; }
inline uint32_t rcc_cfgr_get_sws(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_SWS) >> 2; }
inline uint32_t rcc_cfgr_get_sw(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_SW) >> 0; }

// RCC->CIR clock interrupt register
enum {
	RCC_CIR_CSSC        = 1UL << 23, // Clock security system interrupt clear
	RCC_CIR_PLLI2SRDYC  = 1UL << 21, // PLLI2S ready interrupt clear
	RCC_CIR_PLLRDYC     = 1UL << 20, // Main PLL(PLL) ready interrupt clear
	RCC_CIR_HSERDYC     = 1UL << 19, // HSE ready interrupt clear
	RCC_CIR_HSIRDYC     = 1UL << 18, // HSI ready interrupt clear
	RCC_CIR_LSERDYC     = 1UL << 17, // LSE ready interrupt clear
	RCC_CIR_LSIRDYC     = 1UL << 16, // LSI ready interrupt clear
	RCC_CIR_PLLI2SRDYIE = 1UL << 13, // PLLI2S ready interrupt enable
	RCC_CIR_PLLRDYIE    = 1UL << 12, // Main PLL (PLL) ready interrupt enable
	RCC_CIR_HSERDYIE    = 1UL << 11, // HSE ready interrupt enable
	RCC_CIR_HSIRDYIE    = 1UL << 10, // HSI ready interrupt enable
	RCC_CIR_LSERDYIE    = 1UL << 9,  // LSE ready interrupt enable
	RCC_CIR_LSIRDYIE    = 1UL << 8,  // LSI ready interrupt enable
	RCC_CIR_CSSF        = 1UL << 7,  // Clock security system interrupt flag
	RCC_CIR_PLLI2SRDYF  = 1UL << 5,  // PLLI2S ready interrupt flag
	RCC_CIR_PLLRDYF     = 1UL << 4,  // Main PLL (PLL) ready interrupt flag
	RCC_CIR_HSERDYF     = 1UL << 3,  // HSE ready interrupt flag
	RCC_CIR_HSIRDYF     = 1UL << 2,  // HSI ready interrupt flag
	RCC_CIR_LSERDYF     = 1UL << 1,  // LSE ready interrupt flag
	RCC_CIR_LSIRDYF     = 1UL << 0,  // LSI ready interrupt flag
};

// RCC->AHB1RSTR AHB1 peripheral reset register
enum {
	RCC_AHB1RSTR_DMA2RST  = 1UL << 22, // DMA2 reset
	RCC_AHB1RSTR_DMA1RST  = 1UL << 21, // DMA2 reset
	RCC_AHB1RSTR_CRCRST   = 1UL << 12, // CRC reset
	RCC_AHB1RSTR_GPIOHRST = 1UL << 7,  // IO port H reset
	RCC_AHB1RSTR_GPIOERST = 1UL << 4,  // IO port E reset
	RCC_AHB1RSTR_GPIODRST = 1UL << 3,  // IO port D reset
	RCC_AHB1RSTR_GPIOCRST = 1UL << 2,  // IO port C reset
	RCC_AHB1RSTR_GPIOBRST = 1UL << 1,  // IO port B reset
	RCC_AHB1RSTR_GPIOARST = 1UL << 0,  // IO port A reset
};

// RCC->AHB2RSTR AHB2 peripheral reset register
enum {
	RCC_AHB2RSTR_OTGFSRST = 1UL << 7, // USB OTG FS module reset
};

// RCC->APB1RSTR APB1 peripheral reset register
enum {
	RCC_APB1RSTR_PWRRST   = 1UL << 28, // Power interface reset
	RCC_APB1RSTR_I2C3RST  = 1UL << 23, // I2C3 reset
	RCC_APB1RSTR_I2C2RST  = 1UL << 22, // I2C 2 reset
	RCC_APB1RSTR_I2C1RST  = 1UL << 21, // I2C 1 reset
	RCC_APB1RSTR_UART2RST = 1UL << 17, // USART 2 reset
	RCC_APB1RSTR_SPI3RST  = 1UL << 15, // SPI 3 reset
	RCC_APB1RSTR_SPI2RST  = 1UL << 14, // SPI 2 reset
	RCC_APB1RSTR_WWDGRST  = 1UL << 11, // Window watchdog reset
	RCC_APB1RSTR_TIM5RST  = 1UL << 3,  // TIM5 reset
	RCC_APB1RSTR_TIM4RST  = 1UL << 2,  // TIM4 reset
	RCC_APB1RSTR_TIM3RST  = 1UL << 1,  // TIM3 reset
	RCC_APB1RSTR_TIM2RST  = 1UL << 0,  // TIM2 reset
};

// RCC->APB2RSTR APB2 peripheral reset register
enum {
	RCC_APB2RSTR_TIM11RST  = 1UL << 18, // TIM11 reset
	RCC_APB2RSTR_TIM10RST  = 1UL << 17, // TIM10 reset
	RCC_APB2RSTR_TIM9RST   = 1UL << 16, // TIM9 reset
	RCC_APB2RSTR_SYSCFGRST = 1UL << 14, // System configuration controller reset
	RCC_APB2RSTR_SPI1RST   = 1UL << 12, // SPI 1 reset
	RCC_APB2RSTR_SDIORST   = 1UL << 11, // SDIO reset
	RCC_APB2RSTR_ADCRST    = 1UL << 8,  // ADC interface reset (common to all ADCs)
	RCC_APB2RSTR_USART6RST = 1UL << 5,  // USART6 reset
	RCC_APB2RSTR_USART1RST = 1UL << 4,  // USART1 reset
	RCC_APB2RSTR_TIM1RST   = 1UL << 0,  // TIM1 reset
};

// RCC->AHB1ENR AHB1 peripheral clock register
enum {
	RCC_AHB1ENR_DMA2EN  = 1UL << 22, // DMA2 clock enable
	RCC_AHB1ENR_DMA1EN  = 1UL << 21, // DMA1 clock enable
	RCC_AHB1ENR_CRCEN   = 1UL << 12, // CRC clock enable
	RCC_AHB1ENR_GPIOHEN = 1UL << 7,  // IO port H clock enable
	RCC_AHB1ENR_GPIOEEN = 1UL << 4,  // IO port E clock enable
	RCC_AHB1ENR_GPIODEN = 1UL << 3,  // IO port D clock enable
	RCC_AHB1ENR_GPIOCEN = 1UL << 2,  // IO port C clock enable
	RCC_AHB1ENR_GPIOBEN = 1UL << 1,  // IO port B clock enable
	RCC_AHB1ENR_GPIOAEN = 1UL << 0,  // IO port A clock enable
};

// RCC->AHB2ENR AHB2 peripheral clock enable register
enum {
	RCC_AHB2ENR_OTGFSEN = 1UL << 7, // USB OTG FS clock enable
};

// RCC->APB1ENR APB1 peripheral clock enable register
enum {
	RCC_APB1ENR_PWREN    = 1UL << 28, // Power interface clock enable
	RCC_APB1ENR_I2C3EN   = 1UL << 23, // I2C3 clock enable
	RCC_APB1ENR_I2C2EN   = 1UL << 22, // I2C2 clock enable
	RCC_APB1ENR_I2C1EN   = 1UL << 21, // I2C1 clock enable
	RCC_APB1ENR_USART2EN = 1UL << 17, // USART 2 clock enable
	RCC_APB1ENR_SPI3EN   = 1UL << 15, // SPI3 clock enable
	RCC_APB1ENR_SPI2EN   = 1UL << 14, // SPI2 clock enable
	RCC_APB1ENR_WWDGEN   = 1UL << 11, // Window watchdog clock enable
	RCC_APB1ENR_TIM5EN   = 1UL << 3,  // TIM5 clock enable
	RCC_APB1ENR_TIM4EN   = 1UL << 2,  // TIM4 clock enable
	RCC_APB1ENR_TIM3EN   = 1UL << 1,  // TIM3 clock enable
	RCC_APB1ENR_TIM2EN   = 1UL << 0,  // TIM2 clock enable
};

// RCC->APB2ENR APB2 peripheral clock enable register
enum {
	RCC_APB2ENR_TIM11EN  = 1UL << 18, // TIM11 clock enable
	RCC_APB2ENR_TIM10EN  = 1UL << 17, // TIM10 clock enable
	RCC_APB2ENR_TIM9EN   = 1UL << 16, // TIM9 clock enable
	RCC_APB2ENR_SYSCFGEN = 1UL << 14, // System configuration controller clock enable
	RCC_APB2ENR_SPI4EN   = 1UL << 13, // SPI4 clock enable
	RCC_APB2ENR_SPI1EN   = 1UL << 12, // SPI1 clock enable
	RCC_APB2ENR_SDIOEN   = 1UL << 11, // SDIO clock enable
	RCC_APB2ENR_ADC1EN   = 1UL << 8,  // ADC1 clock enable
	RCC_APB2ENR_USART6EN = 1UL << 5,  // USART6 clock enable
	RCC_APB2ENR_USART1EN = 1UL << 4,  // USART1 clock enable
	RCC_APB2ENR_TIM1EN   = 1UL << 0,  // TIM1 clock enable
};

// RCC->AHB1LPENR AHB1 peripheral clock enable in low power mode register
enum {
	RCC_AHB1LPENR_DMA2LPEN  = 1UL << 22, // DMA2 clock enable during Sleep mode
	RCC_AHB1LPENR_DMA1LPEN  = 1UL << 21, // DMA1 clock enable during Sleep mode
	RCC_AHB1LPENR_SRAM1LPEN = 1UL << 16, // SRAM 1interface clock enable during Sleep mode
	RCC_AHB1LPENR_FLITFLPEN = 1UL << 15, // Flash interface clock enable during Sleep mode
	RCC_AHB1LPENR_CRCLPEN   = 1UL << 12, // CRC clock enable during Sleep mode
	RCC_AHB1LPENR_GPIOHLPEN = 1UL << 7,  // IO port H clock enable during Sleep mode
	RCC_AHB1LPENR_GPIOELPEN = 1UL << 4,  // IO port E clock enable during Sleep mode
	RCC_AHB1LPENR_GPIODLPEN = 1UL << 3,  // IO port D clock enable during Sleep mode
	RCC_AHB1LPENR_GPIOCLPEN = 1UL << 2,  // IO port C clock enable during Sleep mode
	RCC_AHB1LPENR_GPIOBLPEN = 1UL << 1,  // IO port B clock enable during Sleep mode
	RCC_AHB1LPENR_GPIOALPEN = 1UL << 0,  // IO port A clock enable during sleep mode
};

// RCC->AHB2LPENR AHB2 peripheral clock enable in low power mode register
enum {
	RCC_AHB2LPENR_OTGFSLPEN = 1UL << 7, // USB OTG FS clock enable during Sleep mode
};

// RCC->APB1LPENR APB1 peripheral clock enable in low power mode register
enum {
	RCC_APB1LPENR_PWRLPEN    = 1UL << 28, // Power interface clock enable during Sleep mode
	RCC_APB1LPENR_I2C3LPEN   = 1UL << 23, // I2C3 clock enable during Sleep mode
	RCC_APB1LPENR_I2C2LPEN   = 1UL << 22, // I2C2 clock enable during Sleep mode
	RCC_APB1LPENR_I2C1LPEN   = 1UL << 21, // I2C1 clock enable during Sleep mode
	RCC_APB1LPENR_USART2LPEN = 1UL << 17, // USART2 clock enable during Sleep mode
	RCC_APB1LPENR_SPI3LPEN   = 1UL << 15, // SPI3 clock enable during Sleep mode
	RCC_APB1LPENR_SPI2LPEN   = 1UL << 14, // SPI2 clock enable during Sleep mode
	RCC_APB1LPENR_WWDGLPEN   = 1UL << 11, // Window watchdog clock enable during Sleep mode
	RCC_APB1LPENR_TIM5LPEN   = 1UL << 3,  // TIM5 clock enable during Sleep mode
	RCC_APB1LPENR_TIM4LPEN   = 1UL << 2,  // TIM4 clock enable during Sleep mode
	RCC_APB1LPENR_TIM3LPEN   = 1UL << 1,  // TIM3 clock enable during Sleep mode
	RCC_APB1LPENR_TIM2LPEN   = 1UL << 0,  // TIM2 clock enable during Sleep mode
};

// RCC->APB2LPENR APB2 peripheral clock enabled in low power mode register
enum {
	RCC_APB2LPENR_TIM11LPEN  = 1UL << 18, // TIM11 clock enable during Sleep mode
	RCC_APB2LPENR_TIM10LPEN  = 1UL << 17, // TIM10 clock enable during Sleep mode
	RCC_APB2LPENR_TIM9LPEN   = 1UL << 16, // TIM9 clock enable during sleep mode
	RCC_APB2LPENR_SYSCFGLPEN = 1UL << 14, // System configuration controller clock enable during Sleep mode
	RCC_APB2LPENR_SPI4LPEN   = 1UL << 13, // SPI4 clock enable during Sleep mode
	RCC_APB2LPENR_SPI1LPEN   = 1UL << 12, // SPI 1 clock enable during Sleep mode
	RCC_APB2LPENR_SDIOLPEN   = 1UL << 11, // SDIO clock enable during Sleep mode
	RCC_APB2LPENR_ADC1LPEN   = 1UL << 8,  // ADC1 clock enable during Sleep mode
	RCC_APB2LPENR_USART6LPEN = 1UL << 5,  // USART6 clock enable during Sleep mode
	RCC_APB2LPENR_USART1LPEN = 1UL << 4,  // USART1 clock enable during Sleep mode
	RCC_APB2LPENR_TIM1LPEN   = 1UL << 0,  // TIM1 clock enable during Sleep mode
};

// RCC->BDCR Backup domain control register
enum {
	RCC_BDCR_BDRST   = 1UL << 16, // Backup domain software reset
	RCC_BDCR_RTCEN   = 1UL << 15, // RTC clock enable
	RCC_BDCR_RTCSEL1 = 1UL << 9,  // RTC clock source selection
	RCC_BDCR_RTCSEL0 = 1UL << 8,  // RTC clock source selection
	RCC_BDCR_LSEBYP  = 1UL << 2,  // External low-speed oscillator bypass
	RCC_BDCR_LSERDY  = 1UL << 1,  // External low-speed oscillator ready
	RCC_BDCR_LSEON   = 1UL << 0,  // External low-speed oscillator enable
};

// RCC->CSR clock control & status register
enum {
	RCC_CSR_LPWRRSTF = 1UL << 31, // Low-power reset flag
	RCC_CSR_WWDGRSTF = 1UL << 30, // Window watchdog reset flag
	RCC_CSR_WDGRSTF  = 1UL << 29, // Independent watchdog reset flag
	RCC_CSR_SFTRSTF  = 1UL << 28, // Software reset flag
	RCC_CSR_PORRSTF  = 1UL << 27, // POR/PDR reset flag
	RCC_CSR_PADRSTF  = 1UL << 26, // PIN reset flag
	RCC_CSR_BORRSTF  = 1UL << 25, // BOR reset flag
	RCC_CSR_RMVF     = 1UL << 24, // Remove reset flag
	RCC_CSR_LSIRDY   = 1UL << 1,  // Internal low-speed oscillator ready
	RCC_CSR_LSION    = 1UL << 0,  // Internal low-speed oscillator enable
};

// RCC->SSCGR spread spectrum clock generation register
enum {
	RCC_SSCGR_SSCGEN    = 1UL << 31,               // Spread spectrum modulation enable
	RCC_SSCGR_SPREADSEL = 1UL << 30,               // Spread Select
	RCC_SSCGR_INCSTEP   = ((1UL << 15) - 1) << 13, // Incrementation step
	RCC_SSCGR_MODPER    = ((1UL << 13) - 1) << 0,  // Modulation period
};
inline void rcc_sscgr_set_incstep(struct RCC_Type* p, uint32_t val) {
	p->SSCGR = (p->SSCGR & ~RCC_SSCGR_INCSTEP) | ((val << 13) & RCC_SSCGR_INCSTEP);
}
inline void rcc_sscgr_set_modper(struct RCC_Type* p, uint32_t val) {
	p->SSCGR = (p->SSCGR & ~RCC_SSCGR_MODPER) | ((val << 0) & RCC_SSCGR_MODPER);
}
inline uint32_t rcc_sscgr_get_incstep(struct RCC_Type* p) { return (p->SSCGR & RCC_SSCGR_INCSTEP) >> 13; }
inline uint32_t rcc_sscgr_get_modper(struct RCC_Type* p) { return (p->SSCGR & RCC_SSCGR_MODPER) >> 0; }

// RCC->PLLI2SCFGR PLLI2S configuration register
enum {
	RCC_PLLI2SCFGR_PLLI2SRX = ((1UL << 3) - 1) << 28, // PLLI2S division factor for I2S clocks
	RCC_PLLI2SCFGR_PLLI2SNX = ((1UL << 9) - 1) << 6,  // PLLI2S multiplication factor for VCO
};
inline void rcc_plli2scfgr_set_plli2srx(struct RCC_Type* p, uint32_t val) {
	p->PLLI2SCFGR = (p->PLLI2SCFGR & ~RCC_PLLI2SCFGR_PLLI2SRX) | ((val << 28) & RCC_PLLI2SCFGR_PLLI2SRX);
}
inline void rcc_plli2scfgr_set_plli2snx(struct RCC_Type* p, uint32_t val) {
	p->PLLI2SCFGR = (p->PLLI2SCFGR & ~RCC_PLLI2SCFGR_PLLI2SNX) | ((val << 6) & RCC_PLLI2SCFGR_PLLI2SNX);
}
inline uint32_t rcc_plli2scfgr_get_plli2srx(struct RCC_Type* p) { return (p->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SRX) >> 28; }
inline uint32_t rcc_plli2scfgr_get_plli2snx(struct RCC_Type* p) { return (p->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SNX) >> 6; }

/* Real-time clock */
struct RTC_Type {
	__IO uint32_t TR;           // @0 time register
	__IO uint32_t DR;           // @4 date register
	__IO uint32_t CR;           // @8 control register
	__IO uint32_t ISR;          // @12 initialization and status register
	__IO uint32_t PRER;         // @16 prescaler register
	__IO uint16_t WUTR;         // @20 wakeup timer register
	uint8_t       RESERVED0[2]; // @22
	__IO uint8_t CALIBR;        // @24 calibration register
	uint8_t      RESERVED1[3];  // @25
	__IO uint32_t ALRMAR;       // @28 alarm A register
	__IO uint32_t ALRMBR;       // @32 alarm B register
	__O uint8_t WPR;            // @36 write protection register
	uint8_t     RESERVED2[3];   // @37
	__I uint16_t SSR;           // @40 sub second register
	uint8_t      RESERVED3[2];  // @42
	__O uint32_t SHIFTR;        // @44 shift control register
	__I uint32_t TSTR;          // @48 time stamp time register
	__I uint16_t TSDR;          // @52 time stamp date register
	uint8_t      RESERVED4[2];  // @54
	__I uint16_t TSSSR;         // @56 timestamp sub second register
	uint8_t      RESERVED5[2];  // @58
	__IO uint16_t CALR;         // @60 calibration register
	uint8_t       RESERVED6[2]; // @62
	__IO uint32_t TAFCR;        // @64 tamper and alternate function configuration register
	__IO uint32_t ALRMASSR;     // @68 alarm A sub second register
	__IO uint32_t ALRMBSSR;     // @72 alarm B sub second register
	uint8_t       RESERVED7[4]; // @76
	__IO uint32_t BKP0R;        // @80 backup register
	__IO uint32_t BKP1R;        // @84 backup register
	__IO uint32_t BKP2R;        // @88 backup register
	__IO uint32_t BKP3R;        // @92 backup register
	__IO uint32_t BKP4R;        // @96 backup register
	__IO uint32_t BKP5R;        // @100 backup register
	__IO uint32_t BKP6R;        // @104 backup register
	__IO uint32_t BKP7R;        // @108 backup register
	__IO uint32_t BKP8R;        // @112 backup register
	__IO uint32_t BKP9R;        // @116 backup register
	__IO uint32_t BKP10R;       // @120 backup register
	__IO uint32_t BKP11R;       // @124 backup register
	__IO uint32_t BKP12R;       // @128 backup register
	__IO uint32_t BKP13R;       // @132 backup register
	__IO uint32_t BKP14R;       // @136 backup register
	__IO uint32_t BKP15R;       // @140 backup register
	__IO uint32_t BKP16R;       // @144 backup register
	__IO uint32_t BKP17R;       // @148 backup register
	__IO uint32_t BKP18R;       // @152 backup register
	__IO uint32_t BKP19R;       // @156 backup register
};

// RTC->TR time register
enum {
	RTC_TR_PM  = 1UL << 22,              // AM/PM notation
	RTC_TR_HT  = ((1UL << 2) - 1) << 20, // Hour tens in BCD format
	RTC_TR_HU  = ((1UL << 4) - 1) << 16, // Hour units in BCD format
	RTC_TR_MNT = ((1UL << 3) - 1) << 12, // Minute tens in BCD format
	RTC_TR_MNU = ((1UL << 4) - 1) << 8,  // Minute units in BCD format
	RTC_TR_ST  = ((1UL << 3) - 1) << 4,  // Second tens in BCD format
	RTC_TR_SU  = ((1UL << 4) - 1) << 0,  // Second units in BCD format
};
inline void     rtc_tr_set_ht(struct RTC_Type* p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_HT) | ((val << 20) & RTC_TR_HT); }
inline void     rtc_tr_set_hu(struct RTC_Type* p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_HU) | ((val << 16) & RTC_TR_HU); }
inline void     rtc_tr_set_mnt(struct RTC_Type* p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_MNT) | ((val << 12) & RTC_TR_MNT); }
inline void     rtc_tr_set_mnu(struct RTC_Type* p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_MNU) | ((val << 8) & RTC_TR_MNU); }
inline void     rtc_tr_set_st(struct RTC_Type* p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_ST) | ((val << 4) & RTC_TR_ST); }
inline void     rtc_tr_set_su(struct RTC_Type* p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_SU) | ((val << 0) & RTC_TR_SU); }
inline uint32_t rtc_tr_get_ht(struct RTC_Type* p) { return (p->TR & RTC_TR_HT) >> 20; }
inline uint32_t rtc_tr_get_hu(struct RTC_Type* p) { return (p->TR & RTC_TR_HU) >> 16; }
inline uint32_t rtc_tr_get_mnt(struct RTC_Type* p) { return (p->TR & RTC_TR_MNT) >> 12; }
inline uint32_t rtc_tr_get_mnu(struct RTC_Type* p) { return (p->TR & RTC_TR_MNU) >> 8; }
inline uint32_t rtc_tr_get_st(struct RTC_Type* p) { return (p->TR & RTC_TR_ST) >> 4; }
inline uint32_t rtc_tr_get_su(struct RTC_Type* p) { return (p->TR & RTC_TR_SU) >> 0; }

// RTC->DR date register
enum {
	RTC_DR_YT  = ((1UL << 4) - 1) << 20, // Year tens in BCD format
	RTC_DR_YU  = ((1UL << 4) - 1) << 16, // Year units in BCD format
	RTC_DR_WDU = ((1UL << 3) - 1) << 13, // Week day units
	RTC_DR_MT  = 1UL << 12,              // Month tens in BCD format
	RTC_DR_MU  = ((1UL << 4) - 1) << 8,  // Month units in BCD format
	RTC_DR_DT  = ((1UL << 2) - 1) << 4,  // Date tens in BCD format
	RTC_DR_DU  = ((1UL << 4) - 1) << 0,  // Date units in BCD format
};
inline void     rtc_dr_set_yt(struct RTC_Type* p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_YT) | ((val << 20) & RTC_DR_YT); }
inline void     rtc_dr_set_yu(struct RTC_Type* p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_YU) | ((val << 16) & RTC_DR_YU); }
inline void     rtc_dr_set_wdu(struct RTC_Type* p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_WDU) | ((val << 13) & RTC_DR_WDU); }
inline void     rtc_dr_set_mu(struct RTC_Type* p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_MU) | ((val << 8) & RTC_DR_MU); }
inline void     rtc_dr_set_dt(struct RTC_Type* p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_DT) | ((val << 4) & RTC_DR_DT); }
inline void     rtc_dr_set_du(struct RTC_Type* p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_DU) | ((val << 0) & RTC_DR_DU); }
inline uint32_t rtc_dr_get_yt(struct RTC_Type* p) { return (p->DR & RTC_DR_YT) >> 20; }
inline uint32_t rtc_dr_get_yu(struct RTC_Type* p) { return (p->DR & RTC_DR_YU) >> 16; }
inline uint32_t rtc_dr_get_wdu(struct RTC_Type* p) { return (p->DR & RTC_DR_WDU) >> 13; }
inline uint32_t rtc_dr_get_mu(struct RTC_Type* p) { return (p->DR & RTC_DR_MU) >> 8; }
inline uint32_t rtc_dr_get_dt(struct RTC_Type* p) { return (p->DR & RTC_DR_DT) >> 4; }
inline uint32_t rtc_dr_get_du(struct RTC_Type* p) { return (p->DR & RTC_DR_DU) >> 0; }

// RTC->CR control register
enum {
	RTC_CR_COE     = 1UL << 23,              // Calibration output enable
	RTC_CR_OSEL    = ((1UL << 2) - 1) << 21, // Output selection
	RTC_CR_POL     = 1UL << 20,              // Output polarity
	RTC_CR_COSEL   = 1UL << 19,              // Calibration Output selection
	RTC_CR_BKP     = 1UL << 18,              // Backup
	RTC_CR_SUB1H   = 1UL << 17,              // Subtract 1 hour (winter time change)
	RTC_CR_ADD1H   = 1UL << 16,              // Add 1 hour (summer time change)
	RTC_CR_TSIE    = 1UL << 15,              // Time-stamp interrupt enable
	RTC_CR_WUTIE   = 1UL << 14,              // Wakeup timer interrupt enable
	RTC_CR_ALRBIE  = 1UL << 13,              // Alarm B interrupt enable
	RTC_CR_ALRAIE  = 1UL << 12,              // Alarm A interrupt enable
	RTC_CR_TSE     = 1UL << 11,              // Time stamp enable
	RTC_CR_WUTE    = 1UL << 10,              // Wakeup timer enable
	RTC_CR_ALRBE   = 1UL << 9,               // Alarm B enable
	RTC_CR_ALRAE   = 1UL << 8,               // Alarm A enable
	RTC_CR_DCE     = 1UL << 7,               // Coarse digital calibration enable
	RTC_CR_FMT     = 1UL << 6,               // Hour format
	RTC_CR_BYPSHAD = 1UL << 5,               // Bypass the shadow registers
	RTC_CR_REFCKON = 1UL << 4,               // Reference clock detection enable (50 or 60 Hz)
	RTC_CR_TSEDGE  = 1UL << 3,               // Time-stamp event active edge
	RTC_CR_WCKSEL  = ((1UL << 3) - 1) << 0,  // Wakeup clock selection
};
inline void     rtc_cr_set_osel(struct RTC_Type* p, uint32_t val) { p->CR = (p->CR & ~RTC_CR_OSEL) | ((val << 21) & RTC_CR_OSEL); }
inline void     rtc_cr_set_wcksel(struct RTC_Type* p, uint32_t val) { p->CR = (p->CR & ~RTC_CR_WCKSEL) | ((val << 0) & RTC_CR_WCKSEL); }
inline uint32_t rtc_cr_get_osel(struct RTC_Type* p) { return (p->CR & RTC_CR_OSEL) >> 21; }
inline uint32_t rtc_cr_get_wcksel(struct RTC_Type* p) { return (p->CR & RTC_CR_WCKSEL) >> 0; }

// RTC->ISR initialization and status register
enum {
	RTC_ISR_RECALPF = 1UL << 16, // Recalibration pending Flag
	RTC_ISR_TAMP2F  = 1UL << 14, // TAMPER2 detection flag
	RTC_ISR_TAMP1F  = 1UL << 13, // Tamper detection flag
	RTC_ISR_TSOVF   = 1UL << 12, // Time-stamp overflow flag
	RTC_ISR_TSF     = 1UL << 11, // Time-stamp flag
	RTC_ISR_WUTF    = 1UL << 10, // Wakeup timer flag
	RTC_ISR_ALRBF   = 1UL << 9,  // Alarm B flag
	RTC_ISR_ALRAF   = 1UL << 8,  // Alarm A flag
	RTC_ISR_INIT    = 1UL << 7,  // Initialization mode
	RTC_ISR_INITF   = 1UL << 6,  // Initialization flag
	RTC_ISR_RSF     = 1UL << 5,  // Registers synchronization flag
	RTC_ISR_INITS   = 1UL << 4,  // Initialization status flag
	RTC_ISR_SHPF    = 1UL << 3,  // Shift operation pending
	RTC_ISR_WUTWF   = 1UL << 2,  // Wakeup timer write flag
	RTC_ISR_ALRBWF  = 1UL << 1,  // Alarm B write flag
	RTC_ISR_ALRAWF  = 1UL << 0,  // Alarm A write flag
};

// RTC->PRER prescaler register
enum {
	RTC_PRER_PREDIV_A = ((1UL << 7) - 1) << 16, // Asynchronous prescaler factor
	RTC_PRER_PREDIV_S = ((1UL << 15) - 1) << 0, // Synchronous prescaler factor
};
inline void rtc_prer_set_prediv_a(struct RTC_Type* p, uint32_t val) {
	p->PRER = (p->PRER & ~RTC_PRER_PREDIV_A) | ((val << 16) & RTC_PRER_PREDIV_A);
}
inline void rtc_prer_set_prediv_s(struct RTC_Type* p, uint32_t val) {
	p->PRER = (p->PRER & ~RTC_PRER_PREDIV_S) | ((val << 0) & RTC_PRER_PREDIV_S);
}
inline uint32_t rtc_prer_get_prediv_a(struct RTC_Type* p) { return (p->PRER & RTC_PRER_PREDIV_A) >> 16; }
inline uint32_t rtc_prer_get_prediv_s(struct RTC_Type* p) { return (p->PRER & RTC_PRER_PREDIV_S) >> 0; }

// RTC->CALIBR calibration register
enum {
	RTC_CALIBR_DCS = 1UL << 7,              // Digital calibration sign
	RTC_CALIBR_DC  = ((1UL << 5) - 1) << 0, // Digital calibration
};
inline void rtc_calibr_set_dc(struct RTC_Type* p, uint32_t val) { p->CALIBR = (p->CALIBR & ~RTC_CALIBR_DC) | ((val << 0) & RTC_CALIBR_DC); }
inline uint32_t rtc_calibr_get_dc(struct RTC_Type* p) { return (p->CALIBR & RTC_CALIBR_DC) >> 0; }

// RTC->ALRMAR alarm A register
enum {
	RTC_ALRMAR_MSK4  = 1UL << 31,              // Alarm A date mask
	RTC_ALRMAR_WDSEL = 1UL << 30,              // Week day selection
	RTC_ALRMAR_DT    = ((1UL << 2) - 1) << 28, // Date tens in BCD format
	RTC_ALRMAR_DU    = ((1UL << 4) - 1) << 24, // Date units or day in BCD format
	RTC_ALRMAR_MSK3  = 1UL << 23,              // Alarm A hours mask
	RTC_ALRMAR_PM    = 1UL << 22,              // AM/PM notation
	RTC_ALRMAR_HT    = ((1UL << 2) - 1) << 20, // Hour tens in BCD format
	RTC_ALRMAR_HU    = ((1UL << 4) - 1) << 16, // Hour units in BCD format
	RTC_ALRMAR_MSK2  = 1UL << 15,              // Alarm A minutes mask
	RTC_ALRMAR_MNT   = ((1UL << 3) - 1) << 12, // Minute tens in BCD format
	RTC_ALRMAR_MNU   = ((1UL << 4) - 1) << 8,  // Minute units in BCD format
	RTC_ALRMAR_MSK1  = 1UL << 7,               // Alarm A seconds mask
	RTC_ALRMAR_ST    = ((1UL << 3) - 1) << 4,  // Second tens in BCD format
	RTC_ALRMAR_SU    = ((1UL << 4) - 1) << 0,  // Second units in BCD format
};
inline void rtc_alrmar_set_dt(struct RTC_Type* p, uint32_t val) {
	p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_DT) | ((val << 28) & RTC_ALRMAR_DT);
}
inline void rtc_alrmar_set_du(struct RTC_Type* p, uint32_t val) {
	p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_DU) | ((val << 24) & RTC_ALRMAR_DU);
}
inline void rtc_alrmar_set_ht(struct RTC_Type* p, uint32_t val) {
	p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_HT) | ((val << 20) & RTC_ALRMAR_HT);
}
inline void rtc_alrmar_set_hu(struct RTC_Type* p, uint32_t val) {
	p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_HU) | ((val << 16) & RTC_ALRMAR_HU);
}
inline void rtc_alrmar_set_mnt(struct RTC_Type* p, uint32_t val) {
	p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_MNT) | ((val << 12) & RTC_ALRMAR_MNT);
}
inline void rtc_alrmar_set_mnu(struct RTC_Type* p, uint32_t val) {
	p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_MNU) | ((val << 8) & RTC_ALRMAR_MNU);
}
inline void rtc_alrmar_set_st(struct RTC_Type* p, uint32_t val) { p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_ST) | ((val << 4) & RTC_ALRMAR_ST); }
inline void rtc_alrmar_set_su(struct RTC_Type* p, uint32_t val) { p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_SU) | ((val << 0) & RTC_ALRMAR_SU); }
inline uint32_t rtc_alrmar_get_dt(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_DT) >> 28; }
inline uint32_t rtc_alrmar_get_du(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_DU) >> 24; }
inline uint32_t rtc_alrmar_get_ht(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_HT) >> 20; }
inline uint32_t rtc_alrmar_get_hu(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_HU) >> 16; }
inline uint32_t rtc_alrmar_get_mnt(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_MNT) >> 12; }
inline uint32_t rtc_alrmar_get_mnu(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_MNU) >> 8; }
inline uint32_t rtc_alrmar_get_st(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_ST) >> 4; }
inline uint32_t rtc_alrmar_get_su(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_SU) >> 0; }

// RTC->ALRMBR alarm B register
enum {
	RTC_ALRMBR_MSK4  = 1UL << 31,              // Alarm B date mask
	RTC_ALRMBR_WDSEL = 1UL << 30,              // Week day selection
	RTC_ALRMBR_DT    = ((1UL << 2) - 1) << 28, // Date tens in BCD format
	RTC_ALRMBR_DU    = ((1UL << 4) - 1) << 24, // Date units or day in BCD format
	RTC_ALRMBR_MSK3  = 1UL << 23,              // Alarm B hours mask
	RTC_ALRMBR_PM    = 1UL << 22,              // AM/PM notation
	RTC_ALRMBR_HT    = ((1UL << 2) - 1) << 20, // Hour tens in BCD format
	RTC_ALRMBR_HU    = ((1UL << 4) - 1) << 16, // Hour units in BCD format
	RTC_ALRMBR_MSK2  = 1UL << 15,              // Alarm B minutes mask
	RTC_ALRMBR_MNT   = ((1UL << 3) - 1) << 12, // Minute tens in BCD format
	RTC_ALRMBR_MNU   = ((1UL << 4) - 1) << 8,  // Minute units in BCD format
	RTC_ALRMBR_MSK1  = 1UL << 7,               // Alarm B seconds mask
	RTC_ALRMBR_ST    = ((1UL << 3) - 1) << 4,  // Second tens in BCD format
	RTC_ALRMBR_SU    = ((1UL << 4) - 1) << 0,  // Second units in BCD format
};
inline void rtc_alrmbr_set_dt(struct RTC_Type* p, uint32_t val) {
	p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_DT) | ((val << 28) & RTC_ALRMBR_DT);
}
inline void rtc_alrmbr_set_du(struct RTC_Type* p, uint32_t val) {
	p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_DU) | ((val << 24) & RTC_ALRMBR_DU);
}
inline void rtc_alrmbr_set_ht(struct RTC_Type* p, uint32_t val) {
	p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_HT) | ((val << 20) & RTC_ALRMBR_HT);
}
inline void rtc_alrmbr_set_hu(struct RTC_Type* p, uint32_t val) {
	p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_HU) | ((val << 16) & RTC_ALRMBR_HU);
}
inline void rtc_alrmbr_set_mnt(struct RTC_Type* p, uint32_t val) {
	p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_MNT) | ((val << 12) & RTC_ALRMBR_MNT);
}
inline void rtc_alrmbr_set_mnu(struct RTC_Type* p, uint32_t val) {
	p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_MNU) | ((val << 8) & RTC_ALRMBR_MNU);
}
inline void rtc_alrmbr_set_st(struct RTC_Type* p, uint32_t val) { p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_ST) | ((val << 4) & RTC_ALRMBR_ST); }
inline void rtc_alrmbr_set_su(struct RTC_Type* p, uint32_t val) { p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_SU) | ((val << 0) & RTC_ALRMBR_SU); }
inline uint32_t rtc_alrmbr_get_dt(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_DT) >> 28; }
inline uint32_t rtc_alrmbr_get_du(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_DU) >> 24; }
inline uint32_t rtc_alrmbr_get_ht(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_HT) >> 20; }
inline uint32_t rtc_alrmbr_get_hu(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_HU) >> 16; }
inline uint32_t rtc_alrmbr_get_mnt(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_MNT) >> 12; }
inline uint32_t rtc_alrmbr_get_mnu(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_MNU) >> 8; }
inline uint32_t rtc_alrmbr_get_st(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_ST) >> 4; }
inline uint32_t rtc_alrmbr_get_su(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_SU) >> 0; }

// RTC->SHIFTR shift control register
enum {
	RTC_SHIFTR_ADD1S = 1UL << 31,              // Add one second
	RTC_SHIFTR_SUBFS = ((1UL << 15) - 1) << 0, // Subtract a fraction of a second
};
inline void rtc_shiftr_set_subfs(struct RTC_Type* p, uint32_t val) {
	p->SHIFTR = (p->SHIFTR & ~RTC_SHIFTR_SUBFS) | ((val << 0) & RTC_SHIFTR_SUBFS);
}
inline uint32_t rtc_shiftr_get_subfs(struct RTC_Type* p) { return (p->SHIFTR & RTC_SHIFTR_SUBFS) >> 0; }

// RTC->TSTR time stamp time register
enum {
	RTC_TSTR_PM  = 1UL << 22,              // AM/PM notation
	RTC_TSTR_HT  = ((1UL << 2) - 1) << 20, // Hour tens in BCD format
	RTC_TSTR_HU  = ((1UL << 4) - 1) << 16, // Hour units in BCD format
	RTC_TSTR_MNT = ((1UL << 3) - 1) << 12, // Minute tens in BCD format
	RTC_TSTR_MNU = ((1UL << 4) - 1) << 8,  // Minute units in BCD format
	RTC_TSTR_ST  = ((1UL << 3) - 1) << 4,  // Second tens in BCD format
	RTC_TSTR_SU  = ((1UL << 4) - 1) << 0,  // Second units in BCD format
};
inline uint32_t rtc_tstr_get_ht(struct RTC_Type* p) { return (p->TSTR & RTC_TSTR_HT) >> 20; }
inline uint32_t rtc_tstr_get_hu(struct RTC_Type* p) { return (p->TSTR & RTC_TSTR_HU) >> 16; }
inline uint32_t rtc_tstr_get_mnt(struct RTC_Type* p) { return (p->TSTR & RTC_TSTR_MNT) >> 12; }
inline uint32_t rtc_tstr_get_mnu(struct RTC_Type* p) { return (p->TSTR & RTC_TSTR_MNU) >> 8; }
inline uint32_t rtc_tstr_get_st(struct RTC_Type* p) { return (p->TSTR & RTC_TSTR_ST) >> 4; }
inline uint32_t rtc_tstr_get_su(struct RTC_Type* p) { return (p->TSTR & RTC_TSTR_SU) >> 0; }

// RTC->TSDR time stamp date register
enum {
	RTC_TSDR_WDU = ((1UL << 3) - 1) << 13, // Week day units
	RTC_TSDR_MT  = 1UL << 12,              // Month tens in BCD format
	RTC_TSDR_MU  = ((1UL << 4) - 1) << 8,  // Month units in BCD format
	RTC_TSDR_DT  = ((1UL << 2) - 1) << 4,  // Date tens in BCD format
	RTC_TSDR_DU  = ((1UL << 4) - 1) << 0,  // Date units in BCD format
};
inline uint32_t rtc_tsdr_get_wdu(struct RTC_Type* p) { return (p->TSDR & RTC_TSDR_WDU) >> 13; }
inline uint32_t rtc_tsdr_get_mu(struct RTC_Type* p) { return (p->TSDR & RTC_TSDR_MU) >> 8; }
inline uint32_t rtc_tsdr_get_dt(struct RTC_Type* p) { return (p->TSDR & RTC_TSDR_DT) >> 4; }
inline uint32_t rtc_tsdr_get_du(struct RTC_Type* p) { return (p->TSDR & RTC_TSDR_DU) >> 0; }

// RTC->CALR calibration register
enum {
	RTC_CALR_CALP   = 1UL << 15,             // Increase frequency of RTC by 488.5 ppm
	RTC_CALR_CALW8  = 1UL << 14,             // Use an 8-second calibration cycle period
	RTC_CALR_CALW16 = 1UL << 13,             // Use a 16-second calibration cycle period
	RTC_CALR_CALM   = ((1UL << 9) - 1) << 0, // Calibration minus
};
inline void     rtc_calr_set_calm(struct RTC_Type* p, uint32_t val) { p->CALR = (p->CALR & ~RTC_CALR_CALM) | ((val << 0) & RTC_CALR_CALM); }
inline uint32_t rtc_calr_get_calm(struct RTC_Type* p) { return (p->CALR & RTC_CALR_CALM) >> 0; }

// RTC->TAFCR tamper and alternate function configuration register
enum {
	RTC_TAFCR_ALARMOUTTYPE = 1UL << 18,              // AFO_ALARM output type
	RTC_TAFCR_TSINSEL      = 1UL << 17,              // TIMESTAMP mapping
	RTC_TAFCR_TAMP1INSEL   = 1UL << 16,              // TAMPER1 mapping
	RTC_TAFCR_TAMPPUDIS    = 1UL << 15,              // TAMPER pull-up disable
	RTC_TAFCR_TAMPPRCH     = ((1UL << 2) - 1) << 13, // Tamper precharge duration
	RTC_TAFCR_TAMPFLT      = ((1UL << 2) - 1) << 11, // Tamper filter count
	RTC_TAFCR_TAMPFREQ     = ((1UL << 3) - 1) << 8,  // Tamper sampling frequency
	RTC_TAFCR_TAMPTS       = 1UL << 7,               // Activate timestamp on tamper detection event
	RTC_TAFCR_TAMP2TRG     = 1UL << 4,               // Active level for tamper 2
	RTC_TAFCR_TAMP2E       = 1UL << 3,               // Tamper 2 detection enable
	RTC_TAFCR_TAMPIE       = 1UL << 2,               // Tamper interrupt enable
	RTC_TAFCR_TAMP1TRG     = 1UL << 1,               // Active level for tamper 1
	RTC_TAFCR_TAMP1E       = 1UL << 0,               // Tamper 1 detection enable
};
inline void rtc_tafcr_set_tampprch(struct RTC_Type* p, uint32_t val) {
	p->TAFCR = (p->TAFCR & ~RTC_TAFCR_TAMPPRCH) | ((val << 13) & RTC_TAFCR_TAMPPRCH);
}
inline void rtc_tafcr_set_tampflt(struct RTC_Type* p, uint32_t val) {
	p->TAFCR = (p->TAFCR & ~RTC_TAFCR_TAMPFLT) | ((val << 11) & RTC_TAFCR_TAMPFLT);
}
inline void rtc_tafcr_set_tampfreq(struct RTC_Type* p, uint32_t val) {
	p->TAFCR = (p->TAFCR & ~RTC_TAFCR_TAMPFREQ) | ((val << 8) & RTC_TAFCR_TAMPFREQ);
}
inline uint32_t rtc_tafcr_get_tampprch(struct RTC_Type* p) { return (p->TAFCR & RTC_TAFCR_TAMPPRCH) >> 13; }
inline uint32_t rtc_tafcr_get_tampflt(struct RTC_Type* p) { return (p->TAFCR & RTC_TAFCR_TAMPFLT) >> 11; }
inline uint32_t rtc_tafcr_get_tampfreq(struct RTC_Type* p) { return (p->TAFCR & RTC_TAFCR_TAMPFREQ) >> 8; }

// RTC->ALRMASSR alarm A sub second register
enum {
	RTC_ALRMASSR_MASKSS = ((1UL << 4) - 1) << 24, // Mask the most-significant bits starting at this bit
	RTC_ALRMASSR_SS     = ((1UL << 15) - 1) << 0, // Sub seconds value
};
inline void rtc_alrmassr_set_maskss(struct RTC_Type* p, uint32_t val) {
	p->ALRMASSR = (p->ALRMASSR & ~RTC_ALRMASSR_MASKSS) | ((val << 24) & RTC_ALRMASSR_MASKSS);
}
inline void rtc_alrmassr_set_ss(struct RTC_Type* p, uint32_t val) {
	p->ALRMASSR = (p->ALRMASSR & ~RTC_ALRMASSR_SS) | ((val << 0) & RTC_ALRMASSR_SS);
}
inline uint32_t rtc_alrmassr_get_maskss(struct RTC_Type* p) { return (p->ALRMASSR & RTC_ALRMASSR_MASKSS) >> 24; }
inline uint32_t rtc_alrmassr_get_ss(struct RTC_Type* p) { return (p->ALRMASSR & RTC_ALRMASSR_SS) >> 0; }

// RTC->ALRMBSSR alarm B sub second register
enum {
	RTC_ALRMBSSR_MASKSS = ((1UL << 4) - 1) << 24, // Mask the most-significant bits starting at this bit
	RTC_ALRMBSSR_SS     = ((1UL << 15) - 1) << 0, // Sub seconds value
};
inline void rtc_alrmbssr_set_maskss(struct RTC_Type* p, uint32_t val) {
	p->ALRMBSSR = (p->ALRMBSSR & ~RTC_ALRMBSSR_MASKSS) | ((val << 24) & RTC_ALRMBSSR_MASKSS);
}
inline void rtc_alrmbssr_set_ss(struct RTC_Type* p, uint32_t val) {
	p->ALRMBSSR = (p->ALRMBSSR & ~RTC_ALRMBSSR_SS) | ((val << 0) & RTC_ALRMBSSR_SS);
}
inline uint32_t rtc_alrmbssr_get_maskss(struct RTC_Type* p) { return (p->ALRMBSSR & RTC_ALRMBSSR_MASKSS) >> 24; }
inline uint32_t rtc_alrmbssr_get_ss(struct RTC_Type* p) { return (p->ALRMBSSR & RTC_ALRMBSSR_SS) >> 0; }

/* System control block */
struct SCB_Type {
	__I uint32_t CPUID;                 // @0 CPUID base register
	__IO uint32_t ICSR;                 // @4 Interrupt control and state register
	__IO uint32_t VTOR;                 // @8 Vector table offset register
	__IO uint32_t AIRCR;                // @12 Application interrupt and reset control register
	__IO uint8_t SCR;                   // @16 System control register
	uint8_t      RESERVED0[3];          // @17
	__IO uint16_t CCR;                  // @20 Configuration and control register
	uint8_t       RESERVED1[2];         // @22
	__IO uint32_t SHPR1;                // @24 System handler priority registers
	__IO uint32_t SHPR2;                // @28 System handler priority registers
	__IO uint32_t SHPR3;                // @32 System handler priority registers
	__IO uint32_t SHCRS;                // @36 System handler control and state register
	__IO uint32_t CFSR_UFSR_BFSR_MMFSR; // @40 Configurable fault status register
	__IO uint32_t HFSR;                 // @44 Hard fault status register
	uint8_t       RESERVED2[4];         // @48
	__IO uint32_t MMFAR;                // @52 Memory management fault address register
	__IO uint32_t BFAR;                 // @56 Bus fault address register
	__IO uint32_t AFSR;                 // @60 Auxiliary fault status register
};

// SCB->CPUID CPUID base register
enum {
	SCB_CPUID_IMPLEMENTER = ((1UL << 8) - 1) << 24, // Implementer code
	SCB_CPUID_VARIANT     = ((1UL << 4) - 1) << 20, // Variant number
	SCB_CPUID_CONSTANT    = ((1UL << 4) - 1) << 16, // Reads as 0xF
	SCB_CPUID_PARTNO      = ((1UL << 12) - 1) << 4, // Part number of the processor
	SCB_CPUID_REVISION    = ((1UL << 4) - 1) << 0,  // Revision number
};
inline uint32_t scb_cpuid_get_implementer(struct SCB_Type* p) { return (p->CPUID & SCB_CPUID_IMPLEMENTER) >> 24; }
inline uint32_t scb_cpuid_get_variant(struct SCB_Type* p) { return (p->CPUID & SCB_CPUID_VARIANT) >> 20; }
inline uint32_t scb_cpuid_get_constant(struct SCB_Type* p) { return (p->CPUID & SCB_CPUID_CONSTANT) >> 16; }
inline uint32_t scb_cpuid_get_partno(struct SCB_Type* p) { return (p->CPUID & SCB_CPUID_PARTNO) >> 4; }
inline uint32_t scb_cpuid_get_revision(struct SCB_Type* p) { return (p->CPUID & SCB_CPUID_REVISION) >> 0; }

// SCB->ICSR Interrupt control and state register
enum {
	SCB_ICSR_NMIPENDSET  = 1UL << 31,              // NMI set-pending bit.
	SCB_ICSR_PENDSVSET   = 1UL << 28,              // PendSV set-pending bit
	SCB_ICSR_PENDSVCLR   = 1UL << 27,              // PendSV clear-pending bit
	SCB_ICSR_PENDSTSET   = 1UL << 26,              // SysTick exception set-pending bit
	SCB_ICSR_PENDSTCLR   = 1UL << 25,              // SysTick exception clear-pending bit
	SCB_ICSR_ISRPENDING  = 1UL << 22,              // Interrupt pending flag
	SCB_ICSR_VECTPENDING = ((1UL << 7) - 1) << 12, // Pending vector
	SCB_ICSR_RETTOBASE   = 1UL << 11,              // Return to base level
	SCB_ICSR_VECTACTIVE  = ((1UL << 9) - 1) << 0,  // Active vector
};
inline void scb_icsr_set_vectpending(struct SCB_Type* p, uint32_t val) {
	p->ICSR = (p->ICSR & ~SCB_ICSR_VECTPENDING) | ((val << 12) & SCB_ICSR_VECTPENDING);
}
inline void scb_icsr_set_vectactive(struct SCB_Type* p, uint32_t val) {
	p->ICSR = (p->ICSR & ~SCB_ICSR_VECTACTIVE) | ((val << 0) & SCB_ICSR_VECTACTIVE);
}
inline uint32_t scb_icsr_get_vectpending(struct SCB_Type* p) { return (p->ICSR & SCB_ICSR_VECTPENDING) >> 12; }
inline uint32_t scb_icsr_get_vectactive(struct SCB_Type* p) { return (p->ICSR & SCB_ICSR_VECTACTIVE) >> 0; }

// SCB->VTOR Vector table offset register
enum {
	SCB_VTOR_TBLOFF = ((1UL << 21) - 1) << 9, // Vector table base offset field
};
inline void scb_vtor_set_tbloff(struct SCB_Type* p, uint32_t val) {
	p->VTOR = (p->VTOR & ~SCB_VTOR_TBLOFF) | ((val << 9) & SCB_VTOR_TBLOFF);
}
inline uint32_t scb_vtor_get_tbloff(struct SCB_Type* p) { return (p->VTOR & SCB_VTOR_TBLOFF) >> 9; }

// SCB->AIRCR Application interrupt and reset control register
enum {
	SCB_AIRCR_VECTKEYSTAT   = ((1UL << 16) - 1) << 16, // Register key
	SCB_AIRCR_ENDIANESS     = 1UL << 15,               // ENDIANESS
	SCB_AIRCR_PRIGROUP      = ((1UL << 3) - 1) << 8,   // PRIGROUP
	SCB_AIRCR_SYSRESETREQ   = 1UL << 2,                // SYSRESETREQ
	SCB_AIRCR_VECTCLRACTIVE = 1UL << 1,                // VECTCLRACTIVE
	SCB_AIRCR_VECTRESET     = 1UL << 0,                // VECTRESET
};
inline void scb_aircr_set_vectkeystat(struct SCB_Type* p, uint32_t val) {
	p->AIRCR = (p->AIRCR & ~SCB_AIRCR_VECTKEYSTAT) | ((val << 16) & SCB_AIRCR_VECTKEYSTAT);
}
inline void scb_aircr_set_prigroup(struct SCB_Type* p, uint32_t val) {
	p->AIRCR = (p->AIRCR & ~SCB_AIRCR_PRIGROUP) | ((val << 8) & SCB_AIRCR_PRIGROUP);
}
inline uint32_t scb_aircr_get_vectkeystat(struct SCB_Type* p) { return (p->AIRCR & SCB_AIRCR_VECTKEYSTAT) >> 16; }
inline uint32_t scb_aircr_get_prigroup(struct SCB_Type* p) { return (p->AIRCR & SCB_AIRCR_PRIGROUP) >> 8; }

// SCB->SCR System control register
enum {
	SCB_SCR_SEVEONPEND  = 1UL << 4, // Send Event on Pending bit
	SCB_SCR_SLEEPDEEP   = 1UL << 2, // SLEEPDEEP
	SCB_SCR_SLEEPONEXIT = 1UL << 1, // SLEEPONEXIT
};

// SCB->CCR Configuration and control register
enum {
	SCB_CCR_STKALIGN       = 1UL << 9, // STKALIGN
	SCB_CCR_BFHFNMIGN      = 1UL << 8, // BFHFNMIGN
	SCB_CCR_DIV_0_TRP      = 1UL << 4, // DIV_0_TRP
	SCB_CCR_UNALIGN__TRP   = 1UL << 3, // UNALIGN_ TRP
	SCB_CCR_USERSETMPEND   = 1UL << 1, // USERSETMPEND
	SCB_CCR_NONBASETHRDENA = 1UL << 0, // Configures how the processor enters Thread mode
};

// SCB->SHPR1 System handler priority registers
enum {
	SCB_SHPR1_PRI_6 = ((1UL << 8) - 1) << 16, // Priority of system handler 6
	SCB_SHPR1_PRI_5 = ((1UL << 8) - 1) << 8,  // Priority of system handler 5
	SCB_SHPR1_PRI_4 = ((1UL << 8) - 1) << 0,  // Priority of system handler 4
};
inline void scb_shpr1_set_pri_6(struct SCB_Type* p, uint32_t val) {
	p->SHPR1 = (p->SHPR1 & ~SCB_SHPR1_PRI_6) | ((val << 16) & SCB_SHPR1_PRI_6);
}
inline void scb_shpr1_set_pri_5(struct SCB_Type* p, uint32_t val) {
	p->SHPR1 = (p->SHPR1 & ~SCB_SHPR1_PRI_5) | ((val << 8) & SCB_SHPR1_PRI_5);
}
inline void scb_shpr1_set_pri_4(struct SCB_Type* p, uint32_t val) {
	p->SHPR1 = (p->SHPR1 & ~SCB_SHPR1_PRI_4) | ((val << 0) & SCB_SHPR1_PRI_4);
}
inline uint32_t scb_shpr1_get_pri_6(struct SCB_Type* p) { return (p->SHPR1 & SCB_SHPR1_PRI_6) >> 16; }
inline uint32_t scb_shpr1_get_pri_5(struct SCB_Type* p) { return (p->SHPR1 & SCB_SHPR1_PRI_5) >> 8; }
inline uint32_t scb_shpr1_get_pri_4(struct SCB_Type* p) { return (p->SHPR1 & SCB_SHPR1_PRI_4) >> 0; }

// SCB->SHPR2 System handler priority registers
enum {
	SCB_SHPR2_PRI_11 = ((1UL << 8) - 1) << 24, // Priority of system handler 11
};
inline void scb_shpr2_set_pri_11(struct SCB_Type* p, uint32_t val) {
	p->SHPR2 = (p->SHPR2 & ~SCB_SHPR2_PRI_11) | ((val << 24) & SCB_SHPR2_PRI_11);
}
inline uint32_t scb_shpr2_get_pri_11(struct SCB_Type* p) { return (p->SHPR2 & SCB_SHPR2_PRI_11) >> 24; }

// SCB->SHPR3 System handler priority registers
enum {
	SCB_SHPR3_PRI_15 = ((1UL << 8) - 1) << 24, // Priority of system handler 15
	SCB_SHPR3_PRI_14 = ((1UL << 8) - 1) << 16, // Priority of system handler 14
};
inline void scb_shpr3_set_pri_15(struct SCB_Type* p, uint32_t val) {
	p->SHPR3 = (p->SHPR3 & ~SCB_SHPR3_PRI_15) | ((val << 24) & SCB_SHPR3_PRI_15);
}
inline void scb_shpr3_set_pri_14(struct SCB_Type* p, uint32_t val) {
	p->SHPR3 = (p->SHPR3 & ~SCB_SHPR3_PRI_14) | ((val << 16) & SCB_SHPR3_PRI_14);
}
inline uint32_t scb_shpr3_get_pri_15(struct SCB_Type* p) { return (p->SHPR3 & SCB_SHPR3_PRI_15) >> 24; }
inline uint32_t scb_shpr3_get_pri_14(struct SCB_Type* p) { return (p->SHPR3 & SCB_SHPR3_PRI_14) >> 16; }

// SCB->SHCRS System handler control and state register
enum {
	SCB_SHCRS_USGFAULTENA    = 1UL << 18, // Usage fault enable bit
	SCB_SHCRS_BUSFAULTENA    = 1UL << 17, // Bus fault enable bit
	SCB_SHCRS_MEMFAULTENA    = 1UL << 16, // Memory management fault enable bit
	SCB_SHCRS_SVCALLPENDED   = 1UL << 15, // SVC call pending bit
	SCB_SHCRS_BUSFAULTPENDED = 1UL << 14, // Bus fault exception pending bit
	SCB_SHCRS_MEMFAULTPENDED = 1UL << 13, // Memory management fault exception pending bit
	SCB_SHCRS_USGFAULTPENDED = 1UL << 12, // Usage fault exception pending bit
	SCB_SHCRS_SYSTICKACT     = 1UL << 11, // SysTick exception active bit
	SCB_SHCRS_PENDSVACT      = 1UL << 10, // PendSV exception active bit
	SCB_SHCRS_MONITORACT     = 1UL << 8,  // Debug monitor active bit
	SCB_SHCRS_SVCALLACT      = 1UL << 7,  // SVC call active bit
	SCB_SHCRS_USGFAULTACT    = 1UL << 3,  // Usage fault exception active bit
	SCB_SHCRS_BUSFAULTACT    = 1UL << 1,  // Bus fault exception active bit
	SCB_SHCRS_MEMFAULTACT    = 1UL << 0,  // Memory management fault exception active bit
};

// SCB->CFSR_UFSR_BFSR_MMFSR Configurable fault status register
enum {
	SCB_CFSR_UFSR_BFSR_MMFSR_DIVBYZERO   = 1UL << 25, // Divide by zero usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_UNALIGNED   = 1UL << 24, // Unaligned access usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_NOCP        = 1UL << 19, // No coprocessor usage fault.
	SCB_CFSR_UFSR_BFSR_MMFSR_INVPC       = 1UL << 18, // Invalid PC load usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_INVSTATE    = 1UL << 17, // Invalid state usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_UNDEFINSTR  = 1UL << 16, // Undefined instruction usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_BFARVALID   = 1UL << 15, // Bus Fault Address Register (BFAR) valid flag
	SCB_CFSR_UFSR_BFSR_MMFSR_LSPERR      = 1UL << 13, // Bus fault on floating-point lazy state preservation
	SCB_CFSR_UFSR_BFSR_MMFSR_STKERR      = 1UL << 12, // Bus fault on stacking for exception entry
	SCB_CFSR_UFSR_BFSR_MMFSR_UNSTKERR    = 1UL << 11, // Bus fault on unstacking for a return from exception
	SCB_CFSR_UFSR_BFSR_MMFSR_IMPRECISERR = 1UL << 10, // Imprecise data bus error
	SCB_CFSR_UFSR_BFSR_MMFSR_PRECISERR   = 1UL << 9,  // Precise data bus error
	SCB_CFSR_UFSR_BFSR_MMFSR_IBUSERR     = 1UL << 8,  // Instruction bus error
	SCB_CFSR_UFSR_BFSR_MMFSR_MMARVALID   = 1UL << 7,  // Memory Management Fault Address Register (MMAR) valid flag
	SCB_CFSR_UFSR_BFSR_MMFSR_MLSPERR     = 1UL << 5,  // MLSPERR
	SCB_CFSR_UFSR_BFSR_MMFSR_MSTKERR     = 1UL << 4,  // Memory manager fault on stacking for exception entry.
	SCB_CFSR_UFSR_BFSR_MMFSR_MUNSTKERR   = 1UL << 3,  // Memory manager fault on unstacking for a return from exception
	SCB_CFSR_UFSR_BFSR_MMFSR_IACCVIOL    = 1UL << 1,  // Instruction access violation flag
};

// SCB->HFSR Hard fault status register
enum {
	SCB_HFSR_DEBUG_VT = 1UL << 31, // Reserved for Debug use
	SCB_HFSR_FORCED   = 1UL << 30, // Forced hard fault
	SCB_HFSR_VECTTBL  = 1UL << 1,  // Vector table hard fault
};

/* System control block ACTLR */
struct SCB_ACTRL_Type {
	__IO uint16_t ACTRL; // @0 Auxiliary control register
};

// SCB_ACTRL->ACTRL Auxiliary control register
enum {
	SCB_ACTRL_ACTRL_DISOOFP    = 1UL << 9, // DISOOFP
	SCB_ACTRL_ACTRL_DISFPCA    = 1UL << 8, // DISFPCA
	SCB_ACTRL_ACTRL_DISFOLD    = 1UL << 2, // DISFOLD
	SCB_ACTRL_ACTRL_DISDEFWBUF = 1UL << 1, // DISDEFWBUF
	SCB_ACTRL_ACTRL_DISMCYCINT = 1UL << 0, // DISMCYCINT
};

/* Secure digital input/output interface */
struct SDIO_Type {
	__IO uint8_t POWER;         // @0 power control register
	uint8_t      RESERVED0[3];  // @1
	__IO uint16_t CLKCR;        // @4 SDI clock control register
	uint8_t       RESERVED1[2]; // @6
	__IO uint32_t ARG;          // @8 argument register
	__IO uint16_t CMD;          // @12 command register
	uint8_t       RESERVED2[2]; // @14
	__I uint8_t RESPCMD;        // @16 command response register
	uint8_t     RESERVED3[3];   // @17
	__I uint32_t RESP1;         // @20 response 1..4 register
	__I uint32_t RESP2;         // @24 response 1..4 register
	__I uint32_t RESP3;         // @28 response 1..4 register
	__I uint32_t RESP4;         // @32 response 1..4 register
	__IO uint32_t DTIMER;       // @36 data timer register
	__IO uint32_t DLEN;         // @40 data length register
	__IO uint16_t DCTRL;        // @44 data control register
	uint8_t       RESERVED4[2]; // @46
	__I uint32_t DCOUNT;        // @48 data counter register
	__I uint32_t STA;           // @52 status register
	__IO uint32_t ICR;          // @56 interrupt clear register
	__IO uint32_t MASK;         // @60 mask register
	uint8_t       RESERVED5[8]; // @64
	__I uint32_t FIFOCNT;       // @72 FIFO counter register
	uint8_t      RESERVED6[52]; // @76
	__IO uint32_t FIFO;         // @128 data FIFO register
};

// SDIO->POWER power control register
enum {
	SDIO_POWER_PWRCTRL = ((1UL << 2) - 1) << 0, // PWRCTRL
};
inline void sdio_power_set_pwrctrl(struct SDIO_Type* p, uint32_t val) {
	p->POWER = (p->POWER & ~SDIO_POWER_PWRCTRL) | ((val << 0) & SDIO_POWER_PWRCTRL);
}
inline uint32_t sdio_power_get_pwrctrl(struct SDIO_Type* p) { return (p->POWER & SDIO_POWER_PWRCTRL) >> 0; }

// SDIO->CLKCR SDI clock control register
enum {
	SDIO_CLKCR_HWFC_EN = 1UL << 14,              // HW Flow Control enable
	SDIO_CLKCR_NEGEDGE = 1UL << 13,              // SDIO_CK dephasing selection bit
	SDIO_CLKCR_WIDBUS  = ((1UL << 2) - 1) << 11, // Wide bus mode enable bit
	SDIO_CLKCR_BYPASS  = 1UL << 10,              // Clock divider bypass enable bit
	SDIO_CLKCR_PWRSAV  = 1UL << 9,               // Power saving configuration bit
	SDIO_CLKCR_CLKEN   = 1UL << 8,               // Clock enable bit
	SDIO_CLKCR_CLKDIV  = ((1UL << 8) - 1) << 0,  // Clock divide factor
};
inline void sdio_clkcr_set_widbus(struct SDIO_Type* p, uint32_t val) {
	p->CLKCR = (p->CLKCR & ~SDIO_CLKCR_WIDBUS) | ((val << 11) & SDIO_CLKCR_WIDBUS);
}
inline void sdio_clkcr_set_clkdiv(struct SDIO_Type* p, uint32_t val) {
	p->CLKCR = (p->CLKCR & ~SDIO_CLKCR_CLKDIV) | ((val << 0) & SDIO_CLKCR_CLKDIV);
}
inline uint32_t sdio_clkcr_get_widbus(struct SDIO_Type* p) { return (p->CLKCR & SDIO_CLKCR_WIDBUS) >> 11; }
inline uint32_t sdio_clkcr_get_clkdiv(struct SDIO_Type* p) { return (p->CLKCR & SDIO_CLKCR_CLKDIV) >> 0; }

// SDIO->CMD command register
enum {
	SDIO_CMD_CE_ATACMD   = 1UL << 14,             // CE-ATA command
	SDIO_CMD_NIEN        = 1UL << 13,             // not Interrupt Enable
	SDIO_CMD_ENCMDCOMPL  = 1UL << 12,             // Enable CMD completion
	SDIO_CMD_SDIOSUSPEND = 1UL << 11,             // SD I/O suspend command
	SDIO_CMD_CPSMEN      = 1UL << 10,             // Command path state machine (CPSM) Enable bit
	SDIO_CMD_WAITPEND    = 1UL << 9,              // CPSM Waits for ends of data transfer (CmdPend internal signal).
	SDIO_CMD_WAITINT     = 1UL << 8,              // CPSM waits for interrupt request
	SDIO_CMD_WAITRESP    = ((1UL << 2) - 1) << 6, // Wait for response bits
	SDIO_CMD_CMDINDEX    = ((1UL << 6) - 1) << 0, // Command index
};
inline void sdio_cmd_set_waitresp(struct SDIO_Type* p, uint32_t val) {
	p->CMD = (p->CMD & ~SDIO_CMD_WAITRESP) | ((val << 6) & SDIO_CMD_WAITRESP);
}
inline void sdio_cmd_set_cmdindex(struct SDIO_Type* p, uint32_t val) {
	p->CMD = (p->CMD & ~SDIO_CMD_CMDINDEX) | ((val << 0) & SDIO_CMD_CMDINDEX);
}
inline uint32_t sdio_cmd_get_waitresp(struct SDIO_Type* p) { return (p->CMD & SDIO_CMD_WAITRESP) >> 6; }
inline uint32_t sdio_cmd_get_cmdindex(struct SDIO_Type* p) { return (p->CMD & SDIO_CMD_CMDINDEX) >> 0; }

// SDIO->RESPCMD command response register
enum {
	SDIO_RESPCMD_RESPCMD = ((1UL << 6) - 1) << 0, // Response command index
};
inline uint32_t sdio_respcmd_get_respcmd(struct SDIO_Type* p) { return (p->RESPCMD & SDIO_RESPCMD_RESPCMD) >> 0; }

// SDIO->DLEN data length register
enum {
	SDIO_DLEN_DATALENGTH = ((1UL << 25) - 1) << 0, // Data length value
};
inline void sdio_dlen_set_datalength(struct SDIO_Type* p, uint32_t val) {
	p->DLEN = (p->DLEN & ~SDIO_DLEN_DATALENGTH) | ((val << 0) & SDIO_DLEN_DATALENGTH);
}
inline uint32_t sdio_dlen_get_datalength(struct SDIO_Type* p) { return (p->DLEN & SDIO_DLEN_DATALENGTH) >> 0; }

// SDIO->DCTRL data control register
enum {
	SDIO_DCTRL_SDIOEN     = 1UL << 11,             // SD I/O enable functions
	SDIO_DCTRL_RWMOD      = 1UL << 10,             // Read wait mode
	SDIO_DCTRL_RWSTOP     = 1UL << 9,              // Read wait stop
	SDIO_DCTRL_RWSTART    = 1UL << 8,              // Read wait start
	SDIO_DCTRL_DBLOCKSIZE = ((1UL << 4) - 1) << 4, // Data block size
	SDIO_DCTRL_DMAEN      = 1UL << 3,              // DMA enable bit
	SDIO_DCTRL_DTMODE     = 1UL << 2,              // Data transfer mode selection 1: Stream or SDIO multibyte data transfer.
	SDIO_DCTRL_DTDIR      = 1UL << 1,              // Data transfer direction selection
	SDIO_DCTRL_DTEN       = 1UL << 0,              // DTEN
};
inline void sdio_dctrl_set_dblocksize(struct SDIO_Type* p, uint32_t val) {
	p->DCTRL = (p->DCTRL & ~SDIO_DCTRL_DBLOCKSIZE) | ((val << 4) & SDIO_DCTRL_DBLOCKSIZE);
}
inline uint32_t sdio_dctrl_get_dblocksize(struct SDIO_Type* p) { return (p->DCTRL & SDIO_DCTRL_DBLOCKSIZE) >> 4; }

// SDIO->DCOUNT data counter register
enum {
	SDIO_DCOUNT_DATACOUNT = ((1UL << 25) - 1) << 0, // Data count value
};
inline uint32_t sdio_dcount_get_datacount(struct SDIO_Type* p) { return (p->DCOUNT & SDIO_DCOUNT_DATACOUNT) >> 0; }

// SDIO->STA status register
enum {
	SDIO_STA_CEATAEND = 1UL << 23, // CE-ATA command completion signal received for CMD61
	SDIO_STA_SDIOIT   = 1UL << 22, // SDIO interrupt received
	SDIO_STA_RXDAVL   = 1UL << 21, // Data available in receive FIFO
	SDIO_STA_TXDAVL   = 1UL << 20, // Data available in transmit FIFO
	SDIO_STA_RXFIFOE  = 1UL << 19, // Receive FIFO empty
	SDIO_STA_TXFIFOE  = 1UL << 18, // Transmit FIFO empty
	SDIO_STA_RXFIFOF  = 1UL << 17, // Receive FIFO full
	SDIO_STA_TXFIFOF  = 1UL << 16, // Transmit FIFO full
	SDIO_STA_RXFIFOHF = 1UL << 15, // Receive FIFO half full: there are at least 8 words in the FIFO
	SDIO_STA_TXFIFOHE = 1UL << 14, // Transmit FIFO half empty: at least 8 words can be written into the FIFO
	SDIO_STA_RXACT    = 1UL << 13, // Data receive in progress
	SDIO_STA_TXACT    = 1UL << 12, // Data transmit in progress
	SDIO_STA_CMDACT   = 1UL << 11, // Command transfer in progress
	SDIO_STA_DBCKEND  = 1UL << 10, // Data block sent/received (CRC check passed)
	SDIO_STA_STBITERR = 1UL << 9,  // Start bit not detected on all data signals in wide bus mode
	SDIO_STA_DATAEND  = 1UL << 8,  // Data end (data counter, SDIDCOUNT, is zero)
	SDIO_STA_CMDSENT  = 1UL << 7,  // Command sent (no response required)
	SDIO_STA_CMDREND  = 1UL << 6,  // Command response received (CRC check passed)
	SDIO_STA_RXOVERR  = 1UL << 5,  // Received FIFO overrun error
	SDIO_STA_TXUNDERR = 1UL << 4,  // Transmit FIFO underrun error
	SDIO_STA_DTIMEOUT = 1UL << 3,  // Data timeout
	SDIO_STA_CTIMEOUT = 1UL << 2,  // Command response timeout
	SDIO_STA_DCRCFAIL = 1UL << 1,  // Data block sent/received (CRC check failed)
	SDIO_STA_CCRCFAIL = 1UL << 0,  // Command response received (CRC check failed)
};

// SDIO->ICR interrupt clear register
enum {
	SDIO_ICR_CEATAENDC = 1UL << 23, // CEATAEND flag clear bit
	SDIO_ICR_SDIOITC   = 1UL << 22, // SDIOIT flag clear bit
	SDIO_ICR_DBCKENDC  = 1UL << 10, // DBCKEND flag clear bit
	SDIO_ICR_STBITERRC = 1UL << 9,  // STBITERR flag clear bit
	SDIO_ICR_DATAENDC  = 1UL << 8,  // DATAEND flag clear bit
	SDIO_ICR_CMDSENTC  = 1UL << 7,  // CMDSENT flag clear bit
	SDIO_ICR_CMDRENDC  = 1UL << 6,  // CMDREND flag clear bit
	SDIO_ICR_RXOVERRC  = 1UL << 5,  // RXOVERR flag clear bit
	SDIO_ICR_TXUNDERRC = 1UL << 4,  // TXUNDERR flag clear bit
	SDIO_ICR_DTIMEOUTC = 1UL << 3,  // DTIMEOUT flag clear bit
	SDIO_ICR_CTIMEOUTC = 1UL << 2,  // CTIMEOUT flag clear bit
	SDIO_ICR_DCRCFAILC = 1UL << 1,  // DCRCFAIL flag clear bit
	SDIO_ICR_CCRCFAILC = 1UL << 0,  // CCRCFAIL flag clear bit
};

// SDIO->MASK mask register
enum {
	SDIO_MASK_CEATAENDIE = 1UL << 23, // CE-ATA command completion signal received interrupt enable
	SDIO_MASK_SDIOITIE   = 1UL << 22, // SDIO mode interrupt received interrupt enable
	SDIO_MASK_RXDAVLIE   = 1UL << 21, // Data available in Rx FIFO interrupt enable
	SDIO_MASK_TXDAVLIE   = 1UL << 20, // Data available in Tx FIFO interrupt enable
	SDIO_MASK_RXFIFOEIE  = 1UL << 19, // Rx FIFO empty interrupt enable
	SDIO_MASK_TXFIFOEIE  = 1UL << 18, // Tx FIFO empty interrupt enable
	SDIO_MASK_RXFIFOFIE  = 1UL << 17, // Rx FIFO full interrupt enable
	SDIO_MASK_TXFIFOFIE  = 1UL << 16, // Tx FIFO full interrupt enable
	SDIO_MASK_RXFIFOHFIE = 1UL << 15, // Rx FIFO half full interrupt enable
	SDIO_MASK_TXFIFOHEIE = 1UL << 14, // Tx FIFO half empty interrupt enable
	SDIO_MASK_RXACTIE    = 1UL << 13, // Data receive acting interrupt enable
	SDIO_MASK_TXACTIE    = 1UL << 12, // Data transmit acting interrupt enable
	SDIO_MASK_CMDACTIE   = 1UL << 11, // Command acting interrupt enable
	SDIO_MASK_DBCKENDIE  = 1UL << 10, // Data block end interrupt enable
	SDIO_MASK_STBITERRIE = 1UL << 9,  // Start bit error interrupt enable
	SDIO_MASK_DATAENDIE  = 1UL << 8,  // Data end interrupt enable
	SDIO_MASK_CMDSENTIE  = 1UL << 7,  // Command sent interrupt enable
	SDIO_MASK_CMDRENDIE  = 1UL << 6,  // Command response received interrupt enable
	SDIO_MASK_RXOVERRIE  = 1UL << 5,  // Rx FIFO overrun error interrupt enable
	SDIO_MASK_TXUNDERRIE = 1UL << 4,  // Tx FIFO underrun error interrupt enable
	SDIO_MASK_DTIMEOUTIE = 1UL << 3,  // Data timeout interrupt enable
	SDIO_MASK_CTIMEOUTIE = 1UL << 2,  // Command timeout interrupt enable
	SDIO_MASK_DCRCFAILIE = 1UL << 1,  // Data CRC fail interrupt enable
	SDIO_MASK_CCRCFAILIE = 1UL << 0,  // Command CRC fail interrupt enable
};

// SDIO->FIFOCNT FIFO counter register
enum {
	SDIO_FIFOCNT_FIFOCOUNT = ((1UL << 24) - 1) << 0, // Remaining number of words to be written to or read from the FIFO.
};
inline uint32_t sdio_fifocnt_get_fifocount(struct SDIO_Type* p) { return (p->FIFOCNT & SDIO_FIFOCNT_FIFOCOUNT) >> 0; }

/* SysTick timer */
struct STK_Type {
	__IO uint32_t CTRL;  // @0 SysTick control and status register
	__IO uint32_t LOAD;  // @4 SysTick reload value register
	__IO uint32_t VAL;   // @8 SysTick current value register
	__IO uint32_t CALIB; // @12 SysTick calibration value register
};

// STK->CTRL SysTick control and status register
enum {
	STK_CTRL_COUNTFLAG = 1UL << 16, // COUNTFLAG
	STK_CTRL_CLKSOURCE = 1UL << 2,  // Clock source selection
	STK_CTRL_TICKINT   = 1UL << 1,  // SysTick exception request enable
	STK_CTRL_ENABLE    = 1UL << 0,  // Counter enable
};

// STK->LOAD SysTick reload value register
enum {
	STK_LOAD_RELOAD = ((1UL << 24) - 1) << 0, // RELOAD value
};
inline void stk_load_set_reload(struct STK_Type* p, uint32_t val) {
	p->LOAD = (p->LOAD & ~STK_LOAD_RELOAD) | ((val << 0) & STK_LOAD_RELOAD);
}
inline uint32_t stk_load_get_reload(struct STK_Type* p) { return (p->LOAD & STK_LOAD_RELOAD) >> 0; }

// STK->VAL SysTick current value register
enum {
	STK_VAL_CURRENT = ((1UL << 24) - 1) << 0, // Current counter value
};
inline void stk_val_set_current(struct STK_Type* p, uint32_t val) { p->VAL = (p->VAL & ~STK_VAL_CURRENT) | ((val << 0) & STK_VAL_CURRENT); }
inline uint32_t stk_val_get_current(struct STK_Type* p) { return (p->VAL & STK_VAL_CURRENT) >> 0; }

// STK->CALIB SysTick calibration value register
enum {
	STK_CALIB_NOREF = 1UL << 31,              // NOREF flag. Reads as zero
	STK_CALIB_SKEW  = 1UL << 30,              // SKEW flag: Indicates whether the TENMS value is exact
	STK_CALIB_TENMS = ((1UL << 24) - 1) << 0, // Calibration value
};
inline void stk_calib_set_tenms(struct STK_Type* p, uint32_t val) {
	p->CALIB = (p->CALIB & ~STK_CALIB_TENMS) | ((val << 0) & STK_CALIB_TENMS);
}
inline uint32_t stk_calib_get_tenms(struct STK_Type* p) { return (p->CALIB & STK_CALIB_TENMS) >> 0; }

/* System configuration controller */
struct SYSCFG_Type {
	__IO uint8_t MEMRM;          // @0 memory remap register
	uint8_t      RESERVED0[3];   // @1
	__IO uint32_t PMC;           // @4 peripheral mode configuration register
	__IO uint16_t EXTICR1;       // @8 external interrupt configuration register 1
	uint8_t       RESERVED1[2];  // @10
	__IO uint16_t EXTICR2;       // @12 external interrupt configuration register 2
	uint8_t       RESERVED2[2];  // @14
	__IO uint16_t EXTICR3;       // @16 external interrupt configuration register 3
	uint8_t       RESERVED3[2];  // @18
	__IO uint16_t EXTICR4;       // @20 external interrupt configuration register 4
	uint8_t       RESERVED4[10]; // @22
	__I uint16_t CMPCR;          // @32 Compensation cell control register
};

// SYSCFG->MEMRM memory remap register
enum {
	SYSCFG_MEMRM_MEM_MODE = ((1UL << 2) - 1) << 0, // MEM_MODE
};
inline void syscfg_memrm_set_mem_mode(struct SYSCFG_Type* p, uint32_t val) {
	p->MEMRM = (p->MEMRM & ~SYSCFG_MEMRM_MEM_MODE) | ((val << 0) & SYSCFG_MEMRM_MEM_MODE);
}
inline uint32_t syscfg_memrm_get_mem_mode(struct SYSCFG_Type* p) { return (p->MEMRM & SYSCFG_MEMRM_MEM_MODE) >> 0; }

// SYSCFG->PMC peripheral mode configuration register
enum {
	SYSCFG_PMC_ADC1DC2 = 1UL << 16, // ADC1DC2
};

// SYSCFG->EXTICR1 external interrupt configuration register 1
enum {
	SYSCFG_EXTICR1_EXTI3 = ((1UL << 4) - 1) << 12, // EXTI x configuration (x = 0 to 3)
	SYSCFG_EXTICR1_EXTI2 = ((1UL << 4) - 1) << 8,  // EXTI x configuration (x = 0 to 3)
	SYSCFG_EXTICR1_EXTI1 = ((1UL << 4) - 1) << 4,  // EXTI x configuration (x = 0 to 3)
	SYSCFG_EXTICR1_EXTI0 = ((1UL << 4) - 1) << 0,  // EXTI x configuration (x = 0 to 3)
};
inline void syscfg_exticr1_set_exti3(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR1 = (p->EXTICR1 & ~SYSCFG_EXTICR1_EXTI3) | ((val << 12) & SYSCFG_EXTICR1_EXTI3);
}
inline void syscfg_exticr1_set_exti2(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR1 = (p->EXTICR1 & ~SYSCFG_EXTICR1_EXTI2) | ((val << 8) & SYSCFG_EXTICR1_EXTI2);
}
inline void syscfg_exticr1_set_exti1(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR1 = (p->EXTICR1 & ~SYSCFG_EXTICR1_EXTI1) | ((val << 4) & SYSCFG_EXTICR1_EXTI1);
}
inline void syscfg_exticr1_set_exti0(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR1 = (p->EXTICR1 & ~SYSCFG_EXTICR1_EXTI0) | ((val << 0) & SYSCFG_EXTICR1_EXTI0);
}
inline uint32_t syscfg_exticr1_get_exti3(struct SYSCFG_Type* p) { return (p->EXTICR1 & SYSCFG_EXTICR1_EXTI3) >> 12; }
inline uint32_t syscfg_exticr1_get_exti2(struct SYSCFG_Type* p) { return (p->EXTICR1 & SYSCFG_EXTICR1_EXTI2) >> 8; }
inline uint32_t syscfg_exticr1_get_exti1(struct SYSCFG_Type* p) { return (p->EXTICR1 & SYSCFG_EXTICR1_EXTI1) >> 4; }
inline uint32_t syscfg_exticr1_get_exti0(struct SYSCFG_Type* p) { return (p->EXTICR1 & SYSCFG_EXTICR1_EXTI0) >> 0; }

// SYSCFG->EXTICR2 external interrupt configuration register 2
enum {
	SYSCFG_EXTICR2_EXTI7 = ((1UL << 4) - 1) << 12, // EXTI x configuration (x = 4 to 7)
	SYSCFG_EXTICR2_EXTI6 = ((1UL << 4) - 1) << 8,  // EXTI x configuration (x = 4 to 7)
	SYSCFG_EXTICR2_EXTI5 = ((1UL << 4) - 1) << 4,  // EXTI x configuration (x = 4 to 7)
	SYSCFG_EXTICR2_EXTI4 = ((1UL << 4) - 1) << 0,  // EXTI x configuration (x = 4 to 7)
};
inline void syscfg_exticr2_set_exti7(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR2 = (p->EXTICR2 & ~SYSCFG_EXTICR2_EXTI7) | ((val << 12) & SYSCFG_EXTICR2_EXTI7);
}
inline void syscfg_exticr2_set_exti6(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR2 = (p->EXTICR2 & ~SYSCFG_EXTICR2_EXTI6) | ((val << 8) & SYSCFG_EXTICR2_EXTI6);
}
inline void syscfg_exticr2_set_exti5(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR2 = (p->EXTICR2 & ~SYSCFG_EXTICR2_EXTI5) | ((val << 4) & SYSCFG_EXTICR2_EXTI5);
}
inline void syscfg_exticr2_set_exti4(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR2 = (p->EXTICR2 & ~SYSCFG_EXTICR2_EXTI4) | ((val << 0) & SYSCFG_EXTICR2_EXTI4);
}
inline uint32_t syscfg_exticr2_get_exti7(struct SYSCFG_Type* p) { return (p->EXTICR2 & SYSCFG_EXTICR2_EXTI7) >> 12; }
inline uint32_t syscfg_exticr2_get_exti6(struct SYSCFG_Type* p) { return (p->EXTICR2 & SYSCFG_EXTICR2_EXTI6) >> 8; }
inline uint32_t syscfg_exticr2_get_exti5(struct SYSCFG_Type* p) { return (p->EXTICR2 & SYSCFG_EXTICR2_EXTI5) >> 4; }
inline uint32_t syscfg_exticr2_get_exti4(struct SYSCFG_Type* p) { return (p->EXTICR2 & SYSCFG_EXTICR2_EXTI4) >> 0; }

// SYSCFG->EXTICR3 external interrupt configuration register 3
enum {
	SYSCFG_EXTICR3_EXTI11 = ((1UL << 4) - 1) << 12, // EXTI x configuration (x = 8 to 11)
	SYSCFG_EXTICR3_EXTI10 = ((1UL << 4) - 1) << 8,  // EXTI10
	SYSCFG_EXTICR3_EXTI9  = ((1UL << 4) - 1) << 4,  // EXTI x configuration (x = 8 to 11)
	SYSCFG_EXTICR3_EXTI8  = ((1UL << 4) - 1) << 0,  // EXTI x configuration (x = 8 to 11)
};
inline void syscfg_exticr3_set_exti11(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR3 = (p->EXTICR3 & ~SYSCFG_EXTICR3_EXTI11) | ((val << 12) & SYSCFG_EXTICR3_EXTI11);
}
inline void syscfg_exticr3_set_exti10(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR3 = (p->EXTICR3 & ~SYSCFG_EXTICR3_EXTI10) | ((val << 8) & SYSCFG_EXTICR3_EXTI10);
}
inline void syscfg_exticr3_set_exti9(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR3 = (p->EXTICR3 & ~SYSCFG_EXTICR3_EXTI9) | ((val << 4) & SYSCFG_EXTICR3_EXTI9);
}
inline void syscfg_exticr3_set_exti8(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR3 = (p->EXTICR3 & ~SYSCFG_EXTICR3_EXTI8) | ((val << 0) & SYSCFG_EXTICR3_EXTI8);
}
inline uint32_t syscfg_exticr3_get_exti11(struct SYSCFG_Type* p) { return (p->EXTICR3 & SYSCFG_EXTICR3_EXTI11) >> 12; }
inline uint32_t syscfg_exticr3_get_exti10(struct SYSCFG_Type* p) { return (p->EXTICR3 & SYSCFG_EXTICR3_EXTI10) >> 8; }
inline uint32_t syscfg_exticr3_get_exti9(struct SYSCFG_Type* p) { return (p->EXTICR3 & SYSCFG_EXTICR3_EXTI9) >> 4; }
inline uint32_t syscfg_exticr3_get_exti8(struct SYSCFG_Type* p) { return (p->EXTICR3 & SYSCFG_EXTICR3_EXTI8) >> 0; }

// SYSCFG->EXTICR4 external interrupt configuration register 4
enum {
	SYSCFG_EXTICR4_EXTI15 = ((1UL << 4) - 1) << 12, // EXTI x configuration (x = 12 to 15)
	SYSCFG_EXTICR4_EXTI14 = ((1UL << 4) - 1) << 8,  // EXTI x configuration (x = 12 to 15)
	SYSCFG_EXTICR4_EXTI13 = ((1UL << 4) - 1) << 4,  // EXTI x configuration (x = 12 to 15)
	SYSCFG_EXTICR4_EXTI12 = ((1UL << 4) - 1) << 0,  // EXTI x configuration (x = 12 to 15)
};
inline void syscfg_exticr4_set_exti15(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR4 = (p->EXTICR4 & ~SYSCFG_EXTICR4_EXTI15) | ((val << 12) & SYSCFG_EXTICR4_EXTI15);
}
inline void syscfg_exticr4_set_exti14(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR4 = (p->EXTICR4 & ~SYSCFG_EXTICR4_EXTI14) | ((val << 8) & SYSCFG_EXTICR4_EXTI14);
}
inline void syscfg_exticr4_set_exti13(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR4 = (p->EXTICR4 & ~SYSCFG_EXTICR4_EXTI13) | ((val << 4) & SYSCFG_EXTICR4_EXTI13);
}
inline void syscfg_exticr4_set_exti12(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR4 = (p->EXTICR4 & ~SYSCFG_EXTICR4_EXTI12) | ((val << 0) & SYSCFG_EXTICR4_EXTI12);
}
inline uint32_t syscfg_exticr4_get_exti15(struct SYSCFG_Type* p) { return (p->EXTICR4 & SYSCFG_EXTICR4_EXTI15) >> 12; }
inline uint32_t syscfg_exticr4_get_exti14(struct SYSCFG_Type* p) { return (p->EXTICR4 & SYSCFG_EXTICR4_EXTI14) >> 8; }
inline uint32_t syscfg_exticr4_get_exti13(struct SYSCFG_Type* p) { return (p->EXTICR4 & SYSCFG_EXTICR4_EXTI13) >> 4; }
inline uint32_t syscfg_exticr4_get_exti12(struct SYSCFG_Type* p) { return (p->EXTICR4 & SYSCFG_EXTICR4_EXTI12) >> 0; }

// SYSCFG->CMPCR Compensation cell control register
enum {
	SYSCFG_CMPCR_READY  = 1UL << 8, // READY
	SYSCFG_CMPCR_CMP_PD = 1UL << 0, // Compensation cell power-down
};

/* Advanced-timers */
struct TIM1_Type {
	__IO uint16_t CR1;              // @0 control register 1
	uint8_t       RESERVED0[2];     // @2
	__IO uint16_t CR2;              // @4 control register 2
	uint8_t       RESERVED1[2];     // @6
	__IO uint16_t SMCR;             // @8 slave mode control register
	uint8_t       RESERVED2[2];     // @10
	__IO uint16_t DIER;             // @12 DMA/Interrupt enable register
	uint8_t       RESERVED3[2];     // @14
	__IO uint16_t SR;               // @16 status register
	uint8_t       RESERVED4[2];     // @18
	__O uint8_t EGR;                // @20 event generation register
	uint8_t     RESERVED5[3];       // @21
	union {                         // @24
		__IO uint16_t CCMR1_Output; // capture/compare mode register 1 (output mode)
		__IO uint16_t CCMR1_Input;  // capture/compare mode register 1 (input mode)
	};
	uint8_t RESERVED6[2];           // @26
	union {                         // @28
		__IO uint16_t CCMR2_Output; // capture/compare mode register 2 (output mode)
		__IO uint16_t CCMR2_Input;  // capture/compare mode register 2 (input mode)
	};
	uint8_t RESERVED7[2];        // @30
	__IO uint16_t CCER;          // @32 capture/compare enable register
	uint8_t       RESERVED8[2];  // @34
	__IO uint16_t CNT;           // @36 counter
	uint8_t       RESERVED9[2];  // @38
	__IO uint16_t PSC;           // @40 prescaler
	uint8_t       RESERVED10[2]; // @42
	__IO uint16_t ARR;           // @44 auto-reload register
	uint8_t       RESERVED11[2]; // @46
	__IO uint8_t RCR;            // @48 repetition counter register
	uint8_t      RESERVED12[3];  // @49
	__IO uint16_t CCR1;          // @52 capture/compare register 1
	uint8_t       RESERVED13[2]; // @54
	__IO uint16_t CCR2;          // @56 capture/compare register 2
	uint8_t       RESERVED14[2]; // @58
	__IO uint16_t CCR3;          // @60 capture/compare register 3
	uint8_t       RESERVED15[2]; // @62
	__IO uint16_t CCR4;          // @64 capture/compare register 4
	uint8_t       RESERVED16[2]; // @66
	__IO uint16_t BDTR;          // @68 break and dead-time register
	uint8_t       RESERVED17[2]; // @70
	__IO uint16_t DCR;           // @72 DMA control register
	uint8_t       RESERVED18[2]; // @74
	__IO uint16_t DMAR;          // @76 DMA address for full transfer
};

// TIM1->CR1 control register 1
enum {
	TIM1_CR1_CKD  = ((1UL << 2) - 1) << 8, // Clock division
	TIM1_CR1_ARPE = 1UL << 7,              // Auto-reload preload enable
	TIM1_CR1_CMS  = ((1UL << 2) - 1) << 5, // Center-aligned mode selection
	TIM1_CR1_DIR  = 1UL << 4,              // Direction
	TIM1_CR1_OPM  = 1UL << 3,              // One-pulse mode
	TIM1_CR1_URS  = 1UL << 2,              // Update request source
	TIM1_CR1_UDIS = 1UL << 1,              // Update disable
	TIM1_CR1_CEN  = 1UL << 0,              // Counter enable
};
inline void     tim1_cr1_set_ckd(struct TIM1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM1_CR1_CKD) | ((val << 8) & TIM1_CR1_CKD); }
inline void     tim1_cr1_set_cms(struct TIM1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM1_CR1_CMS) | ((val << 5) & TIM1_CR1_CMS); }
inline uint32_t tim1_cr1_get_ckd(struct TIM1_Type* p) { return (p->CR1 & TIM1_CR1_CKD) >> 8; }
inline uint32_t tim1_cr1_get_cms(struct TIM1_Type* p) { return (p->CR1 & TIM1_CR1_CMS) >> 5; }

// TIM1->CR2 control register 2
enum {
	TIM1_CR2_OIS4  = 1UL << 14,             // Output Idle state 4
	TIM1_CR2_OIS3N = 1UL << 13,             // Output Idle state 3
	TIM1_CR2_OIS3  = 1UL << 12,             // Output Idle state 3
	TIM1_CR2_OIS2N = 1UL << 11,             // Output Idle state 2
	TIM1_CR2_OIS2  = 1UL << 10,             // Output Idle state 2
	TIM1_CR2_OIS1N = 1UL << 9,              // Output Idle state 1
	TIM1_CR2_OIS1  = 1UL << 8,              // Output Idle state 1
	TIM1_CR2_TI1S  = 1UL << 7,              // TI1 selection
	TIM1_CR2_MMS   = ((1UL << 3) - 1) << 4, // Master mode selection
	TIM1_CR2_CCDS  = 1UL << 3,              // Capture/compare DMA selection
	TIM1_CR2_CCUS  = 1UL << 2,              // Capture/compare control update selection
	TIM1_CR2_CCPC  = 1UL << 0,              // Capture/compare preloaded control
};
inline void     tim1_cr2_set_mms(struct TIM1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM1_CR2_MMS) | ((val << 4) & TIM1_CR2_MMS); }
inline uint32_t tim1_cr2_get_mms(struct TIM1_Type* p) { return (p->CR2 & TIM1_CR2_MMS) >> 4; }

// TIM1->SMCR slave mode control register
enum {
	TIM1_SMCR_ETP  = 1UL << 15,              // External trigger polarity
	TIM1_SMCR_ECE  = 1UL << 14,              // External clock enable
	TIM1_SMCR_ETPS = ((1UL << 2) - 1) << 12, // External trigger prescaler
	TIM1_SMCR_ETF  = ((1UL << 4) - 1) << 8,  // External trigger filter
	TIM1_SMCR_MSM  = 1UL << 7,               // Master/Slave mode
	TIM1_SMCR_TS   = ((1UL << 3) - 1) << 4,  // Trigger selection
	TIM1_SMCR_SMS  = ((1UL << 3) - 1) << 0,  // Slave mode selection
};
inline void tim1_smcr_set_etps(struct TIM1_Type* p, uint32_t val) {
	p->SMCR = (p->SMCR & ~TIM1_SMCR_ETPS) | ((val << 12) & TIM1_SMCR_ETPS);
}
inline void tim1_smcr_set_etf(struct TIM1_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM1_SMCR_ETF) | ((val << 8) & TIM1_SMCR_ETF); }
inline void tim1_smcr_set_ts(struct TIM1_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM1_SMCR_TS) | ((val << 4) & TIM1_SMCR_TS); }
inline void tim1_smcr_set_sms(struct TIM1_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM1_SMCR_SMS) | ((val << 0) & TIM1_SMCR_SMS); }
inline uint32_t tim1_smcr_get_etps(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_ETPS) >> 12; }
inline uint32_t tim1_smcr_get_etf(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_ETF) >> 8; }
inline uint32_t tim1_smcr_get_ts(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_TS) >> 4; }
inline uint32_t tim1_smcr_get_sms(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_SMS) >> 0; }

// TIM1->DIER DMA/Interrupt enable register
enum {
	TIM1_DIER_TDE   = 1UL << 14, // Trigger DMA request enable
	TIM1_DIER_COMDE = 1UL << 13, // COM DMA request enable
	TIM1_DIER_CC4DE = 1UL << 12, // Capture/Compare 4 DMA request enable
	TIM1_DIER_CC3DE = 1UL << 11, // Capture/Compare 3 DMA request enable
	TIM1_DIER_CC2DE = 1UL << 10, // Capture/Compare 2 DMA request enable
	TIM1_DIER_CC1DE = 1UL << 9,  // Capture/Compare 1 DMA request enable
	TIM1_DIER_UDE   = 1UL << 8,  // Update DMA request enable
	TIM1_DIER_BIE   = 1UL << 7,  // Break interrupt enable
	TIM1_DIER_TIE   = 1UL << 6,  // Trigger interrupt enable
	TIM1_DIER_COMIE = 1UL << 5,  // COM interrupt enable
	TIM1_DIER_CC4IE = 1UL << 4,  // Capture/Compare 4 interrupt enable
	TIM1_DIER_CC3IE = 1UL << 3,  // Capture/Compare 3 interrupt enable
	TIM1_DIER_CC2IE = 1UL << 2,  // Capture/Compare 2 interrupt enable
	TIM1_DIER_CC1IE = 1UL << 1,  // Capture/Compare 1 interrupt enable
	TIM1_DIER_UIE   = 1UL << 0,  // Update interrupt enable
};

// TIM1->SR status register
enum {
	TIM1_SR_CC4OF = 1UL << 12, // Capture/Compare 4 overcapture flag
	TIM1_SR_CC3OF = 1UL << 11, // Capture/Compare 3 overcapture flag
	TIM1_SR_CC2OF = 1UL << 10, // Capture/compare 2 overcapture flag
	TIM1_SR_CC1OF = 1UL << 9,  // Capture/Compare 1 overcapture flag
	TIM1_SR_BIF   = 1UL << 7,  // Break interrupt flag
	TIM1_SR_TIF   = 1UL << 6,  // Trigger interrupt flag
	TIM1_SR_COMIF = 1UL << 5,  // COM interrupt flag
	TIM1_SR_CC4IF = 1UL << 4,  // Capture/Compare 4 interrupt flag
	TIM1_SR_CC3IF = 1UL << 3,  // Capture/Compare 3 interrupt flag
	TIM1_SR_CC2IF = 1UL << 2,  // Capture/Compare 2 interrupt flag
	TIM1_SR_CC1IF = 1UL << 1,  // Capture/compare 1 interrupt flag
	TIM1_SR_UIF   = 1UL << 0,  // Update interrupt flag
};

// TIM1->EGR event generation register
enum {
	TIM1_EGR_BG   = 1UL << 7, // Break generation
	TIM1_EGR_TG   = 1UL << 6, // Trigger generation
	TIM1_EGR_COMG = 1UL << 5, // Capture/Compare control update generation
	TIM1_EGR_CC4G = 1UL << 4, // Capture/compare 4 generation
	TIM1_EGR_CC3G = 1UL << 3, // Capture/compare 3 generation
	TIM1_EGR_CC2G = 1UL << 2, // Capture/compare 2 generation
	TIM1_EGR_CC1G = 1UL << 1, // Capture/compare 1 generation
	TIM1_EGR_UG   = 1UL << 0, // Update generation
};

// TIM1->CCMR1_Output capture/compare mode register 1 (output mode)
enum {
	TIM1_CCMR1_OUTPUT_OC2CE = 1UL << 15,              // Output Compare 2 clear enable
	TIM1_CCMR1_OUTPUT_OC2M  = ((1UL << 3) - 1) << 12, // Output Compare 2 mode
	TIM1_CCMR1_OUTPUT_OC2PE = 1UL << 11,              // Output Compare 2 preload enable
	TIM1_CCMR1_OUTPUT_OC2FE = 1UL << 10,              // Output Compare 2 fast enable
	TIM1_CCMR1_OUTPUT_CC2S  = ((1UL << 2) - 1) << 8,  // Capture/Compare 2 selection
	TIM1_CCMR1_OUTPUT_OC1CE = 1UL << 7,               // Output Compare 1 clear enable
	TIM1_CCMR1_OUTPUT_OC1M  = ((1UL << 3) - 1) << 4,  // Output Compare 1 mode
	TIM1_CCMR1_OUTPUT_OC1PE = 1UL << 3,               // Output Compare 1 preload enable
	TIM1_CCMR1_OUTPUT_OC1FE = 1UL << 2,               // Output Compare 1 fast enable
	TIM1_CCMR1_OUTPUT_CC1S  = ((1UL << 2) - 1) << 0,  // Capture/Compare 1 selection
};
inline void tim1_ccmr1_output_set_oc2m(struct TIM1_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_OC2M) | ((val << 12) & TIM1_CCMR1_OUTPUT_OC2M);
}
inline void tim1_ccmr1_output_set_cc2s(struct TIM1_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_CC2S) | ((val << 8) & TIM1_CCMR1_OUTPUT_CC2S);
}
inline void tim1_ccmr1_output_set_oc1m(struct TIM1_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_OC1M) | ((val << 4) & TIM1_CCMR1_OUTPUT_OC1M);
}
inline void tim1_ccmr1_output_set_cc1s(struct TIM1_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_CC1S) | ((val << 0) & TIM1_CCMR1_OUTPUT_CC1S);
}
inline uint32_t tim1_ccmr1_output_get_oc2m(struct TIM1_Type* p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_OC2M) >> 12; }
inline uint32_t tim1_ccmr1_output_get_cc2s(struct TIM1_Type* p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_CC2S) >> 8; }
inline uint32_t tim1_ccmr1_output_get_oc1m(struct TIM1_Type* p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_OC1M) >> 4; }
inline uint32_t tim1_ccmr1_output_get_cc1s(struct TIM1_Type* p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_CC1S) >> 0; }

// TIM1->CCMR2_Output capture/compare mode register 2 (output mode)
enum {
	TIM1_CCMR2_OUTPUT_OC4CE = 1UL << 15,              // Output compare 4 clear enable
	TIM1_CCMR2_OUTPUT_OC4M  = ((1UL << 3) - 1) << 12, // Output compare 4 mode
	TIM1_CCMR2_OUTPUT_OC4PE = 1UL << 11,              // Output compare 4 preload enable
	TIM1_CCMR2_OUTPUT_OC4FE = 1UL << 10,              // Output compare 4 fast enable
	TIM1_CCMR2_OUTPUT_CC4S  = ((1UL << 2) - 1) << 8,  // Capture/Compare 4 selection
	TIM1_CCMR2_OUTPUT_OC3CE = 1UL << 7,               // Output compare 3 clear enable
	TIM1_CCMR2_OUTPUT_OC3M  = ((1UL << 3) - 1) << 4,  // Output compare 3 mode
	TIM1_CCMR2_OUTPUT_OC3PE = 1UL << 3,               // Output compare 3 preload enable
	TIM1_CCMR2_OUTPUT_OC3FE = 1UL << 2,               // Output compare 3 fast enable
	TIM1_CCMR2_OUTPUT_CC3S  = ((1UL << 2) - 1) << 0,  // Capture/Compare 3 selection
};
inline void tim1_ccmr2_output_set_oc4m(struct TIM1_Type* p, uint32_t val) {
	p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_OC4M) | ((val << 12) & TIM1_CCMR2_OUTPUT_OC4M);
}
inline void tim1_ccmr2_output_set_cc4s(struct TIM1_Type* p, uint32_t val) {
	p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_CC4S) | ((val << 8) & TIM1_CCMR2_OUTPUT_CC4S);
}
inline void tim1_ccmr2_output_set_oc3m(struct TIM1_Type* p, uint32_t val) {
	p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_OC3M) | ((val << 4) & TIM1_CCMR2_OUTPUT_OC3M);
}
inline void tim1_ccmr2_output_set_cc3s(struct TIM1_Type* p, uint32_t val) {
	p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_CC3S) | ((val << 0) & TIM1_CCMR2_OUTPUT_CC3S);
}
inline uint32_t tim1_ccmr2_output_get_oc4m(struct TIM1_Type* p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_OC4M) >> 12; }
inline uint32_t tim1_ccmr2_output_get_cc4s(struct TIM1_Type* p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_CC4S) >> 8; }
inline uint32_t tim1_ccmr2_output_get_oc3m(struct TIM1_Type* p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_OC3M) >> 4; }
inline uint32_t tim1_ccmr2_output_get_cc3s(struct TIM1_Type* p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_CC3S) >> 0; }

// TIM1->CCER capture/compare enable register
enum {
	TIM1_CCER_CC4P  = 1UL << 13, // Capture/Compare 3 output Polarity
	TIM1_CCER_CC4E  = 1UL << 12, // Capture/Compare 4 output enable
	TIM1_CCER_CC3NP = 1UL << 11, // Capture/Compare 3 output Polarity
	TIM1_CCER_CC3NE = 1UL << 10, // Capture/Compare 3 complementary output enable
	TIM1_CCER_CC3P  = 1UL << 9,  // Capture/Compare 3 output Polarity
	TIM1_CCER_CC3E  = 1UL << 8,  // Capture/Compare 3 output enable
	TIM1_CCER_CC2NP = 1UL << 7,  // Capture/Compare 2 output Polarity
	TIM1_CCER_CC2NE = 1UL << 6,  // Capture/Compare 2 complementary output enable
	TIM1_CCER_CC2P  = 1UL << 5,  // Capture/Compare 2 output Polarity
	TIM1_CCER_CC2E  = 1UL << 4,  // Capture/Compare 2 output enable
	TIM1_CCER_CC1NP = 1UL << 3,  // Capture/Compare 1 output Polarity
	TIM1_CCER_CC1NE = 1UL << 2,  // Capture/Compare 1 complementary output enable
	TIM1_CCER_CC1P  = 1UL << 1,  // Capture/Compare 1 output Polarity
	TIM1_CCER_CC1E  = 1UL << 0,  // Capture/Compare 1 output enable
};

// TIM1->BDTR break and dead-time register
enum {
	TIM1_BDTR_MOE  = 1UL << 15,             // Main output enable
	TIM1_BDTR_AOE  = 1UL << 14,             // Automatic output enable
	TIM1_BDTR_BKP  = 1UL << 13,             // Break polarity
	TIM1_BDTR_BKE  = 1UL << 12,             // Break enable
	TIM1_BDTR_OSSR = 1UL << 11,             // Off-state selection for Run mode
	TIM1_BDTR_OSSI = 1UL << 10,             // Off-state selection for Idle mode
	TIM1_BDTR_LOCK = ((1UL << 2) - 1) << 8, // Lock configuration
	TIM1_BDTR_DTG  = ((1UL << 8) - 1) << 0, // Dead-time generator setup
};
inline void tim1_bdtr_set_lock(struct TIM1_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM1_BDTR_LOCK) | ((val << 8) & TIM1_BDTR_LOCK); }
inline void tim1_bdtr_set_dtg(struct TIM1_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM1_BDTR_DTG) | ((val << 0) & TIM1_BDTR_DTG); }
inline uint32_t tim1_bdtr_get_lock(struct TIM1_Type* p) { return (p->BDTR & TIM1_BDTR_LOCK) >> 8; }
inline uint32_t tim1_bdtr_get_dtg(struct TIM1_Type* p) { return (p->BDTR & TIM1_BDTR_DTG) >> 0; }

// TIM1->DCR DMA control register
enum {
	TIM1_DCR_DBL = ((1UL << 5) - 1) << 8, // DMA burst length
	TIM1_DCR_DBA = ((1UL << 5) - 1) << 0, // DMA base address
};
inline void     tim1_dcr_set_dbl(struct TIM1_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM1_DCR_DBL) | ((val << 8) & TIM1_DCR_DBL); }
inline void     tim1_dcr_set_dba(struct TIM1_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM1_DCR_DBA) | ((val << 0) & TIM1_DCR_DBA); }
inline uint32_t tim1_dcr_get_dbl(struct TIM1_Type* p) { return (p->DCR & TIM1_DCR_DBL) >> 8; }
inline uint32_t tim1_dcr_get_dba(struct TIM1_Type* p) { return (p->DCR & TIM1_DCR_DBA) >> 0; }

// Valid Casts:

inline struct TIM10_Type* TIM1_as_TIM10_Type(struct TIM1_Type* p) { return (struct TIM10_Type*)p; }

inline struct BasicTimer_Type* TIM1_as_BasicTimer_Type(struct TIM1_Type* p) { return (struct BasicTimer_Type*)p; }

/* General-purpose-timers */
struct TIM10_Type {
	__IO uint16_t CR1;             // @0 control register 1
	uint8_t       RESERVED0[10];   // @2
	__IO uint8_t DIER;             // @12 DMA/Interrupt enable register
	uint8_t      RESERVED1[3];     // @13
	__IO uint16_t SR;              // @16 status register
	uint8_t       RESERVED2[2];    // @18
	__O uint8_t EGR;               // @20 event generation register
	uint8_t     RESERVED3[3];      // @21
	union {                        // @24
		__IO uint8_t CCMR1_Output; // capture/compare mode register 1 (output mode)
		__IO uint8_t CCMR1_Input;  // capture/compare mode register 1 (input mode)
	};
	uint8_t RESERVED4[7];       // @25
	__IO uint8_t CCER;          // @32 capture/compare enable register
	uint8_t      RESERVED5[3];  // @33
	__IO uint16_t CNT;          // @36 counter
	uint8_t       RESERVED6[2]; // @38
	__IO uint16_t PSC;          // @40 prescaler
	uint8_t       RESERVED7[2]; // @42
	__IO uint16_t ARR;          // @44 auto-reload register
	uint8_t       RESERVED8[6]; // @46
	__IO uint16_t CCR1;         // @52 capture/compare register 1
};

// TIM10->CR1 control register 1
enum {
	TIM10_CR1_CKD  = ((1UL << 2) - 1) << 8, // Clock division
	TIM10_CR1_ARPE = 1UL << 7,              // Auto-reload preload enable
	TIM10_CR1_URS  = 1UL << 2,              // Update request source
	TIM10_CR1_UDIS = 1UL << 1,              // Update disable
	TIM10_CR1_CEN  = 1UL << 0,              // Counter enable
};
inline void     tim10_cr1_set_ckd(struct TIM10_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM10_CR1_CKD) | ((val << 8) & TIM10_CR1_CKD); }
inline uint32_t tim10_cr1_get_ckd(struct TIM10_Type* p) { return (p->CR1 & TIM10_CR1_CKD) >> 8; }

// TIM10->DIER DMA/Interrupt enable register
enum {
	TIM10_DIER_CC1IE = 1UL << 1, // Capture/Compare 1 interrupt enable
	TIM10_DIER_UIE   = 1UL << 0, // Update interrupt enable
};

// TIM10->SR status register
enum {
	TIM10_SR_CC1OF = 1UL << 9, // Capture/Compare 1 overcapture flag
	TIM10_SR_CC1IF = 1UL << 1, // Capture/compare 1 interrupt flag
	TIM10_SR_UIF   = 1UL << 0, // Update interrupt flag
};

// TIM10->EGR event generation register
enum {
	TIM10_EGR_CC1G = 1UL << 1, // Capture/compare 1 generation
	TIM10_EGR_UG   = 1UL << 0, // Update generation
};

// TIM10->CCMR1_Output capture/compare mode register 1 (output mode)
enum {
	TIM10_CCMR1_OUTPUT_OC1M  = ((1UL << 3) - 1) << 4, // Output Compare 1 mode
	TIM10_CCMR1_OUTPUT_OC1PE = 1UL << 3,              // Output Compare 1 preload enable
	TIM10_CCMR1_OUTPUT_OC1FE = 1UL << 2,              // Output Compare 1 fast enable
	TIM10_CCMR1_OUTPUT_CC1S  = ((1UL << 2) - 1) << 0, // Capture/Compare 1 selection
};
inline void tim10_ccmr1_output_set_oc1m(struct TIM10_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM10_CCMR1_OUTPUT_OC1M) | ((val << 4) & TIM10_CCMR1_OUTPUT_OC1M);
}
inline void tim10_ccmr1_output_set_cc1s(struct TIM10_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM10_CCMR1_OUTPUT_CC1S) | ((val << 0) & TIM10_CCMR1_OUTPUT_CC1S);
}
inline uint32_t tim10_ccmr1_output_get_oc1m(struct TIM10_Type* p) { return (p->CCMR1_Output & TIM10_CCMR1_OUTPUT_OC1M) >> 4; }
inline uint32_t tim10_ccmr1_output_get_cc1s(struct TIM10_Type* p) { return (p->CCMR1_Output & TIM10_CCMR1_OUTPUT_CC1S) >> 0; }

// TIM10->CCER capture/compare enable register
enum {
	TIM10_CCER_CC1NP = 1UL << 3, // Capture/Compare 1 output Polarity
	TIM10_CCER_CC1P  = 1UL << 1, // Capture/Compare 1 output Polarity
	TIM10_CCER_CC1E  = 1UL << 0, // Capture/Compare 1 output enable
};

// Valid Casts:

inline struct BasicTimer_Type* TIM10_as_BasicTimer_Type(struct TIM10_Type* p) { return (struct BasicTimer_Type*)p; }

/* General-purpose-timers */
struct TIM11_Type {
	__IO uint16_t CR1;             // @0 control register 1
	uint8_t       RESERVED0[10];   // @2
	__IO uint8_t DIER;             // @12 DMA/Interrupt enable register
	uint8_t      RESERVED1[3];     // @13
	__IO uint16_t SR;              // @16 status register
	uint8_t       RESERVED2[2];    // @18
	__O uint8_t EGR;               // @20 event generation register
	uint8_t     RESERVED3[3];      // @21
	union {                        // @24
		__IO uint8_t CCMR1_Output; // capture/compare mode register 1 (output mode)
		__IO uint8_t CCMR1_Input;  // capture/compare mode register 1 (input mode)
	};
	uint8_t RESERVED4[7];        // @25
	__IO uint8_t CCER;           // @32 capture/compare enable register
	uint8_t      RESERVED5[3];   // @33
	__IO uint16_t CNT;           // @36 counter
	uint8_t       RESERVED6[2];  // @38
	__IO uint16_t PSC;           // @40 prescaler
	uint8_t       RESERVED7[2];  // @42
	__IO uint16_t ARR;           // @44 auto-reload register
	uint8_t       RESERVED8[6];  // @46
	__IO uint16_t CCR1;          // @52 capture/compare register 1
	uint8_t       RESERVED9[26]; // @54
	__IO uint8_t OR;             // @80 option register
};

// TIM11->CR1 control register 1
enum {
	TIM11_CR1_CKD  = ((1UL << 2) - 1) << 8, // Clock division
	TIM11_CR1_ARPE = 1UL << 7,              // Auto-reload preload enable
	TIM11_CR1_URS  = 1UL << 2,              // Update request source
	TIM11_CR1_UDIS = 1UL << 1,              // Update disable
	TIM11_CR1_CEN  = 1UL << 0,              // Counter enable
};
inline void     tim11_cr1_set_ckd(struct TIM11_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM11_CR1_CKD) | ((val << 8) & TIM11_CR1_CKD); }
inline uint32_t tim11_cr1_get_ckd(struct TIM11_Type* p) { return (p->CR1 & TIM11_CR1_CKD) >> 8; }

// TIM11->DIER DMA/Interrupt enable register
enum {
	TIM11_DIER_CC1IE = 1UL << 1, // Capture/Compare 1 interrupt enable
	TIM11_DIER_UIE   = 1UL << 0, // Update interrupt enable
};

// TIM11->SR status register
enum {
	TIM11_SR_CC1OF = 1UL << 9, // Capture/Compare 1 overcapture flag
	TIM11_SR_CC1IF = 1UL << 1, // Capture/compare 1 interrupt flag
	TIM11_SR_UIF   = 1UL << 0, // Update interrupt flag
};

// TIM11->EGR event generation register
enum {
	TIM11_EGR_CC1G = 1UL << 1, // Capture/compare 1 generation
	TIM11_EGR_UG   = 1UL << 0, // Update generation
};

// TIM11->CCMR1_Output capture/compare mode register 1 (output mode)
enum {
	TIM11_CCMR1_OUTPUT_OC1M  = ((1UL << 3) - 1) << 4, // Output Compare 1 mode
	TIM11_CCMR1_OUTPUT_OC1PE = 1UL << 3,              // Output Compare 1 preload enable
	TIM11_CCMR1_OUTPUT_OC1FE = 1UL << 2,              // Output Compare 1 fast enable
	TIM11_CCMR1_OUTPUT_CC1S  = ((1UL << 2) - 1) << 0, // Capture/Compare 1 selection
};
inline void tim11_ccmr1_output_set_oc1m(struct TIM11_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM11_CCMR1_OUTPUT_OC1M) | ((val << 4) & TIM11_CCMR1_OUTPUT_OC1M);
}
inline void tim11_ccmr1_output_set_cc1s(struct TIM11_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM11_CCMR1_OUTPUT_CC1S) | ((val << 0) & TIM11_CCMR1_OUTPUT_CC1S);
}
inline uint32_t tim11_ccmr1_output_get_oc1m(struct TIM11_Type* p) { return (p->CCMR1_Output & TIM11_CCMR1_OUTPUT_OC1M) >> 4; }
inline uint32_t tim11_ccmr1_output_get_cc1s(struct TIM11_Type* p) { return (p->CCMR1_Output & TIM11_CCMR1_OUTPUT_CC1S) >> 0; }

// TIM11->CCER capture/compare enable register
enum {
	TIM11_CCER_CC1NP = 1UL << 3, // Capture/Compare 1 output Polarity
	TIM11_CCER_CC1P  = 1UL << 1, // Capture/Compare 1 output Polarity
	TIM11_CCER_CC1E  = 1UL << 0, // Capture/Compare 1 output enable
};

// TIM11->OR option register
enum {
	TIM11_OR_RMP = ((1UL << 2) - 1) << 0, // Input 1 remapping capability
};
inline void     tim11_or_set_rmp(struct TIM11_Type* p, uint32_t val) { p->OR = (p->OR & ~TIM11_OR_RMP) | ((val << 0) & TIM11_OR_RMP); }
inline uint32_t tim11_or_get_rmp(struct TIM11_Type* p) { return (p->OR & TIM11_OR_RMP) >> 0; }

// Valid Casts:

inline struct TIM10_Type* TIM11_as_TIM10_Type(struct TIM11_Type* p) { return (struct TIM10_Type*)p; }

inline struct BasicTimer_Type* TIM11_as_BasicTimer_Type(struct TIM11_Type* p) { return (struct BasicTimer_Type*)p; }

/* General purpose timers */
struct TIM2_Type {
	__IO uint16_t CR1;              // @0 control register 1
	uint8_t       RESERVED0[2];     // @2
	__IO uint8_t CR2;               // @4 control register 2
	uint8_t      RESERVED1[3];      // @5
	__IO uint16_t SMCR;             // @8 slave mode control register
	uint8_t       RESERVED2[2];     // @10
	__IO uint16_t DIER;             // @12 DMA/Interrupt enable register
	uint8_t       RESERVED3[2];     // @14
	__IO uint16_t SR;               // @16 status register
	uint8_t       RESERVED4[2];     // @18
	__O uint8_t EGR;                // @20 event generation register
	uint8_t     RESERVED5[3];       // @21
	union {                         // @24
		__IO uint16_t CCMR1_Output; // capture/compare mode register 1 (output mode)
		__IO uint16_t CCMR1_Input;  // capture/compare mode register 1 (input mode)
	};
	uint8_t RESERVED6[2];           // @26
	union {                         // @28
		__IO uint16_t CCMR2_Output; // capture/compare mode register 2 (output mode)
		__IO uint16_t CCMR2_Input;  // capture/compare mode register 2 (input mode)
	};
	uint8_t RESERVED7[2];        // @30
	__IO uint16_t CCER;          // @32 capture/compare enable register
	uint8_t       RESERVED8[2];  // @34
	__IO uint32_t CNT;           // @36 counter
	__IO uint16_t PSC;           // @40 prescaler
	uint8_t       RESERVED9[2];  // @42
	__IO uint32_t ARR;           // @44 auto-reload register
	uint8_t       RESERVED10[4]; // @48
	__IO uint32_t CCR1;          // @52 capture/compare register 1
	__IO uint32_t CCR2;          // @56 capture/compare register 2
	__IO uint32_t CCR3;          // @60 capture/compare register 3
	__IO uint32_t CCR4;          // @64 capture/compare register 4
	uint8_t       RESERVED11[4]; // @68
	__IO uint16_t DCR;           // @72 DMA control register
	uint8_t       RESERVED12[2]; // @74
	__IO uint16_t DMAR;          // @76 DMA address for full transfer
	uint8_t       RESERVED13[2]; // @78
	__IO uint16_t OR;            // @80 TIM5 option register
};

// TIM2->CR1 control register 1
enum {
	TIM2_CR1_CKD  = ((1UL << 2) - 1) << 8, // Clock division
	TIM2_CR1_ARPE = 1UL << 7,              // Auto-reload preload enable
	TIM2_CR1_CMS  = ((1UL << 2) - 1) << 5, // Center-aligned mode selection
	TIM2_CR1_DIR  = 1UL << 4,              // Direction
	TIM2_CR1_OPM  = 1UL << 3,              // One-pulse mode
	TIM2_CR1_URS  = 1UL << 2,              // Update request source
	TIM2_CR1_UDIS = 1UL << 1,              // Update disable
	TIM2_CR1_CEN  = 1UL << 0,              // Counter enable
};
inline void     tim2_cr1_set_ckd(struct TIM2_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM2_CR1_CKD) | ((val << 8) & TIM2_CR1_CKD); }
inline void     tim2_cr1_set_cms(struct TIM2_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM2_CR1_CMS) | ((val << 5) & TIM2_CR1_CMS); }
inline uint32_t tim2_cr1_get_ckd(struct TIM2_Type* p) { return (p->CR1 & TIM2_CR1_CKD) >> 8; }
inline uint32_t tim2_cr1_get_cms(struct TIM2_Type* p) { return (p->CR1 & TIM2_CR1_CMS) >> 5; }

// TIM2->CR2 control register 2
enum {
	TIM2_CR2_TI1S = 1UL << 7,              // TI1 selection
	TIM2_CR2_MMS  = ((1UL << 3) - 1) << 4, // Master mode selection
	TIM2_CR2_CCDS = 1UL << 3,              // Capture/compare DMA selection
};
inline void     tim2_cr2_set_mms(struct TIM2_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM2_CR2_MMS) | ((val << 4) & TIM2_CR2_MMS); }
inline uint32_t tim2_cr2_get_mms(struct TIM2_Type* p) { return (p->CR2 & TIM2_CR2_MMS) >> 4; }

// TIM2->SMCR slave mode control register
enum {
	TIM2_SMCR_ETP  = 1UL << 15,              // External trigger polarity
	TIM2_SMCR_ECE  = 1UL << 14,              // External clock enable
	TIM2_SMCR_ETPS = ((1UL << 2) - 1) << 12, // External trigger prescaler
	TIM2_SMCR_ETF  = ((1UL << 4) - 1) << 8,  // External trigger filter
	TIM2_SMCR_MSM  = 1UL << 7,               // Master/Slave mode
	TIM2_SMCR_TS   = ((1UL << 3) - 1) << 4,  // Trigger selection
	TIM2_SMCR_SMS  = ((1UL << 3) - 1) << 0,  // Slave mode selection
};
inline void tim2_smcr_set_etps(struct TIM2_Type* p, uint32_t val) {
	p->SMCR = (p->SMCR & ~TIM2_SMCR_ETPS) | ((val << 12) & TIM2_SMCR_ETPS);
}
inline void tim2_smcr_set_etf(struct TIM2_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM2_SMCR_ETF) | ((val << 8) & TIM2_SMCR_ETF); }
inline void tim2_smcr_set_ts(struct TIM2_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM2_SMCR_TS) | ((val << 4) & TIM2_SMCR_TS); }
inline void tim2_smcr_set_sms(struct TIM2_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM2_SMCR_SMS) | ((val << 0) & TIM2_SMCR_SMS); }
inline uint32_t tim2_smcr_get_etps(struct TIM2_Type* p) { return (p->SMCR & TIM2_SMCR_ETPS) >> 12; }
inline uint32_t tim2_smcr_get_etf(struct TIM2_Type* p) { return (p->SMCR & TIM2_SMCR_ETF) >> 8; }
inline uint32_t tim2_smcr_get_ts(struct TIM2_Type* p) { return (p->SMCR & TIM2_SMCR_TS) >> 4; }
inline uint32_t tim2_smcr_get_sms(struct TIM2_Type* p) { return (p->SMCR & TIM2_SMCR_SMS) >> 0; }

// TIM2->DIER DMA/Interrupt enable register
enum {
	TIM2_DIER_TDE   = 1UL << 14, // Trigger DMA request enable
	TIM2_DIER_CC4DE = 1UL << 12, // Capture/Compare 4 DMA request enable
	TIM2_DIER_CC3DE = 1UL << 11, // Capture/Compare 3 DMA request enable
	TIM2_DIER_CC2DE = 1UL << 10, // Capture/Compare 2 DMA request enable
	TIM2_DIER_CC1DE = 1UL << 9,  // Capture/Compare 1 DMA request enable
	TIM2_DIER_UDE   = 1UL << 8,  // Update DMA request enable
	TIM2_DIER_TIE   = 1UL << 6,  // Trigger interrupt enable
	TIM2_DIER_CC4IE = 1UL << 4,  // Capture/Compare 4 interrupt enable
	TIM2_DIER_CC3IE = 1UL << 3,  // Capture/Compare 3 interrupt enable
	TIM2_DIER_CC2IE = 1UL << 2,  // Capture/Compare 2 interrupt enable
	TIM2_DIER_CC1IE = 1UL << 1,  // Capture/Compare 1 interrupt enable
	TIM2_DIER_UIE   = 1UL << 0,  // Update interrupt enable
};

// TIM2->SR status register
enum {
	TIM2_SR_CC4OF = 1UL << 12, // Capture/Compare 4 overcapture flag
	TIM2_SR_CC3OF = 1UL << 11, // Capture/Compare 3 overcapture flag
	TIM2_SR_CC2OF = 1UL << 10, // Capture/compare 2 overcapture flag
	TIM2_SR_CC1OF = 1UL << 9,  // Capture/Compare 1 overcapture flag
	TIM2_SR_TIF   = 1UL << 6,  // Trigger interrupt flag
	TIM2_SR_CC4IF = 1UL << 4,  // Capture/Compare 4 interrupt flag
	TIM2_SR_CC3IF = 1UL << 3,  // Capture/Compare 3 interrupt flag
	TIM2_SR_CC2IF = 1UL << 2,  // Capture/Compare 2 interrupt flag
	TIM2_SR_CC1IF = 1UL << 1,  // Capture/compare 1 interrupt flag
	TIM2_SR_UIF   = 1UL << 0,  // Update interrupt flag
};

// TIM2->EGR event generation register
enum {
	TIM2_EGR_TG   = 1UL << 6, // Trigger generation
	TIM2_EGR_CC4G = 1UL << 4, // Capture/compare 4 generation
	TIM2_EGR_CC3G = 1UL << 3, // Capture/compare 3 generation
	TIM2_EGR_CC2G = 1UL << 2, // Capture/compare 2 generation
	TIM2_EGR_CC1G = 1UL << 1, // Capture/compare 1 generation
	TIM2_EGR_UG   = 1UL << 0, // Update generation
};

// TIM2->CCMR1_Output capture/compare mode register 1 (output mode)
enum {
	TIM2_CCMR1_OUTPUT_OC2CE = 1UL << 15,              // OC2CE
	TIM2_CCMR1_OUTPUT_OC2M  = ((1UL << 3) - 1) << 12, // OC2M
	TIM2_CCMR1_OUTPUT_OC2PE = 1UL << 11,              // OC2PE
	TIM2_CCMR1_OUTPUT_OC2FE = 1UL << 10,              // OC2FE
	TIM2_CCMR1_OUTPUT_CC2S  = ((1UL << 2) - 1) << 8,  // CC2S
	TIM2_CCMR1_OUTPUT_OC1CE = 1UL << 7,               // OC1CE
	TIM2_CCMR1_OUTPUT_OC1M  = ((1UL << 3) - 1) << 4,  // OC1M
	TIM2_CCMR1_OUTPUT_OC1PE = 1UL << 3,               // OC1PE
	TIM2_CCMR1_OUTPUT_OC1FE = 1UL << 2,               // OC1FE
	TIM2_CCMR1_OUTPUT_CC1S  = ((1UL << 2) - 1) << 0,  // CC1S
};
inline void tim2_ccmr1_output_set_oc2m(struct TIM2_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM2_CCMR1_OUTPUT_OC2M) | ((val << 12) & TIM2_CCMR1_OUTPUT_OC2M);
}
inline void tim2_ccmr1_output_set_cc2s(struct TIM2_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM2_CCMR1_OUTPUT_CC2S) | ((val << 8) & TIM2_CCMR1_OUTPUT_CC2S);
}
inline void tim2_ccmr1_output_set_oc1m(struct TIM2_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM2_CCMR1_OUTPUT_OC1M) | ((val << 4) & TIM2_CCMR1_OUTPUT_OC1M);
}
inline void tim2_ccmr1_output_set_cc1s(struct TIM2_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM2_CCMR1_OUTPUT_CC1S) | ((val << 0) & TIM2_CCMR1_OUTPUT_CC1S);
}
inline uint32_t tim2_ccmr1_output_get_oc2m(struct TIM2_Type* p) { return (p->CCMR1_Output & TIM2_CCMR1_OUTPUT_OC2M) >> 12; }
inline uint32_t tim2_ccmr1_output_get_cc2s(struct TIM2_Type* p) { return (p->CCMR1_Output & TIM2_CCMR1_OUTPUT_CC2S) >> 8; }
inline uint32_t tim2_ccmr1_output_get_oc1m(struct TIM2_Type* p) { return (p->CCMR1_Output & TIM2_CCMR1_OUTPUT_OC1M) >> 4; }
inline uint32_t tim2_ccmr1_output_get_cc1s(struct TIM2_Type* p) { return (p->CCMR1_Output & TIM2_CCMR1_OUTPUT_CC1S) >> 0; }

// TIM2->CCMR2_Output capture/compare mode register 2 (output mode)
enum {
	TIM2_CCMR2_OUTPUT_O24CE = 1UL << 15,              // O24CE
	TIM2_CCMR2_OUTPUT_OC4M  = ((1UL << 3) - 1) << 12, // OC4M
	TIM2_CCMR2_OUTPUT_OC4PE = 1UL << 11,              // OC4PE
	TIM2_CCMR2_OUTPUT_OC4FE = 1UL << 10,              // OC4FE
	TIM2_CCMR2_OUTPUT_CC4S  = ((1UL << 2) - 1) << 8,  // CC4S
	TIM2_CCMR2_OUTPUT_OC3CE = 1UL << 7,               // OC3CE
	TIM2_CCMR2_OUTPUT_OC3M  = ((1UL << 3) - 1) << 4,  // OC3M
	TIM2_CCMR2_OUTPUT_OC3PE = 1UL << 3,               // OC3PE
	TIM2_CCMR2_OUTPUT_OC3FE = 1UL << 2,               // OC3FE
	TIM2_CCMR2_OUTPUT_CC3S  = ((1UL << 2) - 1) << 0,  // CC3S
};
inline void tim2_ccmr2_output_set_oc4m(struct TIM2_Type* p, uint32_t val) {
	p->CCMR2_Output = (p->CCMR2_Output & ~TIM2_CCMR2_OUTPUT_OC4M) | ((val << 12) & TIM2_CCMR2_OUTPUT_OC4M);
}
inline void tim2_ccmr2_output_set_cc4s(struct TIM2_Type* p, uint32_t val) {
	p->CCMR2_Output = (p->CCMR2_Output & ~TIM2_CCMR2_OUTPUT_CC4S) | ((val << 8) & TIM2_CCMR2_OUTPUT_CC4S);
}
inline void tim2_ccmr2_output_set_oc3m(struct TIM2_Type* p, uint32_t val) {
	p->CCMR2_Output = (p->CCMR2_Output & ~TIM2_CCMR2_OUTPUT_OC3M) | ((val << 4) & TIM2_CCMR2_OUTPUT_OC3M);
}
inline void tim2_ccmr2_output_set_cc3s(struct TIM2_Type* p, uint32_t val) {
	p->CCMR2_Output = (p->CCMR2_Output & ~TIM2_CCMR2_OUTPUT_CC3S) | ((val << 0) & TIM2_CCMR2_OUTPUT_CC3S);
}
inline uint32_t tim2_ccmr2_output_get_oc4m(struct TIM2_Type* p) { return (p->CCMR2_Output & TIM2_CCMR2_OUTPUT_OC4M) >> 12; }
inline uint32_t tim2_ccmr2_output_get_cc4s(struct TIM2_Type* p) { return (p->CCMR2_Output & TIM2_CCMR2_OUTPUT_CC4S) >> 8; }
inline uint32_t tim2_ccmr2_output_get_oc3m(struct TIM2_Type* p) { return (p->CCMR2_Output & TIM2_CCMR2_OUTPUT_OC3M) >> 4; }
inline uint32_t tim2_ccmr2_output_get_cc3s(struct TIM2_Type* p) { return (p->CCMR2_Output & TIM2_CCMR2_OUTPUT_CC3S) >> 0; }

// TIM2->CCER capture/compare enable register
enum {
	TIM2_CCER_CC4NP = 1UL << 15, // Capture/Compare 4 output Polarity
	TIM2_CCER_CC4P  = 1UL << 13, // Capture/Compare 3 output Polarity
	TIM2_CCER_CC4E  = 1UL << 12, // Capture/Compare 4 output enable
	TIM2_CCER_CC3NP = 1UL << 11, // Capture/Compare 3 output Polarity
	TIM2_CCER_CC3P  = 1UL << 9,  // Capture/Compare 3 output Polarity
	TIM2_CCER_CC3E  = 1UL << 8,  // Capture/Compare 3 output enable
	TIM2_CCER_CC2NP = 1UL << 7,  // Capture/Compare 2 output Polarity
	TIM2_CCER_CC2P  = 1UL << 5,  // Capture/Compare 2 output Polarity
	TIM2_CCER_CC2E  = 1UL << 4,  // Capture/Compare 2 output enable
	TIM2_CCER_CC1NP = 1UL << 3,  // Capture/Compare 1 output Polarity
	TIM2_CCER_CC1P  = 1UL << 1,  // Capture/Compare 1 output Polarity
	TIM2_CCER_CC1E  = 1UL << 0,  // Capture/Compare 1 output enable
};

// TIM2->CNT counter
enum {
	TIM2_CNT_CNT_H = ((1UL << 16) - 1) << 16, // High counter value
	TIM2_CNT_CNT_L = ((1UL << 16) - 1) << 0,  // Low counter value
};
inline void tim2_cnt_set_cnt_h(struct TIM2_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM2_CNT_CNT_H) | ((val << 16) & TIM2_CNT_CNT_H); }
inline void tim2_cnt_set_cnt_l(struct TIM2_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM2_CNT_CNT_L) | ((val << 0) & TIM2_CNT_CNT_L); }
inline uint32_t tim2_cnt_get_cnt_h(struct TIM2_Type* p) { return (p->CNT & TIM2_CNT_CNT_H) >> 16; }
inline uint32_t tim2_cnt_get_cnt_l(struct TIM2_Type* p) { return (p->CNT & TIM2_CNT_CNT_L) >> 0; }

// TIM2->ARR auto-reload register
enum {
	TIM2_ARR_ARR_H = ((1UL << 16) - 1) << 16, // High Auto-reload value
	TIM2_ARR_ARR_L = ((1UL << 16) - 1) << 0,  // Low Auto-reload value
};
inline void tim2_arr_set_arr_h(struct TIM2_Type* p, uint32_t val) { p->ARR = (p->ARR & ~TIM2_ARR_ARR_H) | ((val << 16) & TIM2_ARR_ARR_H); }
inline void tim2_arr_set_arr_l(struct TIM2_Type* p, uint32_t val) { p->ARR = (p->ARR & ~TIM2_ARR_ARR_L) | ((val << 0) & TIM2_ARR_ARR_L); }
inline uint32_t tim2_arr_get_arr_h(struct TIM2_Type* p) { return (p->ARR & TIM2_ARR_ARR_H) >> 16; }
inline uint32_t tim2_arr_get_arr_l(struct TIM2_Type* p) { return (p->ARR & TIM2_ARR_ARR_L) >> 0; }

// TIM2->CCR1 capture/compare register 1
enum {
	TIM2_CCR1_CCR1_H = ((1UL << 16) - 1) << 16, // High Capture/Compare 1 value
	TIM2_CCR1_CCR1_L = ((1UL << 16) - 1) << 0,  // Low Capture/Compare 1 value
};
inline void tim2_ccr1_set_ccr1_h(struct TIM2_Type* p, uint32_t val) {
	p->CCR1 = (p->CCR1 & ~TIM2_CCR1_CCR1_H) | ((val << 16) & TIM2_CCR1_CCR1_H);
}
inline void tim2_ccr1_set_ccr1_l(struct TIM2_Type* p, uint32_t val) {
	p->CCR1 = (p->CCR1 & ~TIM2_CCR1_CCR1_L) | ((val << 0) & TIM2_CCR1_CCR1_L);
}
inline uint32_t tim2_ccr1_get_ccr1_h(struct TIM2_Type* p) { return (p->CCR1 & TIM2_CCR1_CCR1_H) >> 16; }
inline uint32_t tim2_ccr1_get_ccr1_l(struct TIM2_Type* p) { return (p->CCR1 & TIM2_CCR1_CCR1_L) >> 0; }

// TIM2->CCR2 capture/compare register 2
enum {
	TIM2_CCR2_CCR2_H = ((1UL << 16) - 1) << 16, // High Capture/Compare 2 value
	TIM2_CCR2_CCR2_L = ((1UL << 16) - 1) << 0,  // Low Capture/Compare 2 value
};
inline void tim2_ccr2_set_ccr2_h(struct TIM2_Type* p, uint32_t val) {
	p->CCR2 = (p->CCR2 & ~TIM2_CCR2_CCR2_H) | ((val << 16) & TIM2_CCR2_CCR2_H);
}
inline void tim2_ccr2_set_ccr2_l(struct TIM2_Type* p, uint32_t val) {
	p->CCR2 = (p->CCR2 & ~TIM2_CCR2_CCR2_L) | ((val << 0) & TIM2_CCR2_CCR2_L);
}
inline uint32_t tim2_ccr2_get_ccr2_h(struct TIM2_Type* p) { return (p->CCR2 & TIM2_CCR2_CCR2_H) >> 16; }
inline uint32_t tim2_ccr2_get_ccr2_l(struct TIM2_Type* p) { return (p->CCR2 & TIM2_CCR2_CCR2_L) >> 0; }

// TIM2->CCR3 capture/compare register 3
enum {
	TIM2_CCR3_CCR3_H = ((1UL << 16) - 1) << 16, // High Capture/Compare value
	TIM2_CCR3_CCR3_L = ((1UL << 16) - 1) << 0,  // Low Capture/Compare value
};
inline void tim2_ccr3_set_ccr3_h(struct TIM2_Type* p, uint32_t val) {
	p->CCR3 = (p->CCR3 & ~TIM2_CCR3_CCR3_H) | ((val << 16) & TIM2_CCR3_CCR3_H);
}
inline void tim2_ccr3_set_ccr3_l(struct TIM2_Type* p, uint32_t val) {
	p->CCR3 = (p->CCR3 & ~TIM2_CCR3_CCR3_L) | ((val << 0) & TIM2_CCR3_CCR3_L);
}
inline uint32_t tim2_ccr3_get_ccr3_h(struct TIM2_Type* p) { return (p->CCR3 & TIM2_CCR3_CCR3_H) >> 16; }
inline uint32_t tim2_ccr3_get_ccr3_l(struct TIM2_Type* p) { return (p->CCR3 & TIM2_CCR3_CCR3_L) >> 0; }

// TIM2->CCR4 capture/compare register 4
enum {
	TIM2_CCR4_CCR4_H = ((1UL << 16) - 1) << 16, // High Capture/Compare value
	TIM2_CCR4_CCR4_L = ((1UL << 16) - 1) << 0,  // Low Capture/Compare value
};
inline void tim2_ccr4_set_ccr4_h(struct TIM2_Type* p, uint32_t val) {
	p->CCR4 = (p->CCR4 & ~TIM2_CCR4_CCR4_H) | ((val << 16) & TIM2_CCR4_CCR4_H);
}
inline void tim2_ccr4_set_ccr4_l(struct TIM2_Type* p, uint32_t val) {
	p->CCR4 = (p->CCR4 & ~TIM2_CCR4_CCR4_L) | ((val << 0) & TIM2_CCR4_CCR4_L);
}
inline uint32_t tim2_ccr4_get_ccr4_h(struct TIM2_Type* p) { return (p->CCR4 & TIM2_CCR4_CCR4_H) >> 16; }
inline uint32_t tim2_ccr4_get_ccr4_l(struct TIM2_Type* p) { return (p->CCR4 & TIM2_CCR4_CCR4_L) >> 0; }

// TIM2->DCR DMA control register
enum {
	TIM2_DCR_DBL = ((1UL << 5) - 1) << 8, // DMA burst length
	TIM2_DCR_DBA = ((1UL << 5) - 1) << 0, // DMA base address
};
inline void     tim2_dcr_set_dbl(struct TIM2_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM2_DCR_DBL) | ((val << 8) & TIM2_DCR_DBL); }
inline void     tim2_dcr_set_dba(struct TIM2_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM2_DCR_DBA) | ((val << 0) & TIM2_DCR_DBA); }
inline uint32_t tim2_dcr_get_dbl(struct TIM2_Type* p) { return (p->DCR & TIM2_DCR_DBL) >> 8; }
inline uint32_t tim2_dcr_get_dba(struct TIM2_Type* p) { return (p->DCR & TIM2_DCR_DBA) >> 0; }

// TIM2->OR TIM5 option register
enum {
	TIM2_OR_ITR1_RMP = ((1UL << 2) - 1) << 10, // Timer Input 4 remap
};
inline void tim2_or_set_itr1_rmp(struct TIM2_Type* p, uint32_t val) {
	p->OR = (p->OR & ~TIM2_OR_ITR1_RMP) | ((val << 10) & TIM2_OR_ITR1_RMP);
}
inline uint32_t tim2_or_get_itr1_rmp(struct TIM2_Type* p) { return (p->OR & TIM2_OR_ITR1_RMP) >> 10; }

// Valid Casts:

inline struct TIM3_Type* TIM2_as_TIM3_Type(struct TIM2_Type* p) { return (struct TIM3_Type*)p; }

inline struct BasicTimer_Type* TIM2_as_BasicTimer_Type(struct TIM2_Type* p) { return (struct BasicTimer_Type*)p; }

/* General purpose timers */
struct TIM3_Type {
	__IO uint16_t CR1;              // @0 control register 1
	uint8_t       RESERVED0[2];     // @2
	__IO uint8_t CR2;               // @4 control register 2
	uint8_t      RESERVED1[3];      // @5
	__IO uint16_t SMCR;             // @8 slave mode control register
	uint8_t       RESERVED2[2];     // @10
	__IO uint16_t DIER;             // @12 DMA/Interrupt enable register
	uint8_t       RESERVED3[2];     // @14
	__IO uint16_t SR;               // @16 status register
	uint8_t       RESERVED4[2];     // @18
	__O uint8_t EGR;                // @20 event generation register
	uint8_t     RESERVED5[3];       // @21
	union {                         // @24
		__IO uint16_t CCMR1_Output; // capture/compare mode register 1 (output mode)
		__IO uint16_t CCMR1_Input;  // capture/compare mode register 1 (input mode)
	};
	uint8_t RESERVED6[2];           // @26
	union {                         // @28
		__IO uint16_t CCMR2_Output; // capture/compare mode register 2 (output mode)
		__IO uint16_t CCMR2_Input;  // capture/compare mode register 2 (input mode)
	};
	uint8_t RESERVED7[2];        // @30
	__IO uint16_t CCER;          // @32 capture/compare enable register
	uint8_t       RESERVED8[2];  // @34
	__IO uint32_t CNT;           // @36 counter
	__IO uint16_t PSC;           // @40 prescaler
	uint8_t       RESERVED9[2];  // @42
	__IO uint32_t ARR;           // @44 auto-reload register
	uint8_t       RESERVED10[4]; // @48
	__IO uint32_t CCR1;          // @52 capture/compare register 1
	__IO uint32_t CCR2;          // @56 capture/compare register 2
	__IO uint32_t CCR3;          // @60 capture/compare register 3
	__IO uint32_t CCR4;          // @64 capture/compare register 4
	uint8_t       RESERVED11[4]; // @68
	__IO uint16_t DCR;           // @72 DMA control register
	uint8_t       RESERVED12[2]; // @74
	__IO uint16_t DMAR;          // @76 DMA address for full transfer
};

// TIM3->CR1 control register 1
enum {
	TIM3_CR1_CKD  = ((1UL << 2) - 1) << 8, // Clock division
	TIM3_CR1_ARPE = 1UL << 7,              // Auto-reload preload enable
	TIM3_CR1_CMS  = ((1UL << 2) - 1) << 5, // Center-aligned mode selection
	TIM3_CR1_DIR  = 1UL << 4,              // Direction
	TIM3_CR1_OPM  = 1UL << 3,              // One-pulse mode
	TIM3_CR1_URS  = 1UL << 2,              // Update request source
	TIM3_CR1_UDIS = 1UL << 1,              // Update disable
	TIM3_CR1_CEN  = 1UL << 0,              // Counter enable
};
inline void     tim3_cr1_set_ckd(struct TIM3_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM3_CR1_CKD) | ((val << 8) & TIM3_CR1_CKD); }
inline void     tim3_cr1_set_cms(struct TIM3_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM3_CR1_CMS) | ((val << 5) & TIM3_CR1_CMS); }
inline uint32_t tim3_cr1_get_ckd(struct TIM3_Type* p) { return (p->CR1 & TIM3_CR1_CKD) >> 8; }
inline uint32_t tim3_cr1_get_cms(struct TIM3_Type* p) { return (p->CR1 & TIM3_CR1_CMS) >> 5; }

// TIM3->CR2 control register 2
enum {
	TIM3_CR2_TI1S = 1UL << 7,              // TI1 selection
	TIM3_CR2_MMS  = ((1UL << 3) - 1) << 4, // Master mode selection
	TIM3_CR2_CCDS = 1UL << 3,              // Capture/compare DMA selection
};
inline void     tim3_cr2_set_mms(struct TIM3_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM3_CR2_MMS) | ((val << 4) & TIM3_CR2_MMS); }
inline uint32_t tim3_cr2_get_mms(struct TIM3_Type* p) { return (p->CR2 & TIM3_CR2_MMS) >> 4; }

// TIM3->SMCR slave mode control register
enum {
	TIM3_SMCR_ETP  = 1UL << 15,              // External trigger polarity
	TIM3_SMCR_ECE  = 1UL << 14,              // External clock enable
	TIM3_SMCR_ETPS = ((1UL << 2) - 1) << 12, // External trigger prescaler
	TIM3_SMCR_ETF  = ((1UL << 4) - 1) << 8,  // External trigger filter
	TIM3_SMCR_MSM  = 1UL << 7,               // Master/Slave mode
	TIM3_SMCR_TS   = ((1UL << 3) - 1) << 4,  // Trigger selection
	TIM3_SMCR_SMS  = ((1UL << 3) - 1) << 0,  // Slave mode selection
};
inline void tim3_smcr_set_etps(struct TIM3_Type* p, uint32_t val) {
	p->SMCR = (p->SMCR & ~TIM3_SMCR_ETPS) | ((val << 12) & TIM3_SMCR_ETPS);
}
inline void tim3_smcr_set_etf(struct TIM3_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM3_SMCR_ETF) | ((val << 8) & TIM3_SMCR_ETF); }
inline void tim3_smcr_set_ts(struct TIM3_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM3_SMCR_TS) | ((val << 4) & TIM3_SMCR_TS); }
inline void tim3_smcr_set_sms(struct TIM3_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM3_SMCR_SMS) | ((val << 0) & TIM3_SMCR_SMS); }
inline uint32_t tim3_smcr_get_etps(struct TIM3_Type* p) { return (p->SMCR & TIM3_SMCR_ETPS) >> 12; }
inline uint32_t tim3_smcr_get_etf(struct TIM3_Type* p) { return (p->SMCR & TIM3_SMCR_ETF) >> 8; }
inline uint32_t tim3_smcr_get_ts(struct TIM3_Type* p) { return (p->SMCR & TIM3_SMCR_TS) >> 4; }
inline uint32_t tim3_smcr_get_sms(struct TIM3_Type* p) { return (p->SMCR & TIM3_SMCR_SMS) >> 0; }

// TIM3->DIER DMA/Interrupt enable register
enum {
	TIM3_DIER_TDE   = 1UL << 14, // Trigger DMA request enable
	TIM3_DIER_CC4DE = 1UL << 12, // Capture/Compare 4 DMA request enable
	TIM3_DIER_CC3DE = 1UL << 11, // Capture/Compare 3 DMA request enable
	TIM3_DIER_CC2DE = 1UL << 10, // Capture/Compare 2 DMA request enable
	TIM3_DIER_CC1DE = 1UL << 9,  // Capture/Compare 1 DMA request enable
	TIM3_DIER_UDE   = 1UL << 8,  // Update DMA request enable
	TIM3_DIER_TIE   = 1UL << 6,  // Trigger interrupt enable
	TIM3_DIER_CC4IE = 1UL << 4,  // Capture/Compare 4 interrupt enable
	TIM3_DIER_CC3IE = 1UL << 3,  // Capture/Compare 3 interrupt enable
	TIM3_DIER_CC2IE = 1UL << 2,  // Capture/Compare 2 interrupt enable
	TIM3_DIER_CC1IE = 1UL << 1,  // Capture/Compare 1 interrupt enable
	TIM3_DIER_UIE   = 1UL << 0,  // Update interrupt enable
};

// TIM3->SR status register
enum {
	TIM3_SR_CC4OF = 1UL << 12, // Capture/Compare 4 overcapture flag
	TIM3_SR_CC3OF = 1UL << 11, // Capture/Compare 3 overcapture flag
	TIM3_SR_CC2OF = 1UL << 10, // Capture/compare 2 overcapture flag
	TIM3_SR_CC1OF = 1UL << 9,  // Capture/Compare 1 overcapture flag
	TIM3_SR_TIF   = 1UL << 6,  // Trigger interrupt flag
	TIM3_SR_CC4IF = 1UL << 4,  // Capture/Compare 4 interrupt flag
	TIM3_SR_CC3IF = 1UL << 3,  // Capture/Compare 3 interrupt flag
	TIM3_SR_CC2IF = 1UL << 2,  // Capture/Compare 2 interrupt flag
	TIM3_SR_CC1IF = 1UL << 1,  // Capture/compare 1 interrupt flag
	TIM3_SR_UIF   = 1UL << 0,  // Update interrupt flag
};

// TIM3->EGR event generation register
enum {
	TIM3_EGR_TG   = 1UL << 6, // Trigger generation
	TIM3_EGR_CC4G = 1UL << 4, // Capture/compare 4 generation
	TIM3_EGR_CC3G = 1UL << 3, // Capture/compare 3 generation
	TIM3_EGR_CC2G = 1UL << 2, // Capture/compare 2 generation
	TIM3_EGR_CC1G = 1UL << 1, // Capture/compare 1 generation
	TIM3_EGR_UG   = 1UL << 0, // Update generation
};

// TIM3->CCMR1_Output capture/compare mode register 1 (output mode)
enum {
	TIM3_CCMR1_OUTPUT_OC2CE = 1UL << 15,              // OC2CE
	TIM3_CCMR1_OUTPUT_OC2M  = ((1UL << 3) - 1) << 12, // OC2M
	TIM3_CCMR1_OUTPUT_OC2PE = 1UL << 11,              // OC2PE
	TIM3_CCMR1_OUTPUT_OC2FE = 1UL << 10,              // OC2FE
	TIM3_CCMR1_OUTPUT_CC2S  = ((1UL << 2) - 1) << 8,  // CC2S
	TIM3_CCMR1_OUTPUT_OC1CE = 1UL << 7,               // OC1CE
	TIM3_CCMR1_OUTPUT_OC1M  = ((1UL << 3) - 1) << 4,  // OC1M
	TIM3_CCMR1_OUTPUT_OC1PE = 1UL << 3,               // OC1PE
	TIM3_CCMR1_OUTPUT_OC1FE = 1UL << 2,               // OC1FE
	TIM3_CCMR1_OUTPUT_CC1S  = ((1UL << 2) - 1) << 0,  // CC1S
};
inline void tim3_ccmr1_output_set_oc2m(struct TIM3_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM3_CCMR1_OUTPUT_OC2M) | ((val << 12) & TIM3_CCMR1_OUTPUT_OC2M);
}
inline void tim3_ccmr1_output_set_cc2s(struct TIM3_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM3_CCMR1_OUTPUT_CC2S) | ((val << 8) & TIM3_CCMR1_OUTPUT_CC2S);
}
inline void tim3_ccmr1_output_set_oc1m(struct TIM3_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM3_CCMR1_OUTPUT_OC1M) | ((val << 4) & TIM3_CCMR1_OUTPUT_OC1M);
}
inline void tim3_ccmr1_output_set_cc1s(struct TIM3_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM3_CCMR1_OUTPUT_CC1S) | ((val << 0) & TIM3_CCMR1_OUTPUT_CC1S);
}
inline uint32_t tim3_ccmr1_output_get_oc2m(struct TIM3_Type* p) { return (p->CCMR1_Output & TIM3_CCMR1_OUTPUT_OC2M) >> 12; }
inline uint32_t tim3_ccmr1_output_get_cc2s(struct TIM3_Type* p) { return (p->CCMR1_Output & TIM3_CCMR1_OUTPUT_CC2S) >> 8; }
inline uint32_t tim3_ccmr1_output_get_oc1m(struct TIM3_Type* p) { return (p->CCMR1_Output & TIM3_CCMR1_OUTPUT_OC1M) >> 4; }
inline uint32_t tim3_ccmr1_output_get_cc1s(struct TIM3_Type* p) { return (p->CCMR1_Output & TIM3_CCMR1_OUTPUT_CC1S) >> 0; }

// TIM3->CCMR2_Output capture/compare mode register 2 (output mode)
enum {
	TIM3_CCMR2_OUTPUT_O24CE = 1UL << 15,              // O24CE
	TIM3_CCMR2_OUTPUT_OC4M  = ((1UL << 3) - 1) << 12, // OC4M
	TIM3_CCMR2_OUTPUT_OC4PE = 1UL << 11,              // OC4PE
	TIM3_CCMR2_OUTPUT_OC4FE = 1UL << 10,              // OC4FE
	TIM3_CCMR2_OUTPUT_CC4S  = ((1UL << 2) - 1) << 8,  // CC4S
	TIM3_CCMR2_OUTPUT_OC3CE = 1UL << 7,               // OC3CE
	TIM3_CCMR2_OUTPUT_OC3M  = ((1UL << 3) - 1) << 4,  // OC3M
	TIM3_CCMR2_OUTPUT_OC3PE = 1UL << 3,               // OC3PE
	TIM3_CCMR2_OUTPUT_OC3FE = 1UL << 2,               // OC3FE
	TIM3_CCMR2_OUTPUT_CC3S  = ((1UL << 2) - 1) << 0,  // CC3S
};
inline void tim3_ccmr2_output_set_oc4m(struct TIM3_Type* p, uint32_t val) {
	p->CCMR2_Output = (p->CCMR2_Output & ~TIM3_CCMR2_OUTPUT_OC4M) | ((val << 12) & TIM3_CCMR2_OUTPUT_OC4M);
}
inline void tim3_ccmr2_output_set_cc4s(struct TIM3_Type* p, uint32_t val) {
	p->CCMR2_Output = (p->CCMR2_Output & ~TIM3_CCMR2_OUTPUT_CC4S) | ((val << 8) & TIM3_CCMR2_OUTPUT_CC4S);
}
inline void tim3_ccmr2_output_set_oc3m(struct TIM3_Type* p, uint32_t val) {
	p->CCMR2_Output = (p->CCMR2_Output & ~TIM3_CCMR2_OUTPUT_OC3M) | ((val << 4) & TIM3_CCMR2_OUTPUT_OC3M);
}
inline void tim3_ccmr2_output_set_cc3s(struct TIM3_Type* p, uint32_t val) {
	p->CCMR2_Output = (p->CCMR2_Output & ~TIM3_CCMR2_OUTPUT_CC3S) | ((val << 0) & TIM3_CCMR2_OUTPUT_CC3S);
}
inline uint32_t tim3_ccmr2_output_get_oc4m(struct TIM3_Type* p) { return (p->CCMR2_Output & TIM3_CCMR2_OUTPUT_OC4M) >> 12; }
inline uint32_t tim3_ccmr2_output_get_cc4s(struct TIM3_Type* p) { return (p->CCMR2_Output & TIM3_CCMR2_OUTPUT_CC4S) >> 8; }
inline uint32_t tim3_ccmr2_output_get_oc3m(struct TIM3_Type* p) { return (p->CCMR2_Output & TIM3_CCMR2_OUTPUT_OC3M) >> 4; }
inline uint32_t tim3_ccmr2_output_get_cc3s(struct TIM3_Type* p) { return (p->CCMR2_Output & TIM3_CCMR2_OUTPUT_CC3S) >> 0; }

// TIM3->CCER capture/compare enable register
enum {
	TIM3_CCER_CC4NP = 1UL << 15, // Capture/Compare 4 output Polarity
	TIM3_CCER_CC4P  = 1UL << 13, // Capture/Compare 3 output Polarity
	TIM3_CCER_CC4E  = 1UL << 12, // Capture/Compare 4 output enable
	TIM3_CCER_CC3NP = 1UL << 11, // Capture/Compare 3 output Polarity
	TIM3_CCER_CC3P  = 1UL << 9,  // Capture/Compare 3 output Polarity
	TIM3_CCER_CC3E  = 1UL << 8,  // Capture/Compare 3 output enable
	TIM3_CCER_CC2NP = 1UL << 7,  // Capture/Compare 2 output Polarity
	TIM3_CCER_CC2P  = 1UL << 5,  // Capture/Compare 2 output Polarity
	TIM3_CCER_CC2E  = 1UL << 4,  // Capture/Compare 2 output enable
	TIM3_CCER_CC1NP = 1UL << 3,  // Capture/Compare 1 output Polarity
	TIM3_CCER_CC1P  = 1UL << 1,  // Capture/Compare 1 output Polarity
	TIM3_CCER_CC1E  = 1UL << 0,  // Capture/Compare 1 output enable
};

// TIM3->CNT counter
enum {
	TIM3_CNT_CNT_H = ((1UL << 16) - 1) << 16, // High counter value
	TIM3_CNT_CNT_L = ((1UL << 16) - 1) << 0,  // Low counter value
};
inline void tim3_cnt_set_cnt_h(struct TIM3_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM3_CNT_CNT_H) | ((val << 16) & TIM3_CNT_CNT_H); }
inline void tim3_cnt_set_cnt_l(struct TIM3_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM3_CNT_CNT_L) | ((val << 0) & TIM3_CNT_CNT_L); }
inline uint32_t tim3_cnt_get_cnt_h(struct TIM3_Type* p) { return (p->CNT & TIM3_CNT_CNT_H) >> 16; }
inline uint32_t tim3_cnt_get_cnt_l(struct TIM3_Type* p) { return (p->CNT & TIM3_CNT_CNT_L) >> 0; }

// TIM3->ARR auto-reload register
enum {
	TIM3_ARR_ARR_H = ((1UL << 16) - 1) << 16, // High Auto-reload value
	TIM3_ARR_ARR_L = ((1UL << 16) - 1) << 0,  // Low Auto-reload value
};
inline void tim3_arr_set_arr_h(struct TIM3_Type* p, uint32_t val) { p->ARR = (p->ARR & ~TIM3_ARR_ARR_H) | ((val << 16) & TIM3_ARR_ARR_H); }
inline void tim3_arr_set_arr_l(struct TIM3_Type* p, uint32_t val) { p->ARR = (p->ARR & ~TIM3_ARR_ARR_L) | ((val << 0) & TIM3_ARR_ARR_L); }
inline uint32_t tim3_arr_get_arr_h(struct TIM3_Type* p) { return (p->ARR & TIM3_ARR_ARR_H) >> 16; }
inline uint32_t tim3_arr_get_arr_l(struct TIM3_Type* p) { return (p->ARR & TIM3_ARR_ARR_L) >> 0; }

// TIM3->CCR1 capture/compare register 1
enum {
	TIM3_CCR1_CCR1_H = ((1UL << 16) - 1) << 16, // High Capture/Compare 1 value
	TIM3_CCR1_CCR1_L = ((1UL << 16) - 1) << 0,  // Low Capture/Compare 1 value
};
inline void tim3_ccr1_set_ccr1_h(struct TIM3_Type* p, uint32_t val) {
	p->CCR1 = (p->CCR1 & ~TIM3_CCR1_CCR1_H) | ((val << 16) & TIM3_CCR1_CCR1_H);
}
inline void tim3_ccr1_set_ccr1_l(struct TIM3_Type* p, uint32_t val) {
	p->CCR1 = (p->CCR1 & ~TIM3_CCR1_CCR1_L) | ((val << 0) & TIM3_CCR1_CCR1_L);
}
inline uint32_t tim3_ccr1_get_ccr1_h(struct TIM3_Type* p) { return (p->CCR1 & TIM3_CCR1_CCR1_H) >> 16; }
inline uint32_t tim3_ccr1_get_ccr1_l(struct TIM3_Type* p) { return (p->CCR1 & TIM3_CCR1_CCR1_L) >> 0; }

// TIM3->CCR2 capture/compare register 2
enum {
	TIM3_CCR2_CCR2_H = ((1UL << 16) - 1) << 16, // High Capture/Compare 2 value
	TIM3_CCR2_CCR2_L = ((1UL << 16) - 1) << 0,  // Low Capture/Compare 2 value
};
inline void tim3_ccr2_set_ccr2_h(struct TIM3_Type* p, uint32_t val) {
	p->CCR2 = (p->CCR2 & ~TIM3_CCR2_CCR2_H) | ((val << 16) & TIM3_CCR2_CCR2_H);
}
inline void tim3_ccr2_set_ccr2_l(struct TIM3_Type* p, uint32_t val) {
	p->CCR2 = (p->CCR2 & ~TIM3_CCR2_CCR2_L) | ((val << 0) & TIM3_CCR2_CCR2_L);
}
inline uint32_t tim3_ccr2_get_ccr2_h(struct TIM3_Type* p) { return (p->CCR2 & TIM3_CCR2_CCR2_H) >> 16; }
inline uint32_t tim3_ccr2_get_ccr2_l(struct TIM3_Type* p) { return (p->CCR2 & TIM3_CCR2_CCR2_L) >> 0; }

// TIM3->CCR3 capture/compare register 3
enum {
	TIM3_CCR3_CCR3_H = ((1UL << 16) - 1) << 16, // High Capture/Compare value
	TIM3_CCR3_CCR3_L = ((1UL << 16) - 1) << 0,  // Low Capture/Compare value
};
inline void tim3_ccr3_set_ccr3_h(struct TIM3_Type* p, uint32_t val) {
	p->CCR3 = (p->CCR3 & ~TIM3_CCR3_CCR3_H) | ((val << 16) & TIM3_CCR3_CCR3_H);
}
inline void tim3_ccr3_set_ccr3_l(struct TIM3_Type* p, uint32_t val) {
	p->CCR3 = (p->CCR3 & ~TIM3_CCR3_CCR3_L) | ((val << 0) & TIM3_CCR3_CCR3_L);
}
inline uint32_t tim3_ccr3_get_ccr3_h(struct TIM3_Type* p) { return (p->CCR3 & TIM3_CCR3_CCR3_H) >> 16; }
inline uint32_t tim3_ccr3_get_ccr3_l(struct TIM3_Type* p) { return (p->CCR3 & TIM3_CCR3_CCR3_L) >> 0; }

// TIM3->CCR4 capture/compare register 4
enum {
	TIM3_CCR4_CCR4_H = ((1UL << 16) - 1) << 16, // High Capture/Compare value
	TIM3_CCR4_CCR4_L = ((1UL << 16) - 1) << 0,  // Low Capture/Compare value
};
inline void tim3_ccr4_set_ccr4_h(struct TIM3_Type* p, uint32_t val) {
	p->CCR4 = (p->CCR4 & ~TIM3_CCR4_CCR4_H) | ((val << 16) & TIM3_CCR4_CCR4_H);
}
inline void tim3_ccr4_set_ccr4_l(struct TIM3_Type* p, uint32_t val) {
	p->CCR4 = (p->CCR4 & ~TIM3_CCR4_CCR4_L) | ((val << 0) & TIM3_CCR4_CCR4_L);
}
inline uint32_t tim3_ccr4_get_ccr4_h(struct TIM3_Type* p) { return (p->CCR4 & TIM3_CCR4_CCR4_H) >> 16; }
inline uint32_t tim3_ccr4_get_ccr4_l(struct TIM3_Type* p) { return (p->CCR4 & TIM3_CCR4_CCR4_L) >> 0; }

// TIM3->DCR DMA control register
enum {
	TIM3_DCR_DBL = ((1UL << 5) - 1) << 8, // DMA burst length
	TIM3_DCR_DBA = ((1UL << 5) - 1) << 0, // DMA base address
};
inline void     tim3_dcr_set_dbl(struct TIM3_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM3_DCR_DBL) | ((val << 8) & TIM3_DCR_DBL); }
inline void     tim3_dcr_set_dba(struct TIM3_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM3_DCR_DBA) | ((val << 0) & TIM3_DCR_DBA); }
inline uint32_t tim3_dcr_get_dbl(struct TIM3_Type* p) { return (p->DCR & TIM3_DCR_DBL) >> 8; }
inline uint32_t tim3_dcr_get_dba(struct TIM3_Type* p) { return (p->DCR & TIM3_DCR_DBA) >> 0; }

// Valid Casts:

inline struct BasicTimer_Type* TIM3_as_BasicTimer_Type(struct TIM3_Type* p) { return (struct BasicTimer_Type*)p; }

/* General-purpose-timers */
struct TIM5_Type {
	__IO uint16_t CR1;              // @0 control register 1
	uint8_t       RESERVED0[2];     // @2
	__IO uint8_t CR2;               // @4 control register 2
	uint8_t      RESERVED1[3];      // @5
	__IO uint16_t SMCR;             // @8 slave mode control register
	uint8_t       RESERVED2[2];     // @10
	__IO uint16_t DIER;             // @12 DMA/Interrupt enable register
	uint8_t       RESERVED3[2];     // @14
	__IO uint16_t SR;               // @16 status register
	uint8_t       RESERVED4[2];     // @18
	__O uint8_t EGR;                // @20 event generation register
	uint8_t     RESERVED5[3];       // @21
	union {                         // @24
		__IO uint16_t CCMR1_Output; // capture/compare mode register 1 (output mode)
		__IO uint16_t CCMR1_Input;  // capture/compare mode register 1 (input mode)
	};
	uint8_t RESERVED6[2];           // @26
	union {                         // @28
		__IO uint16_t CCMR2_Output; // capture/compare mode register 2 (output mode)
		__IO uint16_t CCMR2_Input;  // capture/compare mode register 2 (input mode)
	};
	uint8_t RESERVED7[2];        // @30
	__IO uint16_t CCER;          // @32 capture/compare enable register
	uint8_t       RESERVED8[2];  // @34
	__IO uint32_t CNT;           // @36 counter
	__IO uint16_t PSC;           // @40 prescaler
	uint8_t       RESERVED9[2];  // @42
	__IO uint32_t ARR;           // @44 auto-reload register
	uint8_t       RESERVED10[4]; // @48
	__IO uint32_t CCR1;          // @52 capture/compare register 1
	__IO uint32_t CCR2;          // @56 capture/compare register 2
	__IO uint32_t CCR3;          // @60 capture/compare register 3
	__IO uint32_t CCR4;          // @64 capture/compare register 4
	uint8_t       RESERVED11[4]; // @68
	__IO uint16_t DCR;           // @72 DMA control register
	uint8_t       RESERVED12[2]; // @74
	__IO uint16_t DMAR;          // @76 DMA address for full transfer
	uint8_t       RESERVED13[2]; // @78
	__IO uint8_t OR;             // @80 TIM5 option register
};

// TIM5->CR1 control register 1
enum {
	TIM5_CR1_CKD  = ((1UL << 2) - 1) << 8, // Clock division
	TIM5_CR1_ARPE = 1UL << 7,              // Auto-reload preload enable
	TIM5_CR1_CMS  = ((1UL << 2) - 1) << 5, // Center-aligned mode selection
	TIM5_CR1_DIR  = 1UL << 4,              // Direction
	TIM5_CR1_OPM  = 1UL << 3,              // One-pulse mode
	TIM5_CR1_URS  = 1UL << 2,              // Update request source
	TIM5_CR1_UDIS = 1UL << 1,              // Update disable
	TIM5_CR1_CEN  = 1UL << 0,              // Counter enable
};
inline void     tim5_cr1_set_ckd(struct TIM5_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM5_CR1_CKD) | ((val << 8) & TIM5_CR1_CKD); }
inline void     tim5_cr1_set_cms(struct TIM5_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM5_CR1_CMS) | ((val << 5) & TIM5_CR1_CMS); }
inline uint32_t tim5_cr1_get_ckd(struct TIM5_Type* p) { return (p->CR1 & TIM5_CR1_CKD) >> 8; }
inline uint32_t tim5_cr1_get_cms(struct TIM5_Type* p) { return (p->CR1 & TIM5_CR1_CMS) >> 5; }

// TIM5->CR2 control register 2
enum {
	TIM5_CR2_TI1S = 1UL << 7,              // TI1 selection
	TIM5_CR2_MMS  = ((1UL << 3) - 1) << 4, // Master mode selection
	TIM5_CR2_CCDS = 1UL << 3,              // Capture/compare DMA selection
};
inline void     tim5_cr2_set_mms(struct TIM5_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM5_CR2_MMS) | ((val << 4) & TIM5_CR2_MMS); }
inline uint32_t tim5_cr2_get_mms(struct TIM5_Type* p) { return (p->CR2 & TIM5_CR2_MMS) >> 4; }

// TIM5->SMCR slave mode control register
enum {
	TIM5_SMCR_ETP  = 1UL << 15,              // External trigger polarity
	TIM5_SMCR_ECE  = 1UL << 14,              // External clock enable
	TIM5_SMCR_ETPS = ((1UL << 2) - 1) << 12, // External trigger prescaler
	TIM5_SMCR_ETF  = ((1UL << 4) - 1) << 8,  // External trigger filter
	TIM5_SMCR_MSM  = 1UL << 7,               // Master/Slave mode
	TIM5_SMCR_TS   = ((1UL << 3) - 1) << 4,  // Trigger selection
	TIM5_SMCR_SMS  = ((1UL << 3) - 1) << 0,  // Slave mode selection
};
inline void tim5_smcr_set_etps(struct TIM5_Type* p, uint32_t val) {
	p->SMCR = (p->SMCR & ~TIM5_SMCR_ETPS) | ((val << 12) & TIM5_SMCR_ETPS);
}
inline void tim5_smcr_set_etf(struct TIM5_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM5_SMCR_ETF) | ((val << 8) & TIM5_SMCR_ETF); }
inline void tim5_smcr_set_ts(struct TIM5_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM5_SMCR_TS) | ((val << 4) & TIM5_SMCR_TS); }
inline void tim5_smcr_set_sms(struct TIM5_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM5_SMCR_SMS) | ((val << 0) & TIM5_SMCR_SMS); }
inline uint32_t tim5_smcr_get_etps(struct TIM5_Type* p) { return (p->SMCR & TIM5_SMCR_ETPS) >> 12; }
inline uint32_t tim5_smcr_get_etf(struct TIM5_Type* p) { return (p->SMCR & TIM5_SMCR_ETF) >> 8; }
inline uint32_t tim5_smcr_get_ts(struct TIM5_Type* p) { return (p->SMCR & TIM5_SMCR_TS) >> 4; }
inline uint32_t tim5_smcr_get_sms(struct TIM5_Type* p) { return (p->SMCR & TIM5_SMCR_SMS) >> 0; }

// TIM5->DIER DMA/Interrupt enable register
enum {
	TIM5_DIER_TDE   = 1UL << 14, // Trigger DMA request enable
	TIM5_DIER_CC4DE = 1UL << 12, // Capture/Compare 4 DMA request enable
	TIM5_DIER_CC3DE = 1UL << 11, // Capture/Compare 3 DMA request enable
	TIM5_DIER_CC2DE = 1UL << 10, // Capture/Compare 2 DMA request enable
	TIM5_DIER_CC1DE = 1UL << 9,  // Capture/Compare 1 DMA request enable
	TIM5_DIER_UDE   = 1UL << 8,  // Update DMA request enable
	TIM5_DIER_TIE   = 1UL << 6,  // Trigger interrupt enable
	TIM5_DIER_CC4IE = 1UL << 4,  // Capture/Compare 4 interrupt enable
	TIM5_DIER_CC3IE = 1UL << 3,  // Capture/Compare 3 interrupt enable
	TIM5_DIER_CC2IE = 1UL << 2,  // Capture/Compare 2 interrupt enable
	TIM5_DIER_CC1IE = 1UL << 1,  // Capture/Compare 1 interrupt enable
	TIM5_DIER_UIE   = 1UL << 0,  // Update interrupt enable
};

// TIM5->SR status register
enum {
	TIM5_SR_CC4OF = 1UL << 12, // Capture/Compare 4 overcapture flag
	TIM5_SR_CC3OF = 1UL << 11, // Capture/Compare 3 overcapture flag
	TIM5_SR_CC2OF = 1UL << 10, // Capture/compare 2 overcapture flag
	TIM5_SR_CC1OF = 1UL << 9,  // Capture/Compare 1 overcapture flag
	TIM5_SR_TIF   = 1UL << 6,  // Trigger interrupt flag
	TIM5_SR_CC4IF = 1UL << 4,  // Capture/Compare 4 interrupt flag
	TIM5_SR_CC3IF = 1UL << 3,  // Capture/Compare 3 interrupt flag
	TIM5_SR_CC2IF = 1UL << 2,  // Capture/Compare 2 interrupt flag
	TIM5_SR_CC1IF = 1UL << 1,  // Capture/compare 1 interrupt flag
	TIM5_SR_UIF   = 1UL << 0,  // Update interrupt flag
};

// TIM5->EGR event generation register
enum {
	TIM5_EGR_TG   = 1UL << 6, // Trigger generation
	TIM5_EGR_CC4G = 1UL << 4, // Capture/compare 4 generation
	TIM5_EGR_CC3G = 1UL << 3, // Capture/compare 3 generation
	TIM5_EGR_CC2G = 1UL << 2, // Capture/compare 2 generation
	TIM5_EGR_CC1G = 1UL << 1, // Capture/compare 1 generation
	TIM5_EGR_UG   = 1UL << 0, // Update generation
};

// TIM5->CCMR1_Output capture/compare mode register 1 (output mode)
enum {
	TIM5_CCMR1_OUTPUT_OC2CE = 1UL << 15,              // OC2CE
	TIM5_CCMR1_OUTPUT_OC2M  = ((1UL << 3) - 1) << 12, // OC2M
	TIM5_CCMR1_OUTPUT_OC2PE = 1UL << 11,              // OC2PE
	TIM5_CCMR1_OUTPUT_OC2FE = 1UL << 10,              // OC2FE
	TIM5_CCMR1_OUTPUT_CC2S  = ((1UL << 2) - 1) << 8,  // CC2S
	TIM5_CCMR1_OUTPUT_OC1CE = 1UL << 7,               // OC1CE
	TIM5_CCMR1_OUTPUT_OC1M  = ((1UL << 3) - 1) << 4,  // OC1M
	TIM5_CCMR1_OUTPUT_OC1PE = 1UL << 3,               // OC1PE
	TIM5_CCMR1_OUTPUT_OC1FE = 1UL << 2,               // OC1FE
	TIM5_CCMR1_OUTPUT_CC1S  = ((1UL << 2) - 1) << 0,  // CC1S
};
inline void tim5_ccmr1_output_set_oc2m(struct TIM5_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM5_CCMR1_OUTPUT_OC2M) | ((val << 12) & TIM5_CCMR1_OUTPUT_OC2M);
}
inline void tim5_ccmr1_output_set_cc2s(struct TIM5_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM5_CCMR1_OUTPUT_CC2S) | ((val << 8) & TIM5_CCMR1_OUTPUT_CC2S);
}
inline void tim5_ccmr1_output_set_oc1m(struct TIM5_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM5_CCMR1_OUTPUT_OC1M) | ((val << 4) & TIM5_CCMR1_OUTPUT_OC1M);
}
inline void tim5_ccmr1_output_set_cc1s(struct TIM5_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM5_CCMR1_OUTPUT_CC1S) | ((val << 0) & TIM5_CCMR1_OUTPUT_CC1S);
}
inline uint32_t tim5_ccmr1_output_get_oc2m(struct TIM5_Type* p) { return (p->CCMR1_Output & TIM5_CCMR1_OUTPUT_OC2M) >> 12; }
inline uint32_t tim5_ccmr1_output_get_cc2s(struct TIM5_Type* p) { return (p->CCMR1_Output & TIM5_CCMR1_OUTPUT_CC2S) >> 8; }
inline uint32_t tim5_ccmr1_output_get_oc1m(struct TIM5_Type* p) { return (p->CCMR1_Output & TIM5_CCMR1_OUTPUT_OC1M) >> 4; }
inline uint32_t tim5_ccmr1_output_get_cc1s(struct TIM5_Type* p) { return (p->CCMR1_Output & TIM5_CCMR1_OUTPUT_CC1S) >> 0; }

// TIM5->CCMR2_Output capture/compare mode register 2 (output mode)
enum {
	TIM5_CCMR2_OUTPUT_O24CE = 1UL << 15,              // O24CE
	TIM5_CCMR2_OUTPUT_OC4M  = ((1UL << 3) - 1) << 12, // OC4M
	TIM5_CCMR2_OUTPUT_OC4PE = 1UL << 11,              // OC4PE
	TIM5_CCMR2_OUTPUT_OC4FE = 1UL << 10,              // OC4FE
	TIM5_CCMR2_OUTPUT_CC4S  = ((1UL << 2) - 1) << 8,  // CC4S
	TIM5_CCMR2_OUTPUT_OC3CE = 1UL << 7,               // OC3CE
	TIM5_CCMR2_OUTPUT_OC3M  = ((1UL << 3) - 1) << 4,  // OC3M
	TIM5_CCMR2_OUTPUT_OC3PE = 1UL << 3,               // OC3PE
	TIM5_CCMR2_OUTPUT_OC3FE = 1UL << 2,               // OC3FE
	TIM5_CCMR2_OUTPUT_CC3S  = ((1UL << 2) - 1) << 0,  // CC3S
};
inline void tim5_ccmr2_output_set_oc4m(struct TIM5_Type* p, uint32_t val) {
	p->CCMR2_Output = (p->CCMR2_Output & ~TIM5_CCMR2_OUTPUT_OC4M) | ((val << 12) & TIM5_CCMR2_OUTPUT_OC4M);
}
inline void tim5_ccmr2_output_set_cc4s(struct TIM5_Type* p, uint32_t val) {
	p->CCMR2_Output = (p->CCMR2_Output & ~TIM5_CCMR2_OUTPUT_CC4S) | ((val << 8) & TIM5_CCMR2_OUTPUT_CC4S);
}
inline void tim5_ccmr2_output_set_oc3m(struct TIM5_Type* p, uint32_t val) {
	p->CCMR2_Output = (p->CCMR2_Output & ~TIM5_CCMR2_OUTPUT_OC3M) | ((val << 4) & TIM5_CCMR2_OUTPUT_OC3M);
}
inline void tim5_ccmr2_output_set_cc3s(struct TIM5_Type* p, uint32_t val) {
	p->CCMR2_Output = (p->CCMR2_Output & ~TIM5_CCMR2_OUTPUT_CC3S) | ((val << 0) & TIM5_CCMR2_OUTPUT_CC3S);
}
inline uint32_t tim5_ccmr2_output_get_oc4m(struct TIM5_Type* p) { return (p->CCMR2_Output & TIM5_CCMR2_OUTPUT_OC4M) >> 12; }
inline uint32_t tim5_ccmr2_output_get_cc4s(struct TIM5_Type* p) { return (p->CCMR2_Output & TIM5_CCMR2_OUTPUT_CC4S) >> 8; }
inline uint32_t tim5_ccmr2_output_get_oc3m(struct TIM5_Type* p) { return (p->CCMR2_Output & TIM5_CCMR2_OUTPUT_OC3M) >> 4; }
inline uint32_t tim5_ccmr2_output_get_cc3s(struct TIM5_Type* p) { return (p->CCMR2_Output & TIM5_CCMR2_OUTPUT_CC3S) >> 0; }

// TIM5->CCER capture/compare enable register
enum {
	TIM5_CCER_CC4NP = 1UL << 15, // Capture/Compare 4 output Polarity
	TIM5_CCER_CC4P  = 1UL << 13, // Capture/Compare 3 output Polarity
	TIM5_CCER_CC4E  = 1UL << 12, // Capture/Compare 4 output enable
	TIM5_CCER_CC3NP = 1UL << 11, // Capture/Compare 3 output Polarity
	TIM5_CCER_CC3P  = 1UL << 9,  // Capture/Compare 3 output Polarity
	TIM5_CCER_CC3E  = 1UL << 8,  // Capture/Compare 3 output enable
	TIM5_CCER_CC2NP = 1UL << 7,  // Capture/Compare 2 output Polarity
	TIM5_CCER_CC2P  = 1UL << 5,  // Capture/Compare 2 output Polarity
	TIM5_CCER_CC2E  = 1UL << 4,  // Capture/Compare 2 output enable
	TIM5_CCER_CC1NP = 1UL << 3,  // Capture/Compare 1 output Polarity
	TIM5_CCER_CC1P  = 1UL << 1,  // Capture/Compare 1 output Polarity
	TIM5_CCER_CC1E  = 1UL << 0,  // Capture/Compare 1 output enable
};

// TIM5->CNT counter
enum {
	TIM5_CNT_CNT_H = ((1UL << 16) - 1) << 16, // High counter value
	TIM5_CNT_CNT_L = ((1UL << 16) - 1) << 0,  // Low counter value
};
inline void tim5_cnt_set_cnt_h(struct TIM5_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM5_CNT_CNT_H) | ((val << 16) & TIM5_CNT_CNT_H); }
inline void tim5_cnt_set_cnt_l(struct TIM5_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM5_CNT_CNT_L) | ((val << 0) & TIM5_CNT_CNT_L); }
inline uint32_t tim5_cnt_get_cnt_h(struct TIM5_Type* p) { return (p->CNT & TIM5_CNT_CNT_H) >> 16; }
inline uint32_t tim5_cnt_get_cnt_l(struct TIM5_Type* p) { return (p->CNT & TIM5_CNT_CNT_L) >> 0; }

// TIM5->ARR auto-reload register
enum {
	TIM5_ARR_ARR_H = ((1UL << 16) - 1) << 16, // High Auto-reload value
	TIM5_ARR_ARR_L = ((1UL << 16) - 1) << 0,  // Low Auto-reload value
};
inline void tim5_arr_set_arr_h(struct TIM5_Type* p, uint32_t val) { p->ARR = (p->ARR & ~TIM5_ARR_ARR_H) | ((val << 16) & TIM5_ARR_ARR_H); }
inline void tim5_arr_set_arr_l(struct TIM5_Type* p, uint32_t val) { p->ARR = (p->ARR & ~TIM5_ARR_ARR_L) | ((val << 0) & TIM5_ARR_ARR_L); }
inline uint32_t tim5_arr_get_arr_h(struct TIM5_Type* p) { return (p->ARR & TIM5_ARR_ARR_H) >> 16; }
inline uint32_t tim5_arr_get_arr_l(struct TIM5_Type* p) { return (p->ARR & TIM5_ARR_ARR_L) >> 0; }

// TIM5->CCR1 capture/compare register 1
enum {
	TIM5_CCR1_CCR1_H = ((1UL << 16) - 1) << 16, // High Capture/Compare 1 value
	TIM5_CCR1_CCR1_L = ((1UL << 16) - 1) << 0,  // Low Capture/Compare 1 value
};
inline void tim5_ccr1_set_ccr1_h(struct TIM5_Type* p, uint32_t val) {
	p->CCR1 = (p->CCR1 & ~TIM5_CCR1_CCR1_H) | ((val << 16) & TIM5_CCR1_CCR1_H);
}
inline void tim5_ccr1_set_ccr1_l(struct TIM5_Type* p, uint32_t val) {
	p->CCR1 = (p->CCR1 & ~TIM5_CCR1_CCR1_L) | ((val << 0) & TIM5_CCR1_CCR1_L);
}
inline uint32_t tim5_ccr1_get_ccr1_h(struct TIM5_Type* p) { return (p->CCR1 & TIM5_CCR1_CCR1_H) >> 16; }
inline uint32_t tim5_ccr1_get_ccr1_l(struct TIM5_Type* p) { return (p->CCR1 & TIM5_CCR1_CCR1_L) >> 0; }

// TIM5->CCR2 capture/compare register 2
enum {
	TIM5_CCR2_CCR2_H = ((1UL << 16) - 1) << 16, // High Capture/Compare 2 value
	TIM5_CCR2_CCR2_L = ((1UL << 16) - 1) << 0,  // Low Capture/Compare 2 value
};
inline void tim5_ccr2_set_ccr2_h(struct TIM5_Type* p, uint32_t val) {
	p->CCR2 = (p->CCR2 & ~TIM5_CCR2_CCR2_H) | ((val << 16) & TIM5_CCR2_CCR2_H);
}
inline void tim5_ccr2_set_ccr2_l(struct TIM5_Type* p, uint32_t val) {
	p->CCR2 = (p->CCR2 & ~TIM5_CCR2_CCR2_L) | ((val << 0) & TIM5_CCR2_CCR2_L);
}
inline uint32_t tim5_ccr2_get_ccr2_h(struct TIM5_Type* p) { return (p->CCR2 & TIM5_CCR2_CCR2_H) >> 16; }
inline uint32_t tim5_ccr2_get_ccr2_l(struct TIM5_Type* p) { return (p->CCR2 & TIM5_CCR2_CCR2_L) >> 0; }

// TIM5->CCR3 capture/compare register 3
enum {
	TIM5_CCR3_CCR3_H = ((1UL << 16) - 1) << 16, // High Capture/Compare value
	TIM5_CCR3_CCR3_L = ((1UL << 16) - 1) << 0,  // Low Capture/Compare value
};
inline void tim5_ccr3_set_ccr3_h(struct TIM5_Type* p, uint32_t val) {
	p->CCR3 = (p->CCR3 & ~TIM5_CCR3_CCR3_H) | ((val << 16) & TIM5_CCR3_CCR3_H);
}
inline void tim5_ccr3_set_ccr3_l(struct TIM5_Type* p, uint32_t val) {
	p->CCR3 = (p->CCR3 & ~TIM5_CCR3_CCR3_L) | ((val << 0) & TIM5_CCR3_CCR3_L);
}
inline uint32_t tim5_ccr3_get_ccr3_h(struct TIM5_Type* p) { return (p->CCR3 & TIM5_CCR3_CCR3_H) >> 16; }
inline uint32_t tim5_ccr3_get_ccr3_l(struct TIM5_Type* p) { return (p->CCR3 & TIM5_CCR3_CCR3_L) >> 0; }

// TIM5->CCR4 capture/compare register 4
enum {
	TIM5_CCR4_CCR4_H = ((1UL << 16) - 1) << 16, // High Capture/Compare value
	TIM5_CCR4_CCR4_L = ((1UL << 16) - 1) << 0,  // Low Capture/Compare value
};
inline void tim5_ccr4_set_ccr4_h(struct TIM5_Type* p, uint32_t val) {
	p->CCR4 = (p->CCR4 & ~TIM5_CCR4_CCR4_H) | ((val << 16) & TIM5_CCR4_CCR4_H);
}
inline void tim5_ccr4_set_ccr4_l(struct TIM5_Type* p, uint32_t val) {
	p->CCR4 = (p->CCR4 & ~TIM5_CCR4_CCR4_L) | ((val << 0) & TIM5_CCR4_CCR4_L);
}
inline uint32_t tim5_ccr4_get_ccr4_h(struct TIM5_Type* p) { return (p->CCR4 & TIM5_CCR4_CCR4_H) >> 16; }
inline uint32_t tim5_ccr4_get_ccr4_l(struct TIM5_Type* p) { return (p->CCR4 & TIM5_CCR4_CCR4_L) >> 0; }

// TIM5->DCR DMA control register
enum {
	TIM5_DCR_DBL = ((1UL << 5) - 1) << 8, // DMA burst length
	TIM5_DCR_DBA = ((1UL << 5) - 1) << 0, // DMA base address
};
inline void     tim5_dcr_set_dbl(struct TIM5_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM5_DCR_DBL) | ((val << 8) & TIM5_DCR_DBL); }
inline void     tim5_dcr_set_dba(struct TIM5_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM5_DCR_DBA) | ((val << 0) & TIM5_DCR_DBA); }
inline uint32_t tim5_dcr_get_dbl(struct TIM5_Type* p) { return (p->DCR & TIM5_DCR_DBL) >> 8; }
inline uint32_t tim5_dcr_get_dba(struct TIM5_Type* p) { return (p->DCR & TIM5_DCR_DBA) >> 0; }

// TIM5->OR TIM5 option register
enum {
	TIM5_OR_IT4_RMP = ((1UL << 2) - 1) << 6, // Timer Input 4 remap
};
inline void tim5_or_set_it4_rmp(struct TIM5_Type* p, uint32_t val) { p->OR = (p->OR & ~TIM5_OR_IT4_RMP) | ((val << 6) & TIM5_OR_IT4_RMP); }
inline uint32_t tim5_or_get_it4_rmp(struct TIM5_Type* p) { return (p->OR & TIM5_OR_IT4_RMP) >> 6; }

// Valid Casts:

inline struct TIM3_Type* TIM5_as_TIM3_Type(struct TIM5_Type* p) { return (struct TIM3_Type*)p; }

inline struct BasicTimer_Type* TIM5_as_BasicTimer_Type(struct TIM5_Type* p) { return (struct BasicTimer_Type*)p; }

/* General purpose timers */
struct TIM9_Type {
	__IO uint16_t CR1;              // @0 control register 1
	uint8_t       RESERVED0[2];     // @2
	__IO uint8_t CR2;               // @4 control register 2
	uint8_t      RESERVED1[3];      // @5
	__IO uint8_t SMCR;              // @8 slave mode control register
	uint8_t      RESERVED2[3];      // @9
	__IO uint8_t DIER;              // @12 DMA/Interrupt enable register
	uint8_t      RESERVED3[3];      // @13
	__IO uint16_t SR;               // @16 status register
	uint8_t       RESERVED4[2];     // @18
	__O uint8_t EGR;                // @20 event generation register
	uint8_t     RESERVED5[3];       // @21
	union {                         // @24
		__IO uint16_t CCMR1_Output; // capture/compare mode register 1 (output mode)
		__IO uint16_t CCMR1_Input;  // capture/compare mode register 1 (input mode)
	};
	uint8_t RESERVED6[6];        // @26
	__IO uint8_t CCER;           // @32 capture/compare enable register
	uint8_t      RESERVED7[3];   // @33
	__IO uint16_t CNT;           // @36 counter
	uint8_t       RESERVED8[2];  // @38
	__IO uint16_t PSC;           // @40 prescaler
	uint8_t       RESERVED9[2];  // @42
	__IO uint16_t ARR;           // @44 auto-reload register
	uint8_t       RESERVED10[6]; // @46
	__IO uint16_t CCR1;          // @52 capture/compare register 1
	uint8_t       RESERVED11[2]; // @54
	__IO uint16_t CCR2;          // @56 capture/compare register 2
};

// TIM9->CR1 control register 1
enum {
	TIM9_CR1_CKD  = ((1UL << 2) - 1) << 8, // Clock division
	TIM9_CR1_ARPE = 1UL << 7,              // Auto-reload preload enable
	TIM9_CR1_OPM  = 1UL << 3,              // One-pulse mode
	TIM9_CR1_URS  = 1UL << 2,              // Update request source
	TIM9_CR1_UDIS = 1UL << 1,              // Update disable
	TIM9_CR1_CEN  = 1UL << 0,              // Counter enable
};
inline void     tim9_cr1_set_ckd(struct TIM9_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM9_CR1_CKD) | ((val << 8) & TIM9_CR1_CKD); }
inline uint32_t tim9_cr1_get_ckd(struct TIM9_Type* p) { return (p->CR1 & TIM9_CR1_CKD) >> 8; }

// TIM9->CR2 control register 2
enum {
	TIM9_CR2_MMS = ((1UL << 3) - 1) << 4, // Master mode selection
};
inline void     tim9_cr2_set_mms(struct TIM9_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM9_CR2_MMS) | ((val << 4) & TIM9_CR2_MMS); }
inline uint32_t tim9_cr2_get_mms(struct TIM9_Type* p) { return (p->CR2 & TIM9_CR2_MMS) >> 4; }

// TIM9->SMCR slave mode control register
enum {
	TIM9_SMCR_MSM = 1UL << 7,              // Master/Slave mode
	TIM9_SMCR_TS  = ((1UL << 3) - 1) << 4, // Trigger selection
	TIM9_SMCR_SMS = ((1UL << 3) - 1) << 0, // Slave mode selection
};
inline void tim9_smcr_set_ts(struct TIM9_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM9_SMCR_TS) | ((val << 4) & TIM9_SMCR_TS); }
inline void tim9_smcr_set_sms(struct TIM9_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM9_SMCR_SMS) | ((val << 0) & TIM9_SMCR_SMS); }
inline uint32_t tim9_smcr_get_ts(struct TIM9_Type* p) { return (p->SMCR & TIM9_SMCR_TS) >> 4; }
inline uint32_t tim9_smcr_get_sms(struct TIM9_Type* p) { return (p->SMCR & TIM9_SMCR_SMS) >> 0; }

// TIM9->DIER DMA/Interrupt enable register
enum {
	TIM9_DIER_TIE   = 1UL << 6, // Trigger interrupt enable
	TIM9_DIER_CC2IE = 1UL << 2, // Capture/Compare 2 interrupt enable
	TIM9_DIER_CC1IE = 1UL << 1, // Capture/Compare 1 interrupt enable
	TIM9_DIER_UIE   = 1UL << 0, // Update interrupt enable
};

// TIM9->SR status register
enum {
	TIM9_SR_CC2OF = 1UL << 10, // Capture/compare 2 overcapture flag
	TIM9_SR_CC1OF = 1UL << 9,  // Capture/Compare 1 overcapture flag
	TIM9_SR_TIF   = 1UL << 6,  // Trigger interrupt flag
	TIM9_SR_CC2IF = 1UL << 2,  // Capture/Compare 2 interrupt flag
	TIM9_SR_CC1IF = 1UL << 1,  // Capture/compare 1 interrupt flag
	TIM9_SR_UIF   = 1UL << 0,  // Update interrupt flag
};

// TIM9->EGR event generation register
enum {
	TIM9_EGR_TG   = 1UL << 6, // Trigger generation
	TIM9_EGR_CC2G = 1UL << 2, // Capture/compare 2 generation
	TIM9_EGR_CC1G = 1UL << 1, // Capture/compare 1 generation
	TIM9_EGR_UG   = 1UL << 0, // Update generation
};

// TIM9->CCMR1_Output capture/compare mode register 1 (output mode)
enum {
	TIM9_CCMR1_OUTPUT_OC2M  = ((1UL << 3) - 1) << 12, // Output Compare 2 mode
	TIM9_CCMR1_OUTPUT_OC2PE = 1UL << 11,              // Output Compare 2 preload enable
	TIM9_CCMR1_OUTPUT_OC2FE = 1UL << 10,              // Output Compare 2 fast enable
	TIM9_CCMR1_OUTPUT_CC2S  = ((1UL << 2) - 1) << 8,  // Capture/Compare 2 selection
	TIM9_CCMR1_OUTPUT_OC1M  = ((1UL << 3) - 1) << 4,  // Output Compare 1 mode
	TIM9_CCMR1_OUTPUT_OC1PE = 1UL << 3,               // Output Compare 1 preload enable
	TIM9_CCMR1_OUTPUT_OC1FE = 1UL << 2,               // Output Compare 1 fast enable
	TIM9_CCMR1_OUTPUT_CC1S  = ((1UL << 2) - 1) << 0,  // Capture/Compare 1 selection
};
inline void tim9_ccmr1_output_set_oc2m(struct TIM9_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM9_CCMR1_OUTPUT_OC2M) | ((val << 12) & TIM9_CCMR1_OUTPUT_OC2M);
}
inline void tim9_ccmr1_output_set_cc2s(struct TIM9_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM9_CCMR1_OUTPUT_CC2S) | ((val << 8) & TIM9_CCMR1_OUTPUT_CC2S);
}
inline void tim9_ccmr1_output_set_oc1m(struct TIM9_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM9_CCMR1_OUTPUT_OC1M) | ((val << 4) & TIM9_CCMR1_OUTPUT_OC1M);
}
inline void tim9_ccmr1_output_set_cc1s(struct TIM9_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM9_CCMR1_OUTPUT_CC1S) | ((val << 0) & TIM9_CCMR1_OUTPUT_CC1S);
}
inline uint32_t tim9_ccmr1_output_get_oc2m(struct TIM9_Type* p) { return (p->CCMR1_Output & TIM9_CCMR1_OUTPUT_OC2M) >> 12; }
inline uint32_t tim9_ccmr1_output_get_cc2s(struct TIM9_Type* p) { return (p->CCMR1_Output & TIM9_CCMR1_OUTPUT_CC2S) >> 8; }
inline uint32_t tim9_ccmr1_output_get_oc1m(struct TIM9_Type* p) { return (p->CCMR1_Output & TIM9_CCMR1_OUTPUT_OC1M) >> 4; }
inline uint32_t tim9_ccmr1_output_get_cc1s(struct TIM9_Type* p) { return (p->CCMR1_Output & TIM9_CCMR1_OUTPUT_CC1S) >> 0; }

// TIM9->CCER capture/compare enable register
enum {
	TIM9_CCER_CC2NP = 1UL << 7, // Capture/Compare 2 output Polarity
	TIM9_CCER_CC2P  = 1UL << 5, // Capture/Compare 2 output Polarity
	TIM9_CCER_CC2E  = 1UL << 4, // Capture/Compare 2 output enable
	TIM9_CCER_CC1NP = 1UL << 3, // Capture/Compare 1 output Polarity
	TIM9_CCER_CC1P  = 1UL << 1, // Capture/Compare 1 output Polarity
	TIM9_CCER_CC1E  = 1UL << 0, // Capture/Compare 1 output enable
};

// Valid Casts:

inline struct BasicTimer_Type* TIM9_as_BasicTimer_Type(struct TIM9_Type* p) { return (struct BasicTimer_Type*)p; }

/* Universal synchronous asynchronous receiver transmitter */
struct USART1_Type {
	__IO uint16_t SR;           // @0 Status register
	uint8_t       RESERVED0[2]; // @2
	__IO uint16_t DR;           // @4 Data register
	uint8_t       RESERVED1[2]; // @6
	__IO uint16_t BRR;          // @8 Baud rate register
	uint8_t       RESERVED2[2]; // @10
	__IO uint16_t CR1;          // @12 Control register 1
	uint8_t       RESERVED3[2]; // @14
	__IO uint16_t CR2;          // @16 Control register 2
	uint8_t       RESERVED4[2]; // @18
	__IO uint16_t CR3;          // @20 Control register 3
	uint8_t       RESERVED5[2]; // @22
	__IO uint16_t GTPR;         // @24 Guard time and prescaler register
};

// USART1->SR Status register
enum {
	USART1_SR_CTS  = 1UL << 9, // CTS flag
	USART1_SR_LBD  = 1UL << 8, // LIN break detection flag
	USART1_SR_TXE  = 1UL << 7, // Transmit data register empty
	USART1_SR_TC   = 1UL << 6, // Transmission complete
	USART1_SR_RXNE = 1UL << 5, // Read data register not empty
	USART1_SR_IDLE = 1UL << 4, // IDLE line detected
	USART1_SR_ORE  = 1UL << 3, // Overrun error
	USART1_SR_NF   = 1UL << 2, // Noise detected flag
	USART1_SR_FE   = 1UL << 1, // Framing error
	USART1_SR_PE   = 1UL << 0, // Parity error
};

// USART1->DR Data register
enum {
	USART1_DR_DR = ((1UL << 9) - 1) << 0, // Data value
};
inline void     usart1_dr_set_dr(struct USART1_Type* p, uint32_t val) { p->DR = (p->DR & ~USART1_DR_DR) | ((val << 0) & USART1_DR_DR); }
inline uint32_t usart1_dr_get_dr(struct USART1_Type* p) { return (p->DR & USART1_DR_DR) >> 0; }

// USART1->BRR Baud rate register
enum {
	USART1_BRR_DIV_MANTISSA = ((1UL << 12) - 1) << 4, // mantissa of USARTDIV
	USART1_BRR_DIV_FRACTION = ((1UL << 4) - 1) << 0,  // fraction of USARTDIV
};
inline void usart1_brr_set_div_mantissa(struct USART1_Type* p, uint32_t val) {
	p->BRR = (p->BRR & ~USART1_BRR_DIV_MANTISSA) | ((val << 4) & USART1_BRR_DIV_MANTISSA);
}
inline void usart1_brr_set_div_fraction(struct USART1_Type* p, uint32_t val) {
	p->BRR = (p->BRR & ~USART1_BRR_DIV_FRACTION) | ((val << 0) & USART1_BRR_DIV_FRACTION);
}
inline uint32_t usart1_brr_get_div_mantissa(struct USART1_Type* p) { return (p->BRR & USART1_BRR_DIV_MANTISSA) >> 4; }
inline uint32_t usart1_brr_get_div_fraction(struct USART1_Type* p) { return (p->BRR & USART1_BRR_DIV_FRACTION) >> 0; }

// USART1->CR1 Control register 1
enum {
	USART1_CR1_OVER8  = 1UL << 15, // Oversampling mode
	USART1_CR1_UE     = 1UL << 13, // USART enable
	USART1_CR1_M      = 1UL << 12, // Word length
	USART1_CR1_WAKE   = 1UL << 11, // Wakeup method
	USART1_CR1_PCE    = 1UL << 10, // Parity control enable
	USART1_CR1_PS     = 1UL << 9,  // Parity selection
	USART1_CR1_PEIE   = 1UL << 8,  // PE interrupt enable
	USART1_CR1_TXEIE  = 1UL << 7,  // TXE interrupt enable
	USART1_CR1_TCIE   = 1UL << 6,  // Transmission complete interrupt enable
	USART1_CR1_RXNEIE = 1UL << 5,  // RXNE interrupt enable
	USART1_CR1_IDLEIE = 1UL << 4,  // IDLE interrupt enable
	USART1_CR1_TE     = 1UL << 3,  // Transmitter enable
	USART1_CR1_RE     = 1UL << 2,  // Receiver enable
	USART1_CR1_RWU    = 1UL << 1,  // Receiver wakeup
	USART1_CR1_SBK    = 1UL << 0,  // Send break
};

// USART1->CR2 Control register 2
enum {
	USART1_CR2_LINEN = 1UL << 14,              // LIN mode enable
	USART1_CR2_STOP  = ((1UL << 2) - 1) << 12, // STOP bits
	USART1_CR2_CLKEN = 1UL << 11,              // Clock enable
	USART1_CR2_CPOL  = 1UL << 10,              // Clock polarity
	USART1_CR2_CPHA  = 1UL << 9,               // Clock phase
	USART1_CR2_LBCL  = 1UL << 8,               // Last bit clock pulse
	USART1_CR2_LBDIE = 1UL << 6,               // LIN break detection interrupt enable
	USART1_CR2_LBDL  = 1UL << 5,               // lin break detection length
	USART1_CR2_ADD   = ((1UL << 4) - 1) << 0,  // Address of the USART node
};
inline void usart1_cr2_set_stop(struct USART1_Type* p, uint32_t val) {
	p->CR2 = (p->CR2 & ~USART1_CR2_STOP) | ((val << 12) & USART1_CR2_STOP);
}
inline void usart1_cr2_set_add(struct USART1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~USART1_CR2_ADD) | ((val << 0) & USART1_CR2_ADD); }
inline uint32_t usart1_cr2_get_stop(struct USART1_Type* p) { return (p->CR2 & USART1_CR2_STOP) >> 12; }
inline uint32_t usart1_cr2_get_add(struct USART1_Type* p) { return (p->CR2 & USART1_CR2_ADD) >> 0; }

// USART1->CR3 Control register 3
enum {
	USART1_CR3_ONEBIT = 1UL << 11, // One sample bit method enable
	USART1_CR3_CTSIE  = 1UL << 10, // CTS interrupt enable
	USART1_CR3_CTSE   = 1UL << 9,  // CTS enable
	USART1_CR3_RTSE   = 1UL << 8,  // RTS enable
	USART1_CR3_DMAT   = 1UL << 7,  // DMA enable transmitter
	USART1_CR3_DMAR   = 1UL << 6,  // DMA enable receiver
	USART1_CR3_SCEN   = 1UL << 5,  // Smartcard mode enable
	USART1_CR3_NACK   = 1UL << 4,  // Smartcard NACK enable
	USART1_CR3_HDSEL  = 1UL << 3,  // Half-duplex selection
	USART1_CR3_IRLP   = 1UL << 2,  // IrDA low-power
	USART1_CR3_IREN   = 1UL << 1,  // IrDA mode enable
	USART1_CR3_EIE    = 1UL << 0,  // Error interrupt enable
};

// USART1->GTPR Guard time and prescaler register
enum {
	USART1_GTPR_GT  = ((1UL << 8) - 1) << 8, // Guard time value
	USART1_GTPR_PSC = ((1UL << 8) - 1) << 0, // Prescaler value
};
inline void usart1_gtpr_set_gt(struct USART1_Type* p, uint32_t val) {
	p->GTPR = (p->GTPR & ~USART1_GTPR_GT) | ((val << 8) & USART1_GTPR_GT);
}
inline void usart1_gtpr_set_psc(struct USART1_Type* p, uint32_t val) {
	p->GTPR = (p->GTPR & ~USART1_GTPR_PSC) | ((val << 0) & USART1_GTPR_PSC);
}
inline uint32_t usart1_gtpr_get_gt(struct USART1_Type* p) { return (p->GTPR & USART1_GTPR_GT) >> 8; }
inline uint32_t usart1_gtpr_get_psc(struct USART1_Type* p) { return (p->GTPR & USART1_GTPR_PSC) >> 0; }

/* Window watchdog */
struct WWDG_Type {
	__IO uint8_t CR;            // @0 Control register
	uint8_t      RESERVED0[3];  // @1
	__IO uint16_t CFR;          // @4 Configuration register
	uint8_t       RESERVED1[2]; // @6
	__IO uint8_t SR;            // @8 Status register
};

// WWDG->CR Control register
enum {
	WWDG_CR_WDGA = 1UL << 7,              // Activation bit
	WWDG_CR_T    = ((1UL << 7) - 1) << 0, // 7-bit counter (MSB to LSB)
};
inline void     wwdg_cr_set_t(struct WWDG_Type* p, uint32_t val) { p->CR = (p->CR & ~WWDG_CR_T) | ((val << 0) & WWDG_CR_T); }
inline uint32_t wwdg_cr_get_t(struct WWDG_Type* p) { return (p->CR & WWDG_CR_T) >> 0; }

// WWDG->CFR Configuration register
enum {
	WWDG_CFR_EWI    = 1UL << 9,              // Early wakeup interrupt
	WWDG_CFR_WDGTB1 = 1UL << 8,              // Timer base
	WWDG_CFR_WDGTB0 = 1UL << 7,              // Timer base
	WWDG_CFR_W      = ((1UL << 7) - 1) << 0, // 7-bit window value
};
inline void     wwdg_cfr_set_w(struct WWDG_Type* p, uint32_t val) { p->CFR = (p->CFR & ~WWDG_CFR_W) | ((val << 0) & WWDG_CFR_W); }
inline uint32_t wwdg_cfr_get_w(struct WWDG_Type* p) { return (p->CFR & WWDG_CFR_W) >> 0; }

// WWDG->SR Status register
enum {
	WWDG_SR_EWIF = 1UL << 0, // Early wakeup interrupt flag
};

/* intersection of all timers */
struct BasicTimer_Type {
	__IO uint16_t CR1;             // @0 control register 1
	uint8_t       RESERVED0[10];   // @2
	__IO uint8_t DIER;             // @12 DMA/Interrupt enable register
	uint8_t      RESERVED1[3];     // @13
	__IO uint16_t SR;              // @16 status register
	uint8_t       RESERVED2[2];    // @18
	__IO uint8_t EGR;              // @20 event generation register
	uint8_t      RESERVED3[3];     // @21
	union {                        // @24
		__IO uint8_t CCMR1_Output; // capture/compare mode register 1 (output mode)
		__IO uint8_t CCMR1_Input;  // capture/compare mode register 1 (input mode)
	};
	uint8_t RESERVED4[7];      // @25
	__IO uint8_t CCER;         // @32 capture/compare enable register
	uint8_t      RESERVED5[7]; // @33
	__IO uint16_t PSC;         // @40 prescaler
};

// BasicTimer->CR1 control register 1
enum {
	BASICTIMER_CR1_CKD  = ((1UL << 2) - 1) << 8, // Clock division
	BASICTIMER_CR1_ARPE = 1UL << 7,              // Auto-reload preload enable
	BASICTIMER_CR1_URS  = 1UL << 2,              // Update request source
	BASICTIMER_CR1_UDIS = 1UL << 1,              // Update disable
	BASICTIMER_CR1_CEN  = 1UL << 0,              // Counter enable
};
inline void basictimer_cr1_set_ckd(struct BasicTimer_Type* p, uint32_t val) {
	p->CR1 = (p->CR1 & ~BASICTIMER_CR1_CKD) | ((val << 8) & BASICTIMER_CR1_CKD);
}
inline uint32_t basictimer_cr1_get_ckd(struct BasicTimer_Type* p) { return (p->CR1 & BASICTIMER_CR1_CKD) >> 8; }

// BasicTimer->DIER DMA/Interrupt enable register
enum {
	BASICTIMER_DIER_CC1IE = 1UL << 1, // Capture/Compare 1 interrupt enable
	BASICTIMER_DIER_UIE   = 1UL << 0, // Update interrupt enable
};

// BasicTimer->SR status register
enum {
	BASICTIMER_SR_CC1OF = 1UL << 9, // Capture/Compare 1 overcapture flag
	BASICTIMER_SR_CC1IF = 1UL << 1, // Capture/compare 1 interrupt flag
	BASICTIMER_SR_UIF   = 1UL << 0, // Update interrupt flag
};

// BasicTimer->EGR event generation register
enum {
	BASICTIMER_EGR_CC1G = 1UL << 1, // Capture/compare 1 generation
	BASICTIMER_EGR_UG   = 1UL << 0, // Update generation
};

// BasicTimer->CCMR1_Output capture/compare mode register 1 (output mode)
enum {
	BASICTIMER_CCMR1_OUTPUT_OC1M  = ((1UL << 3) - 1) << 4, // Output Compare 1 mode
	BASICTIMER_CCMR1_OUTPUT_OC1PE = 1UL << 3,              // Output Compare 1 preload enable
	BASICTIMER_CCMR1_OUTPUT_OC1FE = 1UL << 2,              // Output Compare 1 fast enable
	BASICTIMER_CCMR1_OUTPUT_CC1S  = ((1UL << 2) - 1) << 0, // Capture/Compare 1 selection
};
inline void basictimer_ccmr1_output_set_oc1m(struct BasicTimer_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~BASICTIMER_CCMR1_OUTPUT_OC1M) | ((val << 4) & BASICTIMER_CCMR1_OUTPUT_OC1M);
}
inline void basictimer_ccmr1_output_set_cc1s(struct BasicTimer_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~BASICTIMER_CCMR1_OUTPUT_CC1S) | ((val << 0) & BASICTIMER_CCMR1_OUTPUT_CC1S);
}
inline uint32_t basictimer_ccmr1_output_get_oc1m(struct BasicTimer_Type* p) {
	return (p->CCMR1_Output & BASICTIMER_CCMR1_OUTPUT_OC1M) >> 4;
}
inline uint32_t basictimer_ccmr1_output_get_cc1s(struct BasicTimer_Type* p) {
	return (p->CCMR1_Output & BASICTIMER_CCMR1_OUTPUT_CC1S) >> 0;
}

// BasicTimer->CCER capture/compare enable register
enum {
	BASICTIMER_CCER_CC1NP = 1UL << 3, // Capture/Compare 1 output Polarity
	BASICTIMER_CCER_CC1P  = 1UL << 1, // Capture/Compare 1 output Polarity
	BASICTIMER_CCER_CC1E  = 1UL << 0, // Capture/Compare 1 output enable
};

#undef __I
#undef __O
#undef __IO

struct ADC1_Type          ADC1;          // @0x40012000
struct ADC_COMMON_Type    ADC_COMMON;    // @0x40012300
struct CRC_Type           CRC;           // @0x40023000
struct DBG_Type           DBG;           // @0xE0042000
struct DMA2_Type          DMA1;          // @0x40026000
struct DMA2_Type          DMA2;          // @0x40026400
struct EXTI_Type          EXTI;          // @0x40013C00
struct FLASH_Type         FLASH;         // @0x40023C00
struct FPU_Type           FPU;           // @0xE000EF34
struct FPU_CPACR_Type     FPU_CPACR;     // @0xE000ED88
struct GPIOA_Type         GPIOA;         // @0x40020000
struct GPIOA_Type         GPIOB;         // @0x40020400
struct GPIOA_Type         GPIOC;         // @0x40020800
struct GPIOA_Type         GPIOD;         // @0x40020C00
struct GPIOA_Type         GPIOE;         // @0x40021000
struct GPIOA_Type         GPIOH;         // @0x40021C00
struct I2C3_Type          I2C1;          // @0x40005400
struct I2C3_Type          I2C2;          // @0x40005800
struct I2C3_Type          I2C3;          // @0x40005C00
struct I2S2ext_Type       I2S2ext;       // @0x40003400
struct I2S2ext_Type       I2S3ext;       // @0x40004000
struct IWDG_Type          IWDG;          // @0x40003000
struct MPU_Type           MPU;           // @0xE000ED90
struct NVIC_Type          NVIC;          // @0xE000E100
struct NVIC_STIR_Type     NVIC_STIR;     // @0xE000EF00
struct OTG_FS_DEVICE_Type OTG_FS_DEVICE; // @0x50000800
struct OTG_FS_GLOBAL_Type OTG_FS_GLOBAL; // @0x50000000
struct OTG_FS_HOST_Type   OTG_FS_HOST;   // @0x50000400
struct OTG_FS_PWRCLK_Type OTG_FS_PWRCLK; // @0x50000E00
struct PWR_Type           PWR;           // @0x40007000
struct RCC_Type           RCC;           // @0x40023800
struct RTC_Type           RTC;           // @0x40002800
struct SCB_Type           SCB;           // @0xE000ED00
struct SCB_ACTRL_Type     SCB_ACTRL;     // @0xE000E008
struct SDIO_Type          SDIO;          // @0x40012C00
struct I2S2ext_Type       SPI1;          // @0x40013000
struct I2S2ext_Type       SPI2;          // @0x40003800
struct I2S2ext_Type       SPI3;          // @0x40003C00
struct I2S2ext_Type       SPI4;          // @0x40013400
struct I2S2ext_Type       SPI5;          // @0x40015000
struct STK_Type           STK;           // @0xE000E010
struct SYSCFG_Type        SYSCFG;        // @0x40013800
struct TIM1_Type          TIM1;          // @0x40010000 Also: TIM10_Type BasicTimer_Type
struct TIM10_Type         TIM10;         // @0x40014400 Also: BasicTimer_Type
struct TIM11_Type         TIM11;         // @0x40014800 Also: TIM10_Type BasicTimer_Type
struct TIM2_Type          TIM2;          // @0x40000000 Also: TIM3_Type BasicTimer_Type
struct TIM3_Type          TIM3;          // @0x40000400 Also: BasicTimer_Type
struct TIM3_Type          TIM4;          // @0x40000800
struct TIM5_Type          TIM5;          // @0x40000C00 Also: TIM3_Type BasicTimer_Type
struct TIM1_Type          TIM8;          // @0x40010400
struct TIM9_Type          TIM9;          // @0x40014000 Also: BasicTimer_Type
struct USART1_Type        USART1;        // @0x40011000
struct USART1_Type        USART2;        // @0x40004400
struct USART1_Type        USART6;        // @0x40011400
struct WWDG_Type          WWDG;          // @0x40002C00
